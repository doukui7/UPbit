import streamlit as st
import pyupbit
import pandas as pd
import numpy as np
import plotly.graph_objects as go
from plotly.subplots import make_subplots
from datetime import datetime, timedelta
import time
import os
import requests
from dotenv import load_dotenv
import json
import data_cache

# Import modules
from backtest.engine import BacktestEngine
from trading.upbit_trader import UpbitTrader
from strategy.sma import SMAStrategy
from strategy.donchian import DonchianStrategy
from strategy.widaeri import WDRStrategy
from strategy.dual_momentum import DualMomentumStrategy
from utils.monte_carlo import monte_carlo_equity, kelly_criterion
from utils.correlation_analysis import align_equities, correlation_matrix, equal_weight_portfolio, risk_parity_portfolio, diversification_analysis, portfolio_metrics

# Load environment variables
load_dotenv(override=True)

# --- Configuration Persistence ---
CONFIG_FILE = "user_config.json"

def load_config():
    if os.path.exists(CONFIG_FILE):
        try:
            with open(CONFIG_FILE, "r") as f:
                return json.load(f)
        except:
            return {}
    return {}

def save_config(config):
    with open(CONFIG_FILE, "w") as f:
        json.dump(config, f)
        
config = load_config()

# Cloud ?섍꼍 媛먯? (Streamlit Cloud?먯꽌??HOSTNAME??*.streamlit.app ?먮뒗 /mount/src 寃쎈줈)
IS_CLOUD = os.path.exists("/mount/src") or "streamlit.app" in os.getenv("HOSTNAME", "")

st.set_page_config(page_title="?낅퉬???먮룞留ㅻℓ", layout="wide")

# --- Custom CSS for Better Readability ---
st.markdown("""
    <style>
    /* Global Font Adjustments */
    html, body, [class*="css"] {
        font-size: 18px;
    }
    .stMarkdown p {
        font-size: 18px !important;
    }
    
    /* Metrics */
    [data-testid="stMetricValue"] {
        font-size: 32px !important;
        font-weight: 700 !important;
    }
    [data-testid="stMetricLabel"] {
        font-size: 18px !important;
        color: #666;
    }
    [data-testid="stMetricDelta"] {
        font-size: 16px !important;
    }

    /* Expander Headers */
    .streamlit-expanderHeader {
        font-size: 22px !important;
        font-weight: 600 !important;
        background-color: #f0f2f6;
        border-radius: 5px;
    }
    
    /* Sidebar Input Labels */
    .stNumberInput label, .stTextInput label, .stSelectbox label {
        font-size: 18px !important;
        font-weight: 600 !important;
    }
    
    /* Sidebar Width Override (PC) */
    [data-testid="stSidebar"] {
        min-width: 400px !important;
        max-width: 520px !important;
    }

    /* Tabs */
    button[data-baseweb="tab"] {
        font-size: 18px !important;
        font-weight: 600 !important;
    }

    /* === 湲??寃뱀묠 諛⑹? === */
    [data-testid="stMetricValue"],
    [data-testid="stMetricLabel"],
    [data-testid="stMetricDelta"] {
        overflow: hidden !important;
        text-overflow: ellipsis !important;
        white-space: nowrap !important;
    }
    [data-testid="stHorizontalBlock"] > div {
        overflow: hidden !important;
    }
    [data-testid="column"] {
        overflow: hidden !important;
    }
    /* ??踰꾪듉 寃뱀묠 諛⑹? */
    [data-baseweb="tab-list"] {
        flex-wrap: wrap !important;
        gap: 4px !important;
    }
    /* ??됲듃諛뺤뒪/?명뭼 ?쇰꺼 寃뱀묠 諛⑹? */
    .stSelectbox label, .stNumberInput label, .stDateInput label, .stTextInput label {
        overflow: hidden !important;
        text-overflow: ellipsis !important;
        white-space: nowrap !important;
        max-width: 100% !important;
    }
    /* 罹≪뀡/?띿뒪??寃뱀묠 諛⑹? */
    .stCaption, .stMarkdown {
        word-break: break-word !important;
        overflow-wrap: break-word !important;
    }

    /* ===== Mobile Responsive ===== */
    @media (max-width: 768px) {
        html, body, [class*="css"] {
            font-size: 14px;
        }
        .stMarkdown p {
            font-size: 14px !important;
        }
        [data-testid="stMetricDelta"] {
            font-size: 12px !important;
            white-space: nowrap !important;
            overflow: hidden !important;
            text-overflow: ellipsis !important;
        }
        .streamlit-expanderHeader {
            font-size: 16px !important;
        }
        button[data-baseweb="tab"] {
            font-size: 11px !important;
            padding: 4px 8px !important;
            white-space: nowrap !important;
            overflow: hidden !important;
            text-overflow: ellipsis !important;
        }
        [data-baseweb="tab-list"] {
            gap: 2px !important;
        }
        /* 紐⑤컮??硫뷀듃由?寃뱀묠 諛⑹? */
        [data-testid="stMetricValue"] {
            font-size: 18px !important;
            white-space: nowrap !important;
            overflow: hidden !important;
            text-overflow: ellipsis !important;
        }
        [data-testid="stMetricLabel"] {
            font-size: 11px !important;
            white-space: nowrap !important;
            overflow: hidden !important;
            text-overflow: ellipsis !important;
        }
        [data-testid="stSidebar"] {
            min-width: 280px !important;
            max-width: 320px !important;
        }
        /* 紐⑤컮?쇱뿉??而щ읆 ?몃줈 ?ㅽ깮 */
        [data-testid="stHorizontalBlock"] {
            flex-wrap: wrap !important;
        }
        [data-testid="stHorizontalBlock"] > div {
            flex: 1 1 100% !important;
            min-width: 100% !important;
        }
        /* 李⑦듃 ?믪씠 議곗젙 */
        .js-plotly-plot {
            max-height: 250px !important;
        }
        /* ?곗씠?고봽?덉엫 媛濡??ㅽ겕濡?*/
        [data-testid="stDataFrame"] {
            overflow-x: auto !important;
        }
        .block-container {
            padding-left: 0.5rem !important;
            padding-right: 0.5rem !important;
        }
    }

    </style>
""", unsafe_allow_html=True)

def warm_up_cache():
    """???쒖옉 ??二쇱슂 ?곗씠?곕? 誘몃━ 罹먯떛"""
    with st.status("?? ?쇱씠釉??곗씠??以鍮?以?..", expanded=False) as status:
        # 1. Coin ?곗씠??(?꾩옱 ?ы듃?대━??湲곗?)
        status.write("肄붿씤 ?쒖꽭 ?곗씠??濡쒕뱶...")
        try:
            from data_manager import get_current_portfolio
            portfolio = get_current_portfolio()
            tickers = [f"KRW-{coin}" for coin in portfolio.keys()]
            if tickers:
                data_cache.batch_download(tickers, count=2000)
        except: pass

        # 2. ISA Trend ETF ?곗씠??
        status.write("援?궡 ETF 異붿꽭 ?곗씠??濡쒕뱶...")
        try:
            from kis_trader import KISTrader
            kis_ak = st.secrets.get("KIS_APP_KEY") or os.getenv("KIS_APP_KEY")
            kis_sk = st.secrets.get("KIS_APP_SECRET") or os.getenv("KIS_APP_SECRET")
            if kis_ak and kis_sk:
                t = KISTrader(is_mock=False)
                t.app_key, t.app_secret = kis_ak, kis_sk
                # ?듭떖 Trend ETF??誘몃━ 濡쒕뱶 (2010?꾨??곗쓽 ?곗씠???뺣낫瑜??꾪빐 6000???ㅼ젙)
                for code in ["133690", "143850", "360750", "305720"]:
                    data_cache.fetch_and_cache_kis_domestic(t, code, count=6000)
        except: pass

        # 3. Overseas WDR/GEM ?곗씠??濡쒕뱶
        status.write("?댁쇅 ETF ?곗씠??濡쒕뱶...")
        try:
            if kis_ak and kis_sk:
                t = KISTrader(is_mock=False)
                t.app_key, t.app_secret = kis_ak, kis_sk
                # TQQQ ?꾨?由?吏?먯쓣 ?꾪븳 QQQ(?쒓렇?? 諛?TQQQ(留ㅻℓ) ?곗씠??(6000??
                for symbol in ["QQQ", "TQQQ", "SPY", "EFA", "BIL", "AGG"]:
                    data_cache.fetch_and_cache_kis_overseas(t, symbol, count=6000)
        except: pass

        # 4. Gold ?곗씠??
        status.write("湲??꾨Ъ ?쒖꽭 ?곗씠??濡쒕뱶...")
        try:
            if kis_ak and kis_sk:
                t = KISTrader(is_mock=False)
                t.app_key, t.app_secret = kis_ak, kis_sk
                data_cache.fetch_and_cache_gold(t, count=1500)
        except: pass

        status.update(label="??紐⑤뱺 ?곗씠??以鍮??꾨즺!", state="complete")


def render_gold_mode():
    """湲?Gold) ?꾨Ъ 嫄곕옒 紐⑤뱶 - ?ㅼ?利앷텒 KRX 湲덉떆??(肄붿씤 ??낵 ?숈씪??援ъ“)"""
    from kiwoom_gold import KiwoomGoldTrader, GOLD_CODE_1KG
    from backtest.engine import BacktestEngine

    st.title("?쪍 Gold Trading System (?ㅼ?利앷텒 KRX)")

    # ?? ?ъ씠?쒕컮: ?ㅼ젙 ?????????????????????????????????????
    st.sidebar.header("Gold ?ㅼ젙")

    # API Keys
    try:
        kiwoom_ak      = st.secrets.get("Kiwoom_App_Key", "")
        kiwoom_sk      = st.secrets.get("Kiwoom_Secret_Key", "")
        kiwoom_account = st.secrets.get("KIWOOM_ACCOUNT", "")
    except Exception:
        kiwoom_ak      = os.getenv("Kiwoom_App_Key", "")
        kiwoom_sk      = os.getenv("Kiwoom_Secret_Key", "")
        kiwoom_account = os.getenv("KIWOOM_ACCOUNT", "")

    if IS_CLOUD:
        st.sidebar.info("?벑 議고쉶 ?꾩슜 紐⑤뱶 (Cloud)")
    else:
        with st.sidebar.expander("?ㅼ? API Keys", expanded=False):
            kiwoom_ak      = st.text_input("App Key",    value=kiwoom_ak,      type="password", key="kiwoom_ak")
            kiwoom_sk      = st.text_input("Secret Key", value=kiwoom_sk,      type="password", key="kiwoom_sk")
            kiwoom_account = st.text_input("怨꾩쥖踰덊샇",    value=kiwoom_account, key="kiwoom_acc")

    # ?꾨왂 ?ㅼ젙 (肄붿씤 ?ы듃?대━?ㅼ? ?숈씪?섍쾶 ?ㅼ쨷 ?꾨왂 吏??
    st.sidebar.subheader("?꾨왂 ?ㅼ젙")
    st.sidebar.caption("?щ윭 ?꾨왂??異붽??섏뿬 ?ы듃?대━?ㅻ? 援ъ꽦?????덉뒿?덈떎.")

    _gold_cfg_default = [{"strategy": "Donchian", "buy": 90, "sell": 55, "weight": 100}]
    _gold_cfg = config.get("gold_strategy", _gold_cfg_default)

    df_gold_strat = pd.DataFrame(_gold_cfg)
    if IS_CLOUD:
        st.sidebar.dataframe(df_gold_strat, use_container_width=True, hide_index=True)
        edited_gold_strat = df_gold_strat
    else:
        edited_gold_strat = st.sidebar.data_editor(
            df_gold_strat, num_rows="dynamic", use_container_width=True, hide_index=True,
            key="gold_strat_editor",
            column_config={
                "strategy": st.column_config.SelectboxColumn("?꾨왂", options=["Donchian", "SMA"], required=True),
                "buy":      st.column_config.NumberColumn("留ㅼ닔", min_value=5, max_value=300, step=1, required=True),
                "sell":     st.column_config.NumberColumn("留ㅻ룄", min_value=0, max_value=300, step=1, required=True, help="Donchian 留ㅻ룄 梨꾨꼸 (SMA??臾댁떆?? 0=留ㅼ닔???덈컲)"),
                "weight":   st.column_config.NumberColumn("鍮꾩쨷 %", min_value=1, max_value=100, step=1, required=True),
            },
        )

    # 鍮꾩쨷 寃利?
    gold_total_weight = int(edited_gold_strat["weight"].sum())
    if gold_total_weight > 100:
        st.sidebar.error(f"珥?鍮꾩쨷??{gold_total_weight}% ?낅땲?? (100% ?댄븯濡??ㅼ젙?댁＜?몄슂)")
    else:
        gold_cash_weight = 100 - gold_total_weight
        st.sidebar.info(f"?ъ옄 鍮꾩쨷: {gold_total_weight}% | ?꾧툑: {gold_cash_weight}%")

    # 怨⑤뱶 ?ы듃?대━??由ъ뒪???앹꽦
    gold_portfolio_list = []
    for _, row in edited_gold_strat.iterrows():
        bp = int(row.get("buy", 90))
        sp = int(row.get("sell", 0) or 0)
        if sp == 0:
            sp = max(5, bp // 2)
        gold_portfolio_list.append({
            "strategy": str(row.get("strategy", "Donchian")),
            "buy_period": bp,
            "sell_period": sp,
            "weight": int(row.get("weight", 100)),
        })

    # 泥?踰덉㎏ ?꾨왂 (湲곕낯媛?
    if gold_portfolio_list:
        _g_first = gold_portfolio_list[0]
        gold_strategy = _g_first["strategy"]
        buy_period = _g_first["buy_period"]
        sell_period = _g_first["sell_period"]
    else:
        gold_strategy = "Donchian"
        buy_period = 90
        sell_period = 55

    # 공통 설정
    st.sidebar.subheader("공통 설정")
    _gold_start_default = config.get("gold_start_date", "2022-06-01")
    gold_start_date = st.sidebar.date_input(
        "기준 시작일",
        value=pd.to_datetime(_gold_start_default).date(),
        help="백테스트 및 평가 기준 시작일",
        disabled=IS_CLOUD,
        key="gold_start_date",
    )
    _gold_cap_default = config.get("gold_initial_cap", 10_000_000)
    gold_initial_cap = st.sidebar.number_input(
        "초기 자본금 (KRW)",
        value=_gold_cap_default,
        step=100_000,
        format="%d",
        disabled=IS_CLOUD,
        key="gold_initial_cap",
    )
    st.sidebar.caption(f"설정: **{gold_initial_cap:,.0f} KRW**")

    if not IS_CLOUD:
        if st.sidebar.button("💾 Gold 설정 저장", key="gold_save_btn"):
            new_gold_cfg = config.copy()
            new_gold_cfg["gold_strategy"] = edited_gold_strat.to_dict("records")
            new_gold_cfg["gold_start_date"] = str(gold_start_date)
            new_gold_cfg["gold_initial_cap"] = gold_initial_cap
            save_config(new_gold_cfg)
            st.sidebar.success("저장 완료!")

    # ?? ?몃젅?대뜑 + 諛깃렇?쇱슫???뚯빱 珥덇린??????????????????????
    from data_manager import GoldDataWorker

    @st.cache_resource
    def _get_gold_trader(ak, sk, acct):
        t = KiwoomGoldTrader(is_mock=False)
        t.app_key = ak
        t.app_secret = sk
        t.account_no = acct
        return t

    @st.cache_resource
    def _get_gold_worker(_trader):
        """諛깃렇?쇱슫???뚯빱: ?붽퀬/?쒖꽭/?멸?瑜?3珥덈쭏??蹂묐젹 媛깆떊"""
        w = GoldDataWorker()
        w.configure(_trader)
        w.start()
        return w

    gold_trader = None
    gold_worker = None
    if kiwoom_ak and kiwoom_sk:
        gold_trader = _get_gold_trader(kiwoom_ak, kiwoom_sk, kiwoom_account)
        gold_worker = _get_gold_worker(gold_trader)

    # ?? ?곗씠??濡쒕뱶 ?ы띁 (parquet 罹먯떆 ???뚯빱 ??CSV ?대갚) ??
    def load_gold_data(buy_p: int) -> pd.DataFrame | None:
        """?쇰큺 ?곗씠?? parquet 罹먯떆 ???뚯빱 李⑦듃 ??CSV ?대갚."""
        import data_cache
        # 1?쒖쐞: parquet 罹먯떆 (?ъ쟾 ?ㅼ슫濡쒕뱶??????곗씠??
        cached = data_cache.load_cached_gold()
        if cached is not None and len(cached) >= buy_p + 5:
            return cached
        # 2?쒖쐞: 諛깃렇?쇱슫???뚯빱 李⑦듃 ?곗씠??
        if gold_worker:
            df_w = gold_worker.get_chart()
            if df_w is not None and len(df_w) >= buy_p + 5:
                return df_w
        # 3?쒖쐞: CSV ?뚯씪 (?ㅽ봽?쇱씤 ?대갚)
        csv_path = os.path.join(os.path.dirname(os.path.abspath(__file__)), "krx_gold_daily.csv")
        if os.path.exists(csv_path):
            df_csv = pd.read_csv(csv_path, index_col="Date", parse_dates=True)
            df_csv.columns = [c.lower() for c in df_csv.columns]
            if "open" not in df_csv.columns: df_csv["open"] = df_csv["close"]
            if "high" not in df_csv.columns: df_csv["high"] = df_csv["close"]
            if "low"  not in df_csv.columns: df_csv["low"]  = df_csv["close"]
            return df_csv
        return None

    # ?? ??援ъ꽦 ???????????????????????????????????????????
    tab_g1, tab_g2, tab_g3, tab_g4 = st.tabs(
        ["?? ?ㅼ떆媛?紐⑤땲?곕쭅", "?썟 ?섎룞 二쇰Ц", "?뱤 諛깊뀒?ㅽ듃", "?뮩 ?섏닔猷??멸툑"]
    )

    # ?먥븧?먥븧?먥븧?먥븧?먥븧?먥븧?먥븧?먥븧?먥븧?먥븧?먥븧?먥븧?먥븧?먥븧?먥븧?먥븧?먥븧?먥븧?먥븧?먥븧?먥븧?먥븧?먥븧?먥븧?먥븧?먥븧?먥븧
    # Tab 1: ?ㅼ떆媛?紐⑤땲?곕쭅 (肄붿씤 ??怨??숈씪 援ъ“)
    # ?먥븧?먥븧?먥븧?먥븧?먥븧?먥븧?먥븧?먥븧?먥븧?먥븧?먥븧?먥븧?먥븧?먥븧?먥븧?먥븧?먥븧?먥븧?먥븧?먥븧?먥븧?먥븧?먥븧?먥븧?먥븧?먥븧?먥븧
    with tab_g1:
        st.header("?ㅼ떆媛?湲?紐⑤땲?곕쭅")
        _strat_labels = [f"{g['strategy']}({g['buy_period']}/{g['sell_period']}) {g['weight']}%" for g in gold_portfolio_list]
        st.caption(f"?꾨왂: {', '.join(_strat_labels)} | 珥덇린?먮낯: {gold_initial_cap:,.0f}??)

        # ?덈줈怨좎묠
        col_r1, col_r2 = st.columns([1, 5])
        with col_r1:
            if st.button("?봽 ?덈줈怨좎묠", key="gold_refresh"):
                for k in list(st.session_state.keys()):
                    if k.startswith("__gc_") or k.startswith("__gt_"):
                        del st.session_state[k]
                st.cache_data.clear()
                st.rerun()

        # 怨꾩쥖 ?붽퀬 (?뚯빱?먯꽌 ?쎄린 ??釉붾줈???놁쓬)
        with st.expander("?뮥 怨꾩쥖 ?꾪솴", expanded=True):
            if not gold_worker:
                st.warning("?ъ씠?쒕컮?먯꽌 ?ㅼ? API Key瑜??낅젰?댁＜?몄슂.")
            else:
                bal = gold_worker.get('balance')
                if bal:
                    b1, b2, b3, b4 = st.columns(4)
                    b1.metric("?덉닔湲?, f"{bal['cash_krw']:,.0f}??)
                    b2.metric("湲?蹂댁쑀??, f"{bal['gold_qty']:.4f}g")
                    b3.metric("湲??됯?湲덉븸", f"{bal['gold_eval']:,.0f}??)
                    total_asset = bal['cash_krw'] + bal['gold_eval']
                    pnl = total_asset - gold_initial_cap
                    b4.metric("珥??됯?", f"{total_asset:,.0f}??, delta=f"{pnl:+,.0f}??)
                    is_holding = bal['gold_qty'] > 0
                elif not gold_worker.is_ready():
                    st.info("?곗씠??濡쒕뵫 以?.. (諛깃렇?쇱슫??媛깆떊)")
                    bal = None
                    is_holding = False
                else:
                    st.warning("?붽퀬 議고쉶 ?ㅽ뙣 (API ?몄쬆 ?뺤씤)")
                    bal = None
                    is_holding = False

        # ?쒓렇??李⑦듃 (?ㅼ쨷 ?꾨왂 吏??
        with st.expander("?뱤 ?쒓렇??紐⑤땲?곕쭅", expanded=True):
            # 媛????buy_period濡??곗씠??濡쒕뱶
            max_buy_p = max((g['buy_period'] for g in gold_portfolio_list), default=90)
            df_gold = load_gold_data(max_buy_p)

            if df_gold is None or len(df_gold) < max_buy_p + 5:
                st.warning("?쇰큺 ?곗씠??遺議? API ?곌껐 ?먮뒗 krx_gold_daily.csv瑜??뺤씤?섏꽭??")
            else:
                close_now = float(df_gold['close'].iloc[-1])
                gold_signal_rows = []

                # ?꾨왂蹂?李⑦듃 ?뚮뜑留?
                n_strats = len(gold_portfolio_list)
                if n_strats > 0:
                    chart_cols = st.columns(n_strats)

                for gi, gp in enumerate(gold_portfolio_list):
                    g_strat = gp['strategy']
                    g_bp = gp['buy_period']
                    g_sp = gp['sell_period']
                    g_wt = gp['weight']

                    if g_strat == "Donchian":
                        g_upper = df_gold['high'].rolling(window=g_bp).max().shift(1)
                        g_lower = df_gold['low'].rolling(window=g_sp).min().shift(1)
                        g_buy_target = float(g_upper.iloc[-1])
                        g_sell_target = float(g_lower.iloc[-1])
                        g_buy_dist = (close_now - g_buy_target) / g_buy_target * 100 if g_buy_target else 0
                        g_sell_dist = (close_now - g_sell_target) / g_sell_target * 100 if g_sell_target else 0
                        in_pos = False
                        for i in range(len(df_gold)):
                            u = g_upper.iloc[i]; l = g_lower.iloc[i]; c = float(df_gold['close'].iloc[i])
                            if not pd.isna(u) and c > u: in_pos = True
                            elif not pd.isna(l) and c < l: in_pos = False
                        g_signal = ("SELL" if close_now < g_sell_target else "HOLD") if in_pos else \
                                   ("BUY" if close_now > g_buy_target else "WAIT")
                        g_pos_label = "蹂댁쑀" if in_pos else "?꾧툑"
                    else:
                        g_sma = df_gold['close'].rolling(window=g_bp).mean()
                        g_buy_target = float(g_sma.iloc[-1])
                        g_sell_target = g_buy_target
                        g_buy_dist = (close_now - g_buy_target) / g_buy_target * 100 if g_buy_target else 0
                        g_sell_dist = g_buy_dist
                        g_signal = "BUY" if close_now > g_buy_target else "SELL"
                        g_pos_label = "蹂댁쑀" if close_now > g_buy_target else "?꾧툑"

                    gold_signal_rows.append({
                        "?꾨왂": f"{g_strat} {g_bp}/{g_sp}",
                        "鍮꾩쨷": f"{g_wt}%",
                        "?꾩옱媛": f"{close_now:,.0f}",
                        "留ㅼ닔紐⑺몴": f"{g_buy_target:,.0f}",
                        "留ㅻ룄紐⑺몴": f"{g_sell_target:,.0f}",
                        "留ㅼ닔?닿꺽??: f"{g_buy_dist:+.2f}%",
                        "留ㅻ룄?닿꺽??: f"{g_sell_dist:+.2f}%",
                        "?ъ???: g_pos_label,
                        "?쒓렇??: g_signal,
                    })

                    # 李⑦듃 ?뚮뜑留?
                    g_sig_color = "green" if g_signal == "BUY" else ("red" if g_signal == "SELL" else ("blue" if g_signal == "WAIT" else "gray"))
                    df_chart = df_gold.iloc[-120:]
                    fig_g = go.Figure()
                    fig_g.add_trace(go.Candlestick(
                        x=df_chart.index, open=df_chart['open'],
                        high=df_chart['high'], low=df_chart['low'],
                        close=df_chart['close'], name='湲??쇰큺',
                        increasing_line_color='#26a69a', decreasing_line_color='#ef5350',
                    ))
                    if g_strat == "Donchian":
                        fig_g.add_trace(go.Scatter(
                            x=df_chart.index, y=g_upper.loc[df_chart.index],
                            name=f'?곷떒({g_bp})', line=dict(color='green', width=1.5, dash='dot')))
                        fig_g.add_trace(go.Scatter(
                            x=df_chart.index, y=g_lower.loc[df_chart.index],
                            name=f'?섎떒({g_sp})', line=dict(color='red', width=1.5, dash='dot')))
                    else:
                        fig_g.add_trace(go.Scatter(
                            x=df_chart.index, y=g_sma.loc[df_chart.index],
                            name=f'SMA({g_bp})', line=dict(color='orange', width=2)))
                    fig_g.update_layout(
                        title=f"KRX 湲덊쁽臾?{g_strat}({g_bp}/{g_sp}) [{g_pos_label}] [{g_buy_dist:+.1f}%]",
                        title_font_color=g_sig_color,
                        height=400, margin=dict(l=0, r=0, t=40, b=30),
                        xaxis_rangeslider_visible=False, showlegend=True,
                        xaxis=dict(showticklabels=True, tickformat='%Y/%m/%d', tickangle=-45, nticks=10),
                        yaxis_title="媛寃?(??g)",
                    )
                    with chart_cols[gi]:
                        st.plotly_chart(fig_g, use_container_width=True)

                # ?쒓렇???붿빟 ?뚯씠釉?
                if gold_signal_rows:
                    st.dataframe(pd.DataFrame(gold_signal_rows), use_container_width=True, hide_index=True)

                    # ?? 媛以?寃고빀 ?쒓렇??(?먮룞留ㅻℓ? ?숈씪 濡쒖쭅) ??
                    total_w = sum(g['weight'] for g in gold_portfolio_list)
                    buy_w = sum(
                        g['weight'] for g, row in zip(gold_portfolio_list, gold_signal_rows)
                        if row['?쒓렇??] in ('BUY', 'HOLD')
                    )
                    target_ratio = buy_w / total_w if total_w > 0 else 0
                    combined_label = f"紐⑺몴 ?ъ옄鍮꾩쑉: **{target_ratio*100:.0f}%** (留ㅼ닔 鍮꾩쨷 {buy_w}% / ?꾩껜 {total_w}%)"

                    if target_ratio >= 0.8:
                        st.success(f"?ы듃?대━??寃고빀 ?쒓렇?? **留ㅼ닔** | {combined_label}")
                    elif target_ratio <= 0.2:
                        st.error(f"?ы듃?대━??寃고빀 ?쒓렇?? **留ㅻ룄** | {combined_label}")
                    else:
                        st.warning(f"?ы듃?대━??寃고빀 ?쒓렇?? **遺遺?蹂댁쑀** | {combined_label}")

        # ?먮룞留ㅻℓ 洹쒖튃
        with st.expander("?뽳툘 ?먮룞留ㅻℓ 洹쒖튃", expanded=False):
            rules_lines = ["**?ㅽ뻾 ?쒖젏**: GitHub Actions - 留??됱씪 KST 09:05\n"]
            for gp in gold_portfolio_list:
                if gp['strategy'] == "Donchian":
                    rules_lines.append(f"**{gp['strategy']}({gp['buy_period']}/{gp['sell_period']})** 鍮꾩쨷 {gp['weight']}%")
                    rules_lines.append(f"- 留ㅼ닔: 醫낃? > {gp['buy_period']}??理쒓퀬媛 ???쒖옣媛 留ㅼ닔")
                    rules_lines.append(f"- 留ㅻ룄: 醫낃? < {gp['sell_period']}??理쒖?媛 ???쒖옣媛 留ㅻ룄\n")
                else:
                    rules_lines.append(f"**{gp['strategy']}({gp['buy_period']})** 鍮꾩쨷 {gp['weight']}%")
                    rules_lines.append(f"- 留ㅼ닔: 醫낃? > SMA({gp['buy_period']}) ???쒖옣媛 留ㅼ닔")
                    rules_lines.append(f"- 留ㅻ룄: 醫낃? < SMA({gp['buy_period']}) ???쒖옣媛 留ㅻ룄\n")
            rules_lines.append("**?섏닔猷?*: ?ㅼ?利앷텒 0.165% (?뺣났 ~0.34%)")
            st.markdown("\n".join(rules_lines))

    # ?먥븧?먥븧?먥븧?먥븧?먥븧?먥븧?먥븧?먥븧?먥븧?먥븧?먥븧?먥븧?먥븧?먥븧?먥븧?먥븧?먥븧?먥븧?먥븧?먥븧?먥븧?먥븧?먥븧?먥븧?먥븧?먥븧?먥븧
    # Tab 2: ?섎룞 二쇰Ц ??HTS ?ㅽ???(肄붿씤 ?몃젅?대뵫 ?⑤꼸怨??숈씪 援ъ“)
    # ?먥븧?먥븧?먥븧?먥븧?먥븧?먥븧?먥븧?먥븧?먥븧?먥븧?먥븧?먥븧?먥븧?먥븧?먥븧?먥븧?먥븧?먥븧?먥븧?먥븧?먥븧?먥븧?먥븧?먥븧?먥븧?먥븧?먥븧
    with tab_g2:
        st.header("?섎룞 二쇰Ц")

        if not gold_trader:
            st.warning("API Key瑜??ъ씠?쒕컮?먯꽌 ?낅젰?댁＜?몄슂.")
        else:
            GOLD_TICK = 10  # KRX 湲덊쁽臾??멸??⑥쐞: 10??
            GOLD_MIN_QTY = 1.0  # 1KG 醫낅ぉ 理쒖냼 ?섎웾: 1g

            def _gold_align_price(price, tick=GOLD_TICK):
                return round(price / tick) * tick

            # ?? ?멸? ?좏깮 肄쒕갚 ??
            def _on_gold_ob_select():
                sel = st.session_state.get('_gold_ob_sel', '')
                try:
                    price_str = sel.split(' ', 1)[1].replace(',', '')
                    chosen = int(float(price_str))
                    st.session_state['gold_buy_price'] = chosen
                    st.session_state['gold_sell_price'] = chosen
                except (IndexError, ValueError):
                    pass

            # ?먥븧???몃젅?대뵫 ?⑤꼸 (3珥??먮룞媛깆떊, ?뚯빱?먯꽌 ?쎄린留???釉붾줈???놁쓬) ?먥븧??
            @st.fragment
            def gold_trading_panel():
                # ?? ?뚯빱?먯꽌 利됱떆 ?쎄린 (API ?몄텧 ?놁쓬) ??
                g_bal = gold_worker.get('balance') if gold_worker else None
                g_price = gold_worker.get('price', 0) if gold_worker else 0

                g_cash = g_bal['cash_krw'] if g_bal else 0.0
                g_qty  = g_bal['gold_qty'] if g_bal else 0.0
                g_eval = g_bal['gold_eval'] if g_bal else 0.0
                g_hold_val = g_qty * g_price if g_price > 0 else g_eval

                # ?? ?곷떒 ?뺣낫 諛???
                gc1, gc2, gc3, gc4, gc5 = st.columns(5)
                gc1.metric("?꾩옱媛 (??g)", f"{g_price:,.0f}")
                gc2.metric("湲?蹂댁쑀", f"{g_qty:.2f}g")
                gc3.metric("?됯?湲덉븸", f"{g_hold_val:,.0f}??)
                gc4.metric("?덉닔湲?, f"{g_cash:,.0f}??)
                gc5.metric("?멸??⑥쐞", f"{GOLD_TICK}??)

                # ?? 理쒓렐 嫄곕옒 ?뚮┝ 諛???
                g_last_trade = st.session_state.get('_gold_last_trade')
                if g_last_trade:
                    gt_type = g_last_trade.get('type', '')
                    gt_time = g_last_trade.get('time', '')
                    gt_detail = g_last_trade.get('detail', '')
                    is_buy = '留ㅼ닔' in gt_type
                    g_color = '#D32F2F' if is_buy else '#1976D2'
                    gnc1, gnc2 = st.columns([6, 1])
                    gnc1.markdown(
                        f'<div style="padding:6px 12px;border-radius:6px;background:{g_color}22;'
                        f'border-left:4px solid {g_color};font-size:14px;">'
                        f'<b style="color:{g_color}">{gt_type}</b> | {gt_detail} | {gt_time}</div>',
                        unsafe_allow_html=True
                    )
                    if gnc2.button("??, key="_gold_dismiss"):
                        del st.session_state['_gold_last_trade']
                        st.rerun()

                st.divider()

                # ?먥븧??硫붿씤 ?덉씠?꾩썐: ?멸?李?醫? + 李⑦듃쨌二쇰Ц(?? ?먥븧??
                ob_col, right_col = st.columns([2, 5])

                # ?? 醫? ?멸?李?(HTML ?뚯씠釉? ??
                with ob_col:
                    price_labels = []

                    ob = gold_worker.get('orderbook') if gold_worker else None

                    if ob and ob.get('asks') and ob.get('bids'):
                        asks = ob['asks']  # 留ㅻ룄?멸? (??넂??
                        bids = ob['bids']  # 留ㅼ닔?멸? (?믠넂??

                        all_qtys = [a['qty'] for a in asks] + [b['qty'] for b in bids]
                        max_qty = max(all_qtys) if all_qtys else 1

                        html = ['<table style="width:100%;border-collapse:collapse;font-size:13px;font-family:monospace;">']
                        html.append(
                            '<tr style="border-bottom:2px solid #ddd;font-weight:bold;color:#666">'
                            '<td>援щ텇</td><td style="text-align:right">?붾웾(g)</td>'
                            '<td style="text-align:right">媛寃???</td>'
                            '<td style="text-align:right">?깅씫</td><td>鍮꾩쑉</td></tr>'
                        )

                        ask_prices = []
                        bid_prices = []

                        # 留ㅻ룄?멸? (?믠넂???쒖꽌濡??쒖떆)
                        for a in reversed(asks):
                            ap = a['price']
                            aq = a['qty']
                            diff = ((ap / g_price) - 1) * 100 if g_price > 0 else 0
                            bar_w = int(aq / max_qty * 100) if max_qty > 0 else 0
                            ask_prices.append(ap)
                            html.append(
                                f'<tr style="color:#1976D2;border-bottom:1px solid #f0f0f0;height:28px">'
                                f'<td>留ㅻ룄</td>'
                                f'<td style="text-align:right">{aq:.2f}</td>'
                                f'<td style="text-align:right;font-weight:bold">{ap:,.0f}</td>'
                                f'<td style="text-align:right">{diff:+.2f}%</td>'
                                f'<td><div style="background:#1976D233;height:14px;width:{bar_w}%"></div></td></tr>'
                            )

                        # ?꾩옱媛 援щ텇??
                        html.append(
                            f'<tr style="background:#FFF3E0;border:2px solid #FF9800;height:32px;font-weight:bold">'
                            f'<td colspan="2" style="color:#E65100">?꾩옱媛</td>'
                            f'<td style="text-align:right;color:#E65100;font-size:15px">{g_price:,.0f}</td>'
                            f'<td colspan="2"></td></tr>'
                        )

                        # 留ㅼ닔?멸? (?믠넂???쒖꽌)
                        for b in bids:
                            bp = b['price']
                            bq = b['qty']
                            diff = ((bp / g_price) - 1) * 100 if g_price > 0 else 0
                            bar_w = int(bq / max_qty * 100) if max_qty > 0 else 0
                            bid_prices.append(bp)
                            html.append(
                                f'<tr style="color:#D32F2F;border-bottom:1px solid #f0f0f0;height:28px">'
                                f'<td>留ㅼ닔</td>'
                                f'<td style="text-align:right">{bq:.2f}</td>'
                                f'<td style="text-align:right;font-weight:bold">{bp:,.0f}</td>'
                                f'<td style="text-align:right">{diff:+.2f}%</td>'
                                f'<td><div style="background:#D32F2F33;height:14px;width:{bar_w}%"></div></td></tr>'
                            )

                        html.append('</table>')
                        st.markdown(''.join(html), unsafe_allow_html=True)

                        # ?멸? ?좏깮 selectbox
                        ask_prices.reverse()  # ??넂?????믠넂??쑝濡?蹂듭썝
                        for ap in ask_prices:
                            price_labels.append(f"留ㅻ룄 {ap:,.0f}")
                        price_labels.append(f"?? {g_price:,.0f} ??")
                        for bp in bid_prices:
                            price_labels.append(f"留ㅼ닔 {bp:,.0f}")

                        st.selectbox(
                            "?멸? ?좏깮 ??二쇰Ц媛 諛섏쁺", price_labels,
                            index=len(ask_prices),
                            key="_gold_ob_sel", on_change=_on_gold_ob_select
                        )

                        # ?ㅽ봽?덈뱶 ?뺣낫 + 留ㅼ닔??鍮꾩쑉
                        if asks and bids:
                            spread = asks[0]['price'] - bids[0]['price']
                            spread_pct = (spread / g_price * 100) if g_price > 0 else 0
                            total_ask_qty = sum(a['qty'] for a in asks)
                            total_bid_qty = sum(b['qty'] for b in bids)
                            bid_ratio = (total_bid_qty / (total_ask_qty + total_bid_qty) * 100) if (total_ask_qty + total_bid_qty) > 0 else 50
                            st.caption(
                                f"?ㅽ봽?덈뱶: {spread:,.0f}??({spread_pct:.3f}%) | "
                                f"留ㅻ룄?붾웾: {total_ask_qty:.2f}g | 留ㅼ닔?붾웾: {total_bid_qty:.2f}g | "
                                f"留ㅼ닔?? {bid_ratio:.1f}%"
                            )
                    else:
                        st.info("?멸? ?곗씠?곕? 遺덈윭?ㅻ뒗 以?..")

                # ?? ?? 李⑦듃 + 二쇰Ц ?⑤꼸 ??
                with right_col:
                    # ?쇰큺 李⑦듃 (?곷?)
                    chart_df = gold_worker.get_chart() if gold_worker else None
                    if chart_df is not None and len(chart_df) > 10:
                        import plotly.graph_objects as go
                        recent = chart_df.tail(60)
                        fig_gc = go.Figure()
                        fig_gc.add_trace(go.Candlestick(
                            x=recent.index, open=recent['open'], high=recent['high'],
                            low=recent['low'], close=recent['close'], name='媛寃?
                        ))
                        if len(recent) >= 5:
                            fig_gc.add_trace(go.Scatter(
                                x=recent.index, y=recent['close'].rolling(5).mean(),
                                line=dict(color='orange', width=1.5), name='MA5'
                            ))
                        if len(recent) >= 20:
                            fig_gc.add_trace(go.Scatter(
                                x=recent.index, y=recent['close'].rolling(20).mean(),
                                line=dict(color='purple', width=1.5), name='MA20'
                            ))
                        fig_gc.update_layout(
                            height=280, xaxis_rangeslider_visible=False,
                            margin=dict(l=0, r=0, t=10, b=30),
                            legend=dict(orientation="h", yanchor="bottom", y=1.02, xanchor="left", x=0)
                        )
                        st.plotly_chart(fig_gc, use_container_width=True)
                    else:
                        st.info("李⑦듃 ?곗씠??濡쒕뵫 以?..")

                    # 二쇰Ц ?⑤꼸 (?섎?)
                    buy_tab, sell_tab = st.tabs(["?뵶 留ㅼ닔", "?뵷 留ㅻ룄"])

                    with buy_tab:
                        gb_type = st.radio("二쇰Ц ?좏삎", ["?쒖옣媛", "吏?뺢?"], horizontal=True, key="g_buy_type")

                        if gb_type == "?쒖옣媛":
                            gb_amount = st.number_input(
                                "留ㅼ닔 湲덉븸 (??", min_value=10_000,
                                value=min(int(g_cash * 0.99), 1_000_000) if g_cash > 10_000 else 10_000,
                                step=10_000, key="g_buy_amt"
                            )
                            # % 踰꾪듉
                            gqb1, gqb2, gqb3, gqb4 = st.columns(4)
                            if gqb1.button("10%", key="gb10"):
                                st.session_state['g_buy_amt'] = int(g_cash * 0.1)
                                st.rerun()
                            if gqb2.button("25%", key="gb25"):
                                st.session_state['g_buy_amt'] = int(g_cash * 0.25)
                                st.rerun()
                            if gqb3.button("50%", key="gb50"):
                                st.session_state['g_buy_amt'] = int(g_cash * 0.5)
                                st.rerun()
                            if gqb4.button("100%", key="gb100"):
                                st.session_state['g_buy_amt'] = int(g_cash * 0.999)
                                st.rerun()

                            if g_price > 0:
                                st.caption(f"?덉긽 ?섎웾: ~{gb_amount / g_price:.2f}g")

                            if st.button("?쒖옣媛 留ㅼ닔", type="primary", key="g_buy_exec", use_container_width=True, disabled=IS_CLOUD):
                                if gb_amount < 10_000:
                                    st.toast("理쒖냼 二쇰Ц湲덉븸: 10,000??, icon="?좑툘")
                                elif gb_amount > g_cash:
                                    st.toast(f"?덉닔湲?遺議?({g_cash:,.0f}??", icon="?좑툘")
                                else:
                                    with st.spinner("留ㅼ닔 二쇰Ц 以?.."):
                                        if gold_trader.auth():
                                            cur_p = gold_trader.get_current_price(GOLD_CODE_1KG) or g_price or 1
                                            buy_qty = round(gb_amount / cur_p, 2)
                                            result = gold_trader.send_order("BUY", GOLD_CODE_1KG, qty=buy_qty, ord_tp="3")
                                        else:
                                            result = None
                                    pass  # ?뚯빱媛 ?먮룞 媛깆떊
                                    if result and result.get("success"):
                                        st.toast(f"???쒖옣媛 留ㅼ닔! {gb_amount:,.0f}????{buy_qty:.2f}g", icon="?윟")
                                        st.session_state['_gold_last_trade'] = {
                                            "type": "?쒖옣媛 留ㅼ닔", "detail": f"{gb_amount:,.0f}????{buy_qty:.2f}g",
                                            "time": time.strftime('%H:%M:%S')
                                        }
                                    else:
                                        st.toast(f"留ㅼ닔 ?ㅽ뙣: {result}", icon="?뵶")

                        else:  # 吏?뺢?
                            gbc1, gbc2 = st.columns(2)
                            gb_price = gbc1.number_input(
                                "留ㅼ닔 媛寃?(??g)", min_value=1,
                                value=_gold_align_price(g_price * 0.99) if g_price > 0 else 100_000,
                                step=GOLD_TICK, key="gold_buy_price"
                            )
                            gb_qty = gbc2.number_input(
                                "留ㅼ닔 ?섎웾 (g)", min_value=0.01, value=max(GOLD_MIN_QTY, 1.0),
                                step=0.01, format="%.2f", key="g_buy_qty"
                            )
                            gb_total = gb_price * gb_qty
                            st.caption(f"珥앹븸: **{gb_total:,.0f}??* | ?멸?: {GOLD_TICK}??| 理쒖냼: {GOLD_MIN_QTY}g")

                            gqbc1, gqbc2, gqbc3, gqbc4 = st.columns(4)
                            if gb_price > 0:
                                if gqbc1.button("10%", key="glb10"):
                                    st.session_state['g_buy_qty'] = round(g_cash * 0.1 / gb_price, 2)
                                    st.rerun()
                                if gqbc2.button("25%", key="glb25"):
                                    st.session_state['g_buy_qty'] = round(g_cash * 0.25 / gb_price, 2)
                                    st.rerun()
                                if gqbc3.button("50%", key="glb50"):
                                    st.session_state['g_buy_qty'] = round(g_cash * 0.5 / gb_price, 2)
                                    st.rerun()
                                if gqbc4.button("100%", key="glb100"):
                                    st.session_state['g_buy_qty'] = round(g_cash * 0.999 / gb_price, 2)
                                    st.rerun()

                            if st.button("吏?뺢? 留ㅼ닔", type="primary", key="g_lbuy_exec", use_container_width=True, disabled=IS_CLOUD):
                                if gb_total < 10_000:
                                    st.toast("理쒖냼 二쇰Ц湲덉븸: 10,000??, icon="?좑툘")
                                elif gb_total > g_cash:
                                    st.toast(f"?덉닔湲?遺議?({g_cash:,.0f}??", icon="?좑툘")
                                else:
                                    with st.spinner("吏?뺢? 留ㅼ닔 二쇰Ц 以?.."):
                                        if gold_trader.auth():
                                            result = gold_trader.send_order("BUY", GOLD_CODE_1KG, qty=gb_qty, price=gb_price, ord_tp="1")
                                        else:
                                            result = None
                                    pass  # ?뚯빱媛 ?먮룞 媛깆떊
                                    if result and result.get("success"):
                                        st.toast(f"??吏?뺢? 留ㅼ닔 ?깅줉! {gb_price:,.0f}??횞 {gb_qty:.2f}g", icon="?윟")
                                        st.session_state['_gold_last_trade'] = {
                                            "type": "吏?뺢? 留ㅼ닔", "detail": f"{gb_price:,.0f}??횞 {gb_qty:.2f}g",
                                            "time": time.strftime('%H:%M:%S')
                                        }
                                    else:
                                        st.toast(f"二쇰Ц ?ㅽ뙣: {result}", icon="?뵶")

                    with sell_tab:
                        gs_type = st.radio("二쇰Ц ?좏삎", ["?쒖옣媛", "吏?뺢?"], horizontal=True, key="g_sell_type")

                        if gs_type == "?쒖옣媛":
                            gs_qty = st.number_input(
                                f"留ㅻ룄 ?섎웾 (g)", min_value=0.01,
                                value=g_qty if g_qty > 0 else 1.0,
                                step=0.01, format="%.2f", key="g_sell_qty"
                            )
                            gqs1, gqs2, gqs3, gqs4 = st.columns(4)
                            if gqs1.button("25%", key="gs25"):
                                st.session_state['g_sell_qty'] = round(g_qty * 0.25, 2)
                                st.rerun()
                            if gqs2.button("50%", key="gs50"):
                                st.session_state['g_sell_qty'] = round(g_qty * 0.5, 2)
                                st.rerun()
                            if gqs3.button("75%", key="gs75"):
                                st.session_state['g_sell_qty'] = round(g_qty * 0.75, 2)
                                st.rerun()
                            if gqs4.button("100%", key="gs100"):
                                st.session_state['g_sell_qty'] = round(g_qty, 2)
                                st.rerun()

                            if g_price > 0:
                                st.caption(f"?덉긽 湲덉븸: ~{gs_qty * g_price:,.0f}??)

                            if st.button("?쒖옣媛 留ㅻ룄", type="primary", key="g_sell_exec", use_container_width=True, disabled=IS_CLOUD):
                                if gs_qty <= 0:
                                    st.toast("留ㅻ룄 ?섎웾???낅젰?댁＜?몄슂.", icon="?좑툘")
                                elif g_price > 0 and gs_qty * g_price < 10_000:
                                    st.toast(f"理쒖냼 二쇰Ц湲덉븸 誘몃떖 ({gs_qty * g_price:,.0f}??< 10,000??", icon="?좑툘")
                                elif gs_qty > g_qty:
                                    st.toast(f"蹂댁쑀??珥덇낵 ({g_qty:.2f}g)", icon="?좑툘")
                                else:
                                    with st.spinner("留ㅻ룄 二쇰Ц 以?.."):
                                        if gold_trader.auth():
                                            result = gold_trader.send_order("SELL", GOLD_CODE_1KG, qty=gs_qty, ord_tp="3")
                                        else:
                                            result = None
                                    pass  # ?뚯빱媛 ?먮룞 媛깆떊
                                    if result and result.get("success"):
                                        st.toast(f"???쒖옣媛 留ㅻ룄! {gs_qty:.2f}g", icon="?뵶")
                                        st.session_state['_gold_last_trade'] = {
                                            "type": "?쒖옣媛 留ㅻ룄", "detail": f"{gs_qty:.2f}g ??{gs_qty * g_price:,.0f}??,
                                            "time": time.strftime('%H:%M:%S')
                                        }
                                    else:
                                        st.toast(f"留ㅻ룄 ?ㅽ뙣: {result}", icon="?뵶")

                        else:  # 吏?뺢?
                            gsc1, gsc2 = st.columns(2)
                            gs_price = gsc1.number_input(
                                "留ㅻ룄 媛寃?(??g)", min_value=1,
                                value=_gold_align_price(g_price * 1.01) if g_price > 0 else 100_000,
                                step=GOLD_TICK, key="gold_sell_price"
                            )
                            gs_lqty = gsc2.number_input(
                                "留ㅻ룄 ?섎웾 (g)", min_value=0.01,
                                value=g_qty if g_qty > 0.01 else 1.0,
                                step=0.01, format="%.2f", key="g_sell_lqty"
                            )
                            gs_total = gs_price * gs_lqty
                            st.caption(f"珥앹븸: **{gs_total:,.0f}??* | ?멸?: {GOLD_TICK}??)

                            gqsc1, gqsc2, gqsc3, gqsc4 = st.columns(4)
                            if g_qty > 0:
                                if gqsc1.button("25%", key="gls25"):
                                    st.session_state['g_sell_lqty'] = round(g_qty * 0.25, 2)
                                    st.rerun()
                                if gqsc2.button("50%", key="gls50"):
                                    st.session_state['g_sell_lqty'] = round(g_qty * 0.5, 2)
                                    st.rerun()
                                if gqsc3.button("75%", key="gls75"):
                                    st.session_state['g_sell_lqty'] = round(g_qty * 0.75, 2)
                                    st.rerun()
                                if gqsc4.button("100%", key="gls100"):
                                    st.session_state['g_sell_lqty'] = round(g_qty, 2)
                                    st.rerun()

                            if st.button("吏?뺢? 留ㅻ룄", type="primary", key="g_lsell_exec", use_container_width=True, disabled=IS_CLOUD):
                                if gs_lqty <= 0:
                                    st.toast("留ㅻ룄 ?섎웾???낅젰?댁＜?몄슂.", icon="?좑툘")
                                elif gs_total < 10_000:
                                    st.toast(f"理쒖냼 二쇰Ц湲덉븸 誘몃떖 ({gs_total:,.0f}??< 10,000??", icon="?좑툘")
                                elif gs_lqty > g_qty:
                                    st.toast(f"蹂댁쑀??珥덇낵 ({g_qty:.2f}g)", icon="?좑툘")
                                else:
                                    with st.spinner("吏?뺢? 留ㅻ룄 二쇰Ц 以?.."):
                                        if gold_trader.auth():
                                            result = gold_trader.send_order("SELL", GOLD_CODE_1KG, qty=gs_lqty, price=gs_price, ord_tp="1")
                                        else:
                                            result = None
                                    pass  # ?뚯빱媛 ?먮룞 媛깆떊
                                    if result and result.get("success"):
                                        st.toast(f"??吏?뺢? 留ㅻ룄 ?깅줉! {gs_price:,.0f}??횞 {gs_lqty:.2f}g", icon="?뵶")
                                        st.session_state['_gold_last_trade'] = {
                                            "type": "吏?뺢? 留ㅻ룄", "detail": f"{gs_price:,.0f}??횞 {gs_lqty:.2f}g",
                                            "time": time.strftime('%H:%M:%S')
                                        }
                                    else:
                                        st.toast(f"二쇰Ц ?ㅽ뙣: {result}", icon="?뵶")

                # ?? 誘몄껜寃?二쇰Ц 愿由???
                st.divider()
                st.subheader("誘몄껜寃?二쇰Ц")
                if st.button("誘몄껜寃?二쇰Ц 議고쉶", key="g_pending"):
                    with st.spinner("議고쉶 以?.."):
                        if gold_trader.auth():
                            pending = gold_trader.get_pending_orders(GOLD_CODE_1KG)
                        else:
                            pending = []
                    if pending and len(pending) > 0:
                        for i, order in enumerate(pending):
                            side_kr = order.get('side_kr', '留ㅼ닔')
                            side_color = "red" if order['side'] == 'BUY' else "blue"
                            price = order.get('price', 0)
                            remaining = order.get('remaining_qty', 0)
                            ord_time = order.get('ord_time', '')
                            oc1, oc2 = st.columns([4, 1])
                            oc1.markdown(f"**:{side_color}[{side_kr}]** 湲덊쁽臾?| {price:,.0f}??횞 {remaining:.2f}g | {ord_time}")
                            if oc2.button("痍⑥냼", key=f"g_cancel_{i}"):
                                with st.spinner("二쇰Ц 痍⑥냼 以?.."):
                                    cancel_result = gold_trader.cancel_order(
                                        order['ord_no'], order['code'], remaining
                                    )
                                if cancel_result and str(cancel_result.get('return_code', -1)) == '0':
                                    st.toast("二쇰Ц 痍⑥냼 ?꾨즺", icon="??)
                                    st.rerun()
                                else:
                                    st.toast(f"痍⑥냼 ?ㅽ뙣: {cancel_result}", icon="?뵶")
                    else:
                        st.info("誘몄껜寃?二쇰Ц???놁뒿?덈떎.")

            gold_trading_panel()

    # ?먥븧?먥븧?먥븧?먥븧?먥븧?먥븧?먥븧?먥븧?먥븧?먥븧?먥븧?먥븧?먥븧?먥븧?먥븧?먥븧?먥븧?먥븧?먥븧?먥븧?먥븧?먥븧?먥븧?먥븧?먥븧?먥븧?먥븧
    # Tab 3: 諛깊뀒?ㅽ듃 (肄붿씤 ??? ?숈씪 援ъ“ - 3媛??쒕툕??
    # ?먥븧?먥븧?먥븧?먥븧?먥븧?먥븧?먥븧?먥븧?먥븧?먥븧?먥븧?먥븧?먥븧?먥븧?먥븧?먥븧?먥븧?먥븧?먥븧?먥븧?먥븧?먥븧?먥븧?먥븧?먥븧?먥븧?먥븧
    with tab_g3:
        gbt1, gbt2 = st.tabs(["?뱢 ?⑥씪 諛깊뀒?ㅽ듃", "?썱截??뚮씪誘명꽣 理쒖쟻??])

        # ?? ?쒕툕??: ?⑥씪 諛깊뀒?ㅽ듃 ??????????????????????????
        with gbt1:
            st.header("湲덊쁽臾??⑥씪 諛깊뀒?ㅽ듃")

            # ?? ?곗씠??媛??踰붿쐞 + ?ъ쟾 ?ㅼ슫濡쒕뱶 ??
            import data_cache as _dc_gold
            _gold_info = _dc_gold.gold_cache_info()
            if _gold_info["exists"]:
                _gi_start = _gold_info["start"]
                _gi_end = _gold_info["end"]
                _gi_start_str = _gi_start.strftime('%Y-%m-%d') if hasattr(_gi_start, 'strftime') else str(_gi_start)[:10]
                _gi_end_str = _gi_end.strftime('%Y-%m-%d') if hasattr(_gi_end, 'strftime') else str(_gi_end)[:10]
                st.info(f"?ъ슜 媛???곗씠?? **{_gold_info['rows']:,}**媛?罹붾뱾 ({_gi_start_str} ~ {_gi_end_str})")
            else:
                st.warning("罹먯떆??Gold ?곗씠?곌? ?놁뒿?덈떎. ?꾨옒 踰꾪듉?쇰줈 ?ъ쟾 ?ㅼ슫濡쒕뱶?섏꽭??")

            if gold_trader and st.button("Gold ?쇰큺 ?꾩껜 ?ㅼ슫濡쒕뱶 (2014~ ?꾩껜)", key="gold_predownload"):
                with st.status("Gold ?쇰큺 ?ㅼ슫濡쒕뱶 以?..", expanded=True) as dl_status:
                    prog_dl = st.progress(0)
                    log_dl = st.empty()
                    def _dl_progress(fetched, total, msg):
                        pct = min(fetched / total, 1.0) if total > 0 else 1.0
                        prog_dl.progress(pct)
                        log_dl.text(msg)
                    df_dl = _dc_gold.fetch_and_cache_gold(gold_trader, count=5000, progress_callback=_dl_progress)
                    if df_dl is not None and len(df_dl) > 0:
                        dl_status.update(label=f"?꾨즺! {len(df_dl):,}媛?罹붾뱾 ?ㅼ슫濡쒕뱶??, state="complete")
                        st.rerun()
                    else:
                        dl_status.update(label="?ㅼ슫濡쒕뱶 ?ㅽ뙣", state="error")

            st.divider()

            bt_col1, bt_col2, bt_col3 = st.columns(3)
            with bt_col1:
                bt_strategy = st.selectbox("?꾨왂", ["Donchian", "SMA"], key="gold_bt_strat")
            with bt_col2:
                bt_buy_p  = st.number_input("留ㅼ닔 湲곌컙", min_value=5, max_value=300, value=buy_period,  step=1, key="gold_bt_buy")
            with bt_col3:
                bt_sell_p = st.number_input("留ㅻ룄 湲곌컙", min_value=5, max_value=300, value=sell_period, step=1, key="gold_bt_sell",
                                            help="Donchian 留ㅻ룄 梨꾨꼸 (SMA??臾댁떆??")

            bt_start = st.date_input("諛깊뀒?ㅽ듃 ?쒖옉??, value=gold_start_date, key="gold_bt_start")
            bt_cap   = st.number_input("珥덇린 ?먮낯 (??", value=gold_initial_cap, step=100_000, format="%d", key="gold_bt_cap")

            if st.button("?? 諛깊뀒?ㅽ듃 ?ㅽ뻾", key="gold_bt_run", type="primary"):
                df_bt = load_gold_data(bt_buy_p)
                if df_bt is None or len(df_bt) < bt_buy_p + 5:
                    st.error("?곗씠??遺議? ?ъ쟾 ?ㅼ슫濡쒕뱶瑜??ㅽ뻾?섏꽭??")
                else:
                    st.caption(f"議고쉶??罹붾뱾: {len(df_bt):,}媛?({df_bt.index[0].strftime('%Y-%m-%d')} ~ {df_bt.index[-1].strftime('%Y-%m-%d')})")
                    with st.spinner("諛깊뀒?ㅽ듃 ?ㅽ뻾 以?.."):
                        engine = BacktestEngine()
                        result = engine.run_backtest(
                            ticker=None, df=df_bt,
                            period=bt_buy_p,
                            interval="day",
                            fee=0.003,
                            start_date=str(bt_start),
                            initial_balance=bt_cap,
                            strategy_mode=bt_strategy,
                            sell_period_ratio=(bt_sell_p / bt_buy_p) if bt_strategy == "Donchian" else 1.0,
                            slippage=0.0,
                        )

                    if "error" in result:
                        st.error(f"諛깊뀒?ㅽ듃 ?ㅻ쪟: {result['error']}")
                    else:
                        p = result["performance"]
                        r1, r2, r3, r4 = st.columns(4)
                        r1.metric("珥??섏씡瑜?,  f"{p['total_return']:+.2f}%")
                        r2.metric("CAGR",      f"{p['cagr']:+.2f}%")
                        r3.metric("MDD",       f"{p['mdd']:.2f}%")
                        r4.metric("?ㅽ봽 鍮꾩쑉",  f"{p['sharpe']:.2f}")
                        r5, r6, r7, r8, r9 = st.columns(5)
                        r5.metric("留ㅻℓ ?잛닔",  f"{p['trade_count']}??)
                        r6.metric("?밸쪧",      f"{p['win_rate']:.1f}%")
                        r7.metric("理쒖쥌 ?먯궛",  f"{p['final_equity']:,.0f}??)
                        calmar = abs(p['cagr'] / p['mdd']) if p['mdd'] != 0 else 0
                        r8.metric("Calmar",    f"{calmar:.2f}")
                        r9.metric("?고룊洹쟋DD",  f"{p.get('avg_yearly_mdd', p['mdd']):.2f}%")

                        # ?? ?곕룄蹂??깃낵 (?곸꽭 而щ읆) ??????????????????
                        df_result_full = result.get("df")
                        equity_curve   = result.get("equity_curve")

                        if df_result_full is not None and equity_curve is not None:
                            eq_series = pd.Series(equity_curve, index=df_result_full.index[-len(equity_curve):])
                            yearly_rows_g = []
                            years = eq_series.index.year.unique()
                            for yr in sorted(years):
                                yr_eq = eq_series[eq_series.index.year == yr]
                                if yr_eq.empty:
                                    continue
                                yr_start_eq = yr_eq.iloc[0]
                                yr_end_eq   = yr_eq.iloc[-1]
                                yr_ret      = (yr_end_eq / yr_start_eq - 1) * 100
                                peak_yr     = yr_eq.cummax()
                                yr_mdd      = ((yr_eq - peak_yr) / peak_yr * 100).min()
                                # ?곹깭: ?곕룄 留덉?留??쇱쓽 ?ъ???
                                yr_trades = [t for t in p.get("trades", []) if pd.Timestamp(t["date"]).year <= yr]
                                last_type = yr_trades[-1]["type"] if yr_trades else "??
                                yr_state = "蹂댁쑀" if last_type == "buy" else "?꾧툑"
                                yearly_rows_g.append({
                                    "?곕룄": yr,
                                    "?섏씡瑜?%)": f"{yr_ret:+.2f}",
                                    "MDD(%)": f"{yr_mdd:.2f}",
                                    "?쒖옉?먯궛(??": f"{yr_start_eq:,.0f}",
                                    "理쒖쥌?먯궛(??": f"{yr_end_eq:,.0f}",
                                    "?곹깭": yr_state,
                                })
                            if yearly_rows_g:
                                # ?됯퇏 ??異붽?
                                _df_yr_g = pd.DataFrame(yearly_rows_g)
                                _avg_ret = np.mean([float(r["?섏씡瑜?%)"]) for r in yearly_rows_g])
                                _avg_mdd = np.mean([float(r["MDD(%)"]) for r in yearly_rows_g])
                                _df_yr_g = pd.concat([_df_yr_g, pd.DataFrame([{
                                    "?곕룄": "?됯퇏", "?섏씡瑜?%)": f"{_avg_ret:+.2f}",
                                    "MDD(%)": f"{_avg_mdd:.2f}",
                                    "?쒖옉?먯궛(??": "??, "理쒖쥌?먯궛(??": "??, "?곹깭": "??,
                                }])], ignore_index=True)
                                st.subheader("?곕룄蹂??깃낵")
                                st.dataframe(_df_yr_g, use_container_width=True, hide_index=True)

                        # ?? ?먯옘??而ㅻ툕 李⑦듃 ??????????????????????????
                        if equity_curve is not None and len(equity_curve) > 0:
                            df_eq = pd.DataFrame({"equity": equity_curve})
                            df_eq.index = df_result_full.index[-len(equity_curve):]
                            df_eq["return_pct"] = (df_eq["equity"] / bt_cap - 1) * 100
                            # Buy & Hold 鍮꾧탳
                            df_bt_chart = df_bt.loc[df_bt.index >= pd.Timestamp(str(bt_start))]
                            if not df_bt_chart.empty:
                                bh_base = df_bt_chart["close"].iloc[0]
                                bh_pct  = (df_bt_chart["close"] / bh_base - 1) * 100

                            fig_eq = go.Figure()
                            fig_eq.add_trace(go.Scatter(
                                x=df_eq.index, y=df_eq["return_pct"], mode="lines",
                                name="?꾨왂", line=dict(color="gold", width=2)
                            ))
                            if not df_bt_chart.empty:
                                fig_eq.add_trace(go.Scatter(
                                    x=bh_pct.index, y=bh_pct.values, mode="lines",
                                    name="Buy & Hold", line=dict(color="gray", width=1, dash="dot")
                                ))
                            fig_eq.update_layout(
                                title=f"?꾩쟻 ?섏씡瑜?({bt_strategy} {bt_buy_p}/{bt_sell_p})",
                                yaxis_title="?섏씡瑜?(%)", height=350,
                                margin=dict(l=0, r=0, t=40, b=30),
                                legend=dict(orientation="h", yanchor="bottom", y=1.02, xanchor="left", x=0)
                            )
                            st.plotly_chart(fig_eq, use_container_width=True)

                        # ?? 嫄곕옒 ?댁뿭 ?????????????????????????????????
                        with st.expander("嫄곕옒 ?댁뿭"):
                            trades_list = p.get("trades", [])
                            if trades_list:
                                st.dataframe(pd.DataFrame(trades_list), use_container_width=True, hide_index=True)
                            else:
                                st.info("?ㅽ뻾??嫄곕옒媛 ?놁뒿?덈떎.")

        # ?? ?쒕툕??: ?뚮씪誘명꽣 理쒖쟻??????????????????????????
        with gbt2:
            st.header("?뚮씪誘명꽣 理쒖쟻??)

            # ?곗씠??媛??踰붿쐞 ?쒖떆
            _gold_info_opt = _dc_gold.gold_cache_info()
            if _gold_info_opt["exists"]:
                _gio_s = _gold_info_opt["start"]
                _gio_e = _gold_info_opt["end"]
                _gio_s_str = _gio_s.strftime('%Y-%m-%d') if hasattr(_gio_s, 'strftime') else str(_gio_s)[:10]
                _gio_e_str = _gio_e.strftime('%Y-%m-%d') if hasattr(_gio_e, 'strftime') else str(_gio_e)[:10]
                st.info(f"?ъ슜 媛???곗씠?? **{_gold_info_opt['rows']:,}**媛?罹붾뱾 ({_gio_s_str} ~ {_gio_e_str})")
            else:
                st.warning("罹먯떆??Gold ?곗씠?곌? ?놁뒿?덈떎. 諛깊뀒?ㅽ듃 ??뿉???ъ쟾 ?ㅼ슫濡쒕뱶瑜??ㅽ뻾?섏꽭??")

            opt_strat_g = st.selectbox("?꾨왂", ["Donchian", "SMA"], key="gold_opt_strat")

            with st.form("gold_optimization_form"):
                gopt_method = st.radio("理쒖쟻??諛⑸쾿", ["Grid Search (?꾩닔 ?먯깋)", "Optuna (踰좎씠吏??理쒖쟻??"], horizontal=True, key="gold_opt_method")
                use_optuna_g = "Optuna" in gopt_method

                if opt_strat_g == "Donchian":
                    st.markdown("##### 留ㅼ닔 梨꾨꼸 湲곌컙")
                    goc1, goc2, goc3 = st.columns(3)
                    g_buy_start = goc1.number_input("?쒖옉", 5, 300, 30,  key="gold_opt_buy_start")
                    g_buy_end   = goc2.number_input("??,   5, 300, 150, key="gold_opt_buy_end")
                    g_buy_step  = goc3.number_input("媛꾧꺽", 1, 50,  5,   key="gold_opt_buy_step")
                    st.markdown("##### 留ㅻ룄 梨꾨꼸 湲곌컙")
                    goc4, goc5, goc6 = st.columns(3)
                    g_sell_start = goc4.number_input("?쒖옉", 5, 300, 10, key="gold_opt_sell_start")
                    g_sell_end   = goc5.number_input("??,   5, 300, 80, key="gold_opt_sell_end")
                    g_sell_step  = goc6.number_input("媛꾧꺽", 1, 50,  5,  key="gold_opt_sell_step")
                else:
                    st.markdown("##### SMA 湲곌컙")
                    goc1, goc2, goc3 = st.columns(3)
                    g_sma_start = goc1.number_input("?쒖옉", 5, 300, 10, key="gold_opt_sma_start")
                    g_sma_end   = goc2.number_input("??,   5, 300, 100, key="gold_opt_sma_end")
                    g_sma_step  = goc3.number_input("媛꾧꺽", 1, 50,  5,   key="gold_opt_sma_step")

                if use_optuna_g:
                    st.divider()
                    st.markdown("##### Optuna ?ㅼ젙")
                    uoc1, uoc2 = st.columns(2)
                    g_n_trials  = uoc1.number_input("?먯깋 ?잛닔", 50, 2000, 200, step=50, key="gold_optuna_trials")
                    g_obj_label = uoc2.selectbox("紐⑹쟻?⑥닔", ["Calmar (CAGR/|MDD|)", "Sharpe", "?섏씡瑜?(Return)", "MDD 理쒖냼"], key="gold_optuna_obj")

                st.divider()
                g_opt_start = st.date_input("?쒖옉??, value=gold_start_date, key="gold_opt_start")
                g_opt_fee   = st.number_input("?섏닔猷?(%)", value=0.3, format="%.2f", key="gold_opt_fee") / 100
                g_opt_cap   = st.number_input("珥덇린 ?먮낯 (??", value=gold_initial_cap, step=100_000, format="%d", key="gold_opt_cap")

                gopt_submitted = st.form_submit_button("理쒖쟻???쒖옉", type="primary")

            if gopt_submitted:
                import plotly.express as px
                df_opt_src = load_gold_data(max(
                    g_buy_end if opt_strat_g == "Donchian" else g_sma_end, 300
                ))
                if df_opt_src is None or df_opt_src.empty:
                    st.error("?곗씠??濡쒕뱶 ?ㅽ뙣. 諛깊뀒?ㅽ듃 ??뿉???ъ쟾 ?ㅼ슫濡쒕뱶瑜??ㅽ뻾?섏꽭??")
                else:
                    st.caption(f"議고쉶??罹붾뱾: {len(df_opt_src):,}媛?({df_opt_src.index[0].strftime('%Y-%m-%d')} ~ {df_opt_src.index[-1].strftime('%Y-%m-%d')})")
                    with st.status("理쒖쟻??吏꾪뻾 以?..", expanded=True) as gopt_status:
                        prog_bar_g  = st.progress(0)
                        log_area_g  = st.empty()

                        def g_opt_progress(idx, total, msg):
                            pct = min(idx / total, 1.0) if total > 0 else 0
                            prog_bar_g.progress(pct)
                            log_area_g.text(f"{msg} ({idx}/{total})")

                        engine_g = BacktestEngine()
                        try:
                            if use_optuna_g:
                                obj_map_g = {"Calmar (CAGR/|MDD|)": "calmar", "Sharpe": "sharpe", "?섏씡瑜?(Return)": "return", "MDD 理쒖냼": "mdd"}
                                obj_key_g = obj_map_g.get(g_obj_label, "calmar")
                                if opt_strat_g == "Donchian":
                                    opt_res_g = engine_g.optuna_optimize(
                                        df_opt_src, strategy_mode="Donchian",
                                        buy_range=(g_buy_start, g_buy_end),
                                        sell_range=(g_sell_start, g_sell_end),
                                        fee=g_opt_fee, slippage=0.0,
                                        start_date=str(g_opt_start),
                                        initial_balance=g_opt_cap,
                                        n_trials=g_n_trials,
                                        objective_metric=obj_key_g,
                                        progress_callback=g_opt_progress,
                                    )
                                else:
                                    opt_res_g = engine_g.optuna_optimize(
                                        df_opt_src, strategy_mode="SMA",
                                        buy_range=(g_sma_start, g_sma_end),
                                        fee=g_opt_fee, slippage=0.0,
                                        start_date=str(g_opt_start),
                                        initial_balance=g_opt_cap,
                                        n_trials=g_n_trials,
                                        objective_metric=obj_key_g,
                                        progress_callback=g_opt_progress,
                                    )
                                gopt_results = opt_res_g.get("trials", [])
                                best_params  = opt_res_g.get("best_params", {})
                                gopt_status.update(label="Optuna 理쒖쟻???꾨즺!", state="complete")
                                st.success(f"理쒖쟻 ?뚮씪誘명꽣: {best_params} | 紐⑹쟻?⑥닔 媛? {opt_res_g['best_value']:.2f}")
                            else:
                                if opt_strat_g == "Donchian":
                                    buy_r  = range(g_buy_start,  g_buy_end  + 1, g_buy_step)
                                    sell_r = range(g_sell_start, g_sell_end + 1, g_sell_step)
                                    gopt_results = engine_g.optimize_donchian(
                                        df_opt_src, buy_range=buy_r, sell_range=sell_r,
                                        fee=g_opt_fee, slippage=0.0,
                                        start_date=str(g_opt_start),
                                        initial_balance=g_opt_cap,
                                        progress_callback=g_opt_progress,
                                    )
                                else:
                                    sma_r = range(g_sma_start, g_sma_end + 1, g_sma_step)
                                    gopt_results = engine_g.optimize_sma(
                                        df_opt_src, sma_range=sma_r,
                                        fee=g_opt_fee, slippage=0.0,
                                        start_date=str(g_opt_start),
                                        initial_balance=g_opt_cap,
                                        progress_callback=g_opt_progress,
                                    )
                                gopt_status.update(label="Grid Search ?꾨즺!", state="complete")

                        except Exception as e:
                            gopt_status.update(label=f"?ㅻ쪟: {e}", state="error")
                            gopt_results = []

                    if gopt_results:
                        df_opt_res = pd.DataFrame(gopt_results)
                        df_opt_res["calmar"] = df_opt_res.apply(
                            lambda r: abs(r["cagr"] / r["mdd"]) if r["mdd"] != 0 else 0, axis=1
                        )

                        # ?뺣젹 湲곗?: Calmar
                        df_opt_res_sorted = df_opt_res.sort_values("calmar", ascending=False).reset_index(drop=True)

                        # ?몄뀡?????(由щ윴 ?꾩뿉???좎?)
                        st.session_state['gold_opt_data'] = {
                            'df': df_opt_res_sorted.to_dict('records'),
                            'strategy': opt_strat_g,
                            'start_date': str(g_opt_start),
                            'cap': g_opt_cap,
                            'fee': g_opt_fee,
                        }

                        st.subheader("?곸쐞 20媛??뚮씪誘명꽣")
                        disp_cols = ["Buy Period", "Sell Period", "total_return", "cagr", "mdd", "avg_yearly_mdd", "sharpe", "calmar", "win_rate", "trade_count"] \
                            if opt_strat_g == "Donchian" else \
                            ["sma_period", "total_return", "cagr", "mdd", "avg_yearly_mdd", "sharpe", "calmar", "win_rate", "trade_count"]
                        disp_cols = [c for c in disp_cols if c in df_opt_res_sorted.columns]
                        top20 = df_opt_res_sorted.head(20)
                        st.dataframe(
                            top20[disp_cols].style.format({
                                "total_return": "{:.2f}%", "cagr": "{:.2f}%",
                                "mdd": "{:.2f}%", "avg_yearly_mdd": "{:.2f}%",
                                "sharpe": "{:.2f}",
                                "calmar": "{:.2f}", "win_rate": "{:.1f}%",
                            }),
                            use_container_width=True, hide_index=True
                        )

                        # ?? ?뚮씪誘명꽣 ?좏깮 踰꾪듉 (?대┃ ??利됱떆 諛깊뀒?ㅽ듃) ??
                        st.divider()
                        st.subheader("?뚮씪誘명꽣 ?좏깮 ??利됱떆 諛깊뀒?ㅽ듃")
                        _gtop5 = top20.head(5).reset_index(drop=True)
                        for _gri, _grow in _gtop5.iterrows():
                            _gc1, _gc2 = st.columns([8, 1])
                            if opt_strat_g == "Donchian" and "Buy Period" in _gtop5.columns:
                                _gc1.markdown(f"**#{_gri+1}** Buy={int(_grow['Buy Period'])}, Sell={int(_grow['Sell Period'])} | ?섏씡 {_grow['total_return']:.1f}%, Calmar {_grow['calmar']:.2f}")
                            elif "sma_period" in _gtop5.columns:
                                _gc1.markdown(f"**#{_gri+1}** SMA={int(_grow['sma_period'])} | ?섏씡 {_grow['total_return']:.1f}%, Calmar {_grow['calmar']:.2f}")
                            else:
                                continue
                            if _gc2.button("?ㅽ뻾", key=f"g_obt_{_gri}"):
                                if opt_strat_g == "Donchian" and "Buy Period" in _gtop5.columns:
                                    st.session_state['gold_opt_bt_params'] = {
                                        'strategy': 'Donchian',
                                        'buy_period': int(_grow['Buy Period']),
                                        'sell_period': int(_grow['Sell Period']),
                                    }
                                else:
                                    st.session_state['gold_opt_bt_params'] = {
                                        'strategy': 'SMA',
                                        'sma_period': int(_grow['sma_period']),
                                    }
                                st.rerun()

                        # ?덊듃留?(Donchian Grid Search????
                        if opt_strat_g == "Donchian" and not use_optuna_g and \
                                "Buy Period" in df_opt_res.columns and "Sell Period" in df_opt_res.columns:
                            st.subheader("Calmar ?덊듃留?(Buy 횞 Sell)")
                            try:
                                df_heat = df_opt_res.pivot_table(index="Buy Period", columns="Sell Period", values="calmar")
                                fig_heat = px.imshow(
                                    df_heat, color_continuous_scale="RdYlGn",
                                    labels=dict(x="Sell Period", y="Buy Period", color="Calmar"),
                                    aspect="auto"
                                )
                                fig_heat.update_layout(height=500, margin=dict(l=0, r=0, t=40, b=30))
                                st.plotly_chart(fig_heat, use_container_width=True)
                            except Exception:
                                pass

                        # SMA 理쒖쟻??李⑦듃 (?댁쨷 Y異?
                        if opt_strat_g == "SMA" and not use_optuna_g and "sma_period" in df_opt_res.columns:
                            from plotly.subplots import make_subplots as _g_make_subplots
                            _g_sma_df = df_opt_res_sorted.copy()
                            _g_fig_sma = _g_make_subplots(specs=[[{"secondary_y": True}]])
                            _g_fig_sma.add_trace(go.Scatter(
                                x=_g_sma_df["sma_period"], y=_g_sma_df["total_return"],
                                name="Total Return (%)", line=dict(color="gold", width=2)), secondary_y=False)
                            _g_fig_sma.add_trace(go.Scatter(
                                x=_g_sma_df["sma_period"], y=_g_sma_df["mdd"],
                                name="MDD (%)", line=dict(color="red", width=2)), secondary_y=True)
                            if "avg_yearly_mdd" in _g_sma_df.columns:
                                _g_fig_sma.add_trace(go.Scatter(
                                    x=_g_sma_df["sma_period"], y=_g_sma_df["avg_yearly_mdd"],
                                    name="?고룊洹쟋DD (%)", line=dict(color="orange", width=2, dash="dot")), secondary_y=True)
                            _g_fig_sma.update_layout(title="SMA 理쒖쟻??寃곌낵", height=400,
                                margin=dict(l=0, r=0, t=40, b=30),
                                legend=dict(orientation="h", yanchor="bottom", y=1.02, xanchor="left", x=0))
                            _g_fig_sma.update_yaxes(title_text="Total Return (%)", secondary_y=False)
                            _g_fig_sma.update_yaxes(title_text="MDD (%)", secondary_y=True)
                            st.plotly_chart(_g_fig_sma, use_container_width=True)

                        # ?꾩껜 寃곌낵 ?ㅼ슫濡쒕뱶
                        csv_data_g = df_opt_res_sorted.to_csv(index=False).encode("utf-8")
                        st.download_button("?뱿 ?꾩껜 寃곌낵 ?ㅼ슫濡쒕뱶 (CSV)", data=csv_data_g,
                                           file_name="gold_optimization_results.csv", mime="text/csv")

            # ?? 理쒖쟻??寃곌낵?먯꽌 ?좏깮???뚮씪誘명꽣濡??먮룞 諛깊뀒?ㅽ듃 ??
            if 'gold_opt_bt_params' in st.session_state and 'gold_opt_data' in st.session_state:
                _gp = st.session_state['gold_opt_bt_params']
                _gd = st.session_state['gold_opt_data']
                st.divider()
                if _gp['strategy'] == 'Donchian':
                    _gbp = _gp['buy_period']
                    _gsp = _gp['sell_period']
                    st.subheader(f"諛깊뀒?ㅽ듃: Donchian Buy={_gbp}, Sell={_gsp}")
                    _g_period = _gbp
                    _g_sell_ratio = _gsp / _gbp
                    _g_strat_mode = "Donchian"
                else:
                    _gsma = _gp['sma_period']
                    st.subheader(f"諛깊뀒?ㅽ듃: SMA Period={_gsma}")
                    _g_period = _gsma
                    _g_sell_ratio = 1.0
                    _g_strat_mode = "SMA"

                _g_df_bt = load_gold_data(_g_period)
                if _g_df_bt is None or len(_g_df_bt) < _g_period + 5:
                    st.error("?곗씠??遺議? 諛깊뀒?ㅽ듃 ??뿉???ъ쟾 ?ㅼ슫濡쒕뱶瑜??ㅽ뻾?섏꽭??")
                else:
                    with st.spinner("諛깊뀒?ㅽ듃 ?ㅽ뻾 以?.."):
                        _g_eng = BacktestEngine()
                        _g_res = _g_eng.run_backtest(
                            ticker=None, df=_g_df_bt,
                            period=_g_period,
                            interval="day",
                            fee=_gd.get('fee', 0.003),
                            start_date=_gd.get('start_date', '2020-01-01'),
                            initial_balance=_gd.get('cap', gold_initial_cap),
                            strategy_mode=_g_strat_mode,
                            sell_period_ratio=_g_sell_ratio,
                            slippage=0.0,
                        )
                    if "error" in _g_res:
                        st.error(f"諛깊뀒?ㅽ듃 ?ㅻ쪟: {_g_res['error']}")
                    else:
                        _gperf = _g_res["performance"]
                        _gr1, _gr2, _gr3, _gr4 = st.columns(4)
                        _gr1.metric("珥??섏씡瑜?, f"{_gperf['total_return']:+.2f}%")
                        _gr2.metric("CAGR", f"{_gperf['cagr']:+.2f}%")
                        _gr3.metric("MDD", f"{_gperf['mdd']:.2f}%")
                        _gr4.metric("?ㅽ봽 鍮꾩쑉", f"{_gperf['sharpe']:.2f}")
                        _gr5, _gr6, _gr7, _gr8, _gr9 = st.columns(5)
                        _gr5.metric("留ㅻℓ ?잛닔", f"{_gperf['trade_count']}??)
                        _gr6.metric("?밸쪧", f"{_gperf['win_rate']:.1f}%")
                        _gr7.metric("理쒖쥌 ?먯궛", f"{_gperf['final_equity']:,.0f}??)
                        _g_calmar = abs(_gperf['cagr'] / _gperf['mdd']) if _gperf['mdd'] != 0 else 0
                        _gr8.metric("Calmar", f"{_g_calmar:.2f}")
                        _gr9.metric("?고룊洹쟋DD", f"{_gperf.get('avg_yearly_mdd', _gperf['mdd']):.2f}%")

                        _g_df_full = _g_res.get("df")
                        _g_eq_curve = _g_res.get("equity_curve")
                        _g_cap = _gd.get('cap', gold_initial_cap)

                        if _g_df_full is not None and _g_eq_curve is not None:
                            _g_eq_s = pd.Series(_g_eq_curve, index=_g_df_full.index[-len(_g_eq_curve):])
                            _g_yr_rows = []
                            for yr in sorted(_g_eq_s.index.year.unique()):
                                _yr_eq = _g_eq_s[_g_eq_s.index.year == yr]
                                if _yr_eq.empty:
                                    continue
                                _yr_ret = (_yr_eq.iloc[-1] / _yr_eq.iloc[0] - 1) * 100
                                _yr_mdd = ((_yr_eq - _yr_eq.cummax()) / _yr_eq.cummax() * 100).min()
                                _g_yr_rows.append({
                                    "?곕룄": yr, "?섏씡瑜?%)": f"{_yr_ret:+.2f}",
                                    "MDD(%)": f"{_yr_mdd:.2f}",
                                    "?쒖옉?먯궛": f"{_yr_eq.iloc[0]:,.0f}",
                                    "理쒖쥌?먯궛": f"{_yr_eq.iloc[-1]:,.0f}",
                                })
                            if _g_yr_rows:
                                _df_gyr = pd.DataFrame(_g_yr_rows)
                                _gavg_ret = np.mean([float(r["?섏씡瑜?%)"]) for r in _g_yr_rows])
                                _gavg_mdd = np.mean([float(r["MDD(%)"]) for r in _g_yr_rows])
                                _df_gyr = pd.concat([_df_gyr, pd.DataFrame([{
                                    "?곕룄": "?됯퇏", "?섏씡瑜?%)": f"{_gavg_ret:+.2f}",
                                    "MDD(%)": f"{_gavg_mdd:.2f}",
                                    "?쒖옉?먯궛": "??, "理쒖쥌?먯궛": "??,
                                }])], ignore_index=True)
                                st.subheader("?곕룄蹂??깃낵")
                                st.dataframe(_df_gyr, use_container_width=True, hide_index=True)

                            _g_df_eq = pd.DataFrame({"equity": _g_eq_curve}, index=_g_df_full.index[-len(_g_eq_curve):])
                            _g_df_eq["return_pct"] = (_g_df_eq["equity"] / _g_cap - 1) * 100
                            _g_fig = go.Figure()
                            _g_fig.add_trace(go.Scatter(
                                x=_g_df_eq.index, y=_g_df_eq["return_pct"], mode="lines",
                                name="?꾨왂", line=dict(color="gold", width=2)))
                            _g_start_str = _gd.get('start_date', '2020-01-01')
                            _g_bh = _g_df_bt.loc[_g_df_bt.index >= pd.Timestamp(_g_start_str)]
                            if not _g_bh.empty:
                                _g_bh_base = _g_bh["close"].iloc[0]
                                _g_bh_pct = (_g_bh["close"] / _g_bh_base - 1) * 100
                                _g_fig.add_trace(go.Scatter(
                                    x=_g_bh_pct.index, y=_g_bh_pct.values, mode="lines",
                                    name="Buy & Hold", line=dict(color="gray", width=1, dash="dot")))
                            if _gp['strategy'] == 'Donchian':
                                _g_title = f"?꾩쟻 ?섏씡瑜?(Donchian {_gbp}/{_gsp})"
                            else:
                                _g_title = f"?꾩쟻 ?섏씡瑜?(SMA {_gsma})"
                            _g_fig.update_layout(
                                title=_g_title, yaxis_title="?섏씡瑜?(%)", height=350,
                                margin=dict(l=0, r=0, t=40, b=30),
                                legend=dict(orientation="h", yanchor="bottom", y=1.02, xanchor="left", x=0))
                            st.plotly_chart(_g_fig, use_container_width=True)

                        with st.expander("嫄곕옒 ?댁뿭"):
                            _g_trades = _gperf.get("trades", [])
                            if _g_trades:
                                st.dataframe(pd.DataFrame(_g_trades), use_container_width=True, hide_index=True)
                            else:
                                st.info("?ㅽ뻾??嫄곕옒媛 ?놁뒿?덈떎.")

                if st.button("寃곌낵 ?リ린", key="gold_opt_bt_close"):
                    del st.session_state['gold_opt_bt_params']
                    st.rerun()

    # ?먥븧?먥븧?먥븧?먥븧?먥븧?먥븧?먥븧?먥븧?먥븧?먥븧?먥븧?먥븧?먥븧?먥븧?먥븧?먥븧?먥븧?먥븧?먥븧?먥븧?먥븧?먥븧?먥븧?먥븧?먥븧?먥븧?먥븧
    # Tab 4: ?섏닔猷??멸툑 (湲곗〈 ?댁슜 ?좎?)
    # ?먥븧?먥븧?먥븧?먥븧?먥븧?먥븧?먥븧?먥븧?먥븧?먥븧?먥븧?먥븧?먥븧?먥븧?먥븧?먥븧?먥븧?먥븧?먥븧?먥븧?먥븧?먥븧?먥븧?먥븧?먥븧?먥븧?먥븧
    with tab_g4:
        st.header("KRX 湲덊쁽臾??섏닔猷?諛??멸툑 ?덈궡")
        st.caption("?ㅼ?利앷텒 湲곗? | ?섏닔猷뚮뒗 蹂寃쎈맆 ???덉쑝??怨듭떇 ?덊럹?댁??먯꽌 理쒖떊 ?뺣낫瑜??뺤씤?섏꽭??")

        st.subheader("1. 嫄곕옒 ?섏닔猷?)
        fee_data = pd.DataFrame([
            {"援щ텇": "留ㅻℓ ?섏닔猷?, "?붿쑉/湲덉븸": "??0.165% (?⑤씪??", "鍮꾧퀬": "留ㅼ닔/留ㅻ룄 媛곴컖 遺怨? 遺媛???ы븿"},
            {"援щ텇": "?좉?湲곌? ?섏닔猷?, "?붿쑉/湲덉븸": "0.0046396%", "鍮꾧퀬": "嫄곕옒???덊긽????(留ㅻℓ湲덉븸 湲곗?)"},
            {"援щ텇": "?⑷퀎 (?몃룄)", "?붿쑉/湲덉븸": "??0.17%", "鍮꾧퀬": "留ㅼ닔 ?먮뒗 留ㅻ룄 1?뚮떦"},
            {"援щ텇": "?⑷퀎 (?뺣났)", "?붿쑉/湲덉븸": "??0.34%", "鍮꾧퀬": "留ㅼ닔 + 留ㅻ룄 1?명듃"},
        ])
        st.dataframe(fee_data, use_container_width=True, hide_index=True)

        st.subheader("2. ?멸툑")
        tax_data = pd.DataFrame([
            {"援щ텇": "?묐룄?뚮뱷??, "?몄쑉": "鍮꾧낵??, "鍮꾧퀬": "KRX 湲덉떆??留ㅻℓ李⑥씡? ?묐룄??硫댁젣"},
            {"援щ텇": "諛곕떦?뚮뱷??, "?몄쑉": "15.4%", "鍮꾧퀬": "蹂닿?猷??섍툒湲??댁옄) 諛쒖깮 ??},
            {"援щ텇": "遺媛媛移섏꽭 (留ㅻℓ)", "?몄쑉": "硫댁꽭", "鍮꾧퀬": "KRX ?λ궡 嫄곕옒 ??遺媛???놁쓬"},
            {"援щ텇": "遺媛媛移섏꽭 (?ㅻЪ ?몄텧)", "?몄쑉": "10%", "鍮꾧퀬": "?됯퇏 留ㅼ닔?④? x ?몄텧 ?섎웾 湲곗?"},
        ])
        st.dataframe(tax_data, use_container_width=True, hide_index=True)
        st.info("KRX 湲덉떆?μ쓽 理쒕? ?μ젏: **留ㅻℓ李⑥씡 鍮꾧낵??+ 遺媛??硫댁꽭** (?ㅻЪ ?몄텧 ?쒖뿉留?遺媛??10% 遺怨?")

        st.subheader("3. 蹂닿?猷?)
        st.markdown(
            "| ??ぉ | ?댁슜 |\n"
            "|------|------|\n"
            "| **蹂닿?猷뚯쑉** | 留ㅼ씪 ?붾웾???쒓? ?섏궛 湲덉븸 x **0.02% (?곗쑉)** |\n"
            "| **?쇳븷 怨꾩궛** | ?쒓? x 蹂댁쑀?섎웾 x 0.0002% / 365??|\n"
            "| **遺媛??* | 蹂꾨룄 (蹂닿?猷뚯쓽 10%) |\n"
            "| **遺怨?二쇨린** | 留ㅼ썡 留??뺤궛 |\n"
            "\n"
            "> ?덉떆: 湲?100g 蹂댁쑀, ?쒓? 13留뚯썝/g ???곌컙 蹂닿?猷???**2,600??* (遺媛??蹂꾨룄)\n"
        )

        st.subheader("4. 湲??ъ옄 諛⑸쾿蹂?鍮꾧탳")
        compare_data = pd.DataFrame([
            {"?ъ옄 諛⑸쾿": "KRX 湲덊쁽臾?, "留ㅻℓ李⑥씡 ?멸툑": "鍮꾧낵??, "遺媛??: "硫댁꽭 (?몄텧??10%)", "嫄곕옒 ?섏닔猷?: "~0.17%", "?ㅻЪ ?몄텧": "媛??(100g/1kg)"},
            {"?ъ옄 諛⑸쾿": "湲?ETF", "留ㅻℓ李⑥씡 ?멸툑": "15.4%", "遺媛??: "?대떦?놁쓬", "嫄곕옒 ?섏닔猷?: "~0.015%+蹂댁닔", "?ㅻЪ ?몄텧": "遺덇?"},
            {"?ъ옄 諛⑸쾿": "怨⑤뱶諭낇궧 (???", "留ㅻℓ李⑥씡 ?멸툑": "15.4%", "遺媛??: "留ㅼ엯??硫댁꽭, ?몄텧??10%", "嫄곕옒 ?섏닔猷?: "~1%", "?ㅻЪ ?몄텧": "媛??},
            {"?ъ옄 諛⑸쾿": "湲??ㅻЪ (洹湲덉냽??", "留ㅻℓ李⑥씡 ?멸툑": "鍮꾧낵??, "遺媛??: "10% (留ㅼ엯 ??", "嫄곕옒 ?섏닔猷?: "5~15% (?ㅽ봽?덈뱶)", "?ㅻЪ ?몄텧": "利됱떆"},
        ])
        st.dataframe(compare_data, use_container_width=True, hide_index=True)
        st.caption("異쒖쿂: ?ㅼ?利앷텒 湲덊쁽臾??섏닔猷??덈궡, KRX 湲덉떆???덈궡??| ?섏닔猷뚮뒗 蹂寃쎈맆 ???덉뒿?덈떎.")


def render_kis_isa_mode():
    """?쒓뎅?ъ옄利앷텒 ISA 怨꾩쥖 - ?꾨?由?WDR) ?꾨왂 紐⑤뱶"""
    from kis_trader import KISTrader

    st.title("?뱢 ISA ?꾨?由?WDR) ?꾨왂 (?쒓뎅?ъ옄利앷텒)")

    # ?? ?ъ씠?쒕컮: ?ㅼ젙 ??
    st.sidebar.header("ISA ?ㅼ젙")

    try:
        kis_ak = st.secrets.get("KIS_APP_KEY", "")
        kis_sk = st.secrets.get("KIS_APP_SECRET", "")
        kis_acct = st.secrets.get("KIS_ACCOUNT_NO", "")
        kis_prdt = st.secrets.get("KIS_ACNT_PRDT_CD", "01")
    except Exception:
        kis_ak = os.getenv("KIS_APP_KEY", "")
        kis_sk = os.getenv("KIS_APP_SECRET", "")
        kis_acct = os.getenv("KIS_ACCOUNT_NO", "")
        kis_prdt = os.getenv("KIS_ACNT_PRDT_CD", "01")

    if IS_CLOUD:
        st.sidebar.info("?벑 議고쉶 ?꾩슜 紐⑤뱶 (Cloud)")
    else:
        with st.sidebar.expander("KIS API Keys", expanded=False):
            kis_ak = st.text_input("App Key", value=kis_ak, type="password", key="kis_isa_ak")
            kis_sk = st.text_input("Secret Key", value=kis_sk, type="password", key="kis_isa_sk")
            kis_acct = st.text_input("怨꾩쥖踰덊샇 (8?먮━)", value=kis_acct, key="kis_isa_acct")
            kis_prdt = st.text_input("?곹뭹肄붾뱶", value=kis_prdt, key="kis_isa_prdt")

    # Trend ETF ?ㅼ젙 (1諛?- 異붿꽭 ?먮떒??
    st.sidebar.subheader("Trend ETF ?ㅼ젙 (1諛?")
    _trend_options = {
        "133690 TIGER 誘멸뎅?섏뒪??00 (2010??": "133690",
        "143850 TIGER 誘멸뎅S&P500?좊Ъ(H) (2011??": "143850",
        "360750 TIGER 誘멸뎅S&P500 (2020??": "360750",
        "305720 TIGER 誘멸뎅梨?0?꾩꽑臾?: "305720",
    }
    _trend_default = config.get("kis_isa_trend_etf", "133690 TIGER 誘멸뎅?섏뒪??00")
    selected_trend_label = st.sidebar.selectbox("Trend ETF (Signal)", list(_trend_options.keys()),
                                                index=list(_trend_options.keys()).index(_trend_default)
                                                if _trend_default in _trend_options else 0,
                                                key="kis_isa_trend_sel")
    trend_etf_code = _trend_options[selected_trend_label]

    # ETF ?ㅼ젙 (?덈쾭由ъ?/?≫떚釉?- ?ㅼ젣 留ㅻℓ ???
    st.sidebar.subheader("留ㅻℓ ETF ?ㅼ젙 (2諛??≫떚釉?")
    _etf_options = {
        "418660 TIGER 誘멸뎅?섏뒪??00?덈쾭由ъ? [蹂댁닔 0.25%]": "418660",
        "409820 KODEX 誘멸뎅?섏뒪??00?덈쾭由ъ?(H) [蹂댁닔 0.30%]": "409820",
        "423920 TIGER 誘멸뎅?꾨씪?명뵾?꾨컲?꾩껜?덈쾭由ъ? [蹂댁닔 0.58%]": "423920",
        "465610 ACE 誘멸뎅鍮낇뀒?촖OP7 Plus?덈쾭由ъ? [蹂댁닔 0.60%]": "465610",
        "461910 PLUS 誘멸뎅?뚰겕TOP10?덈쾭由ъ? [蹂댁닔 0.50%]": "461910",
        "426030 TIMEFOLIO 誘멸뎅?섏뒪??00?≫떚釉?[蹂댁닔 0.80%]": "426030",
    }
    _etf_default = config.get("kis_isa_etf", "418660 TIGER 誘멸뎅?섏뒪??00?덈쾭由ъ? [蹂댁닔 0.25%]")
    selected_etf_label = st.sidebar.selectbox("留ㅻℓ ETF", list(_etf_options.keys()),
                                               index=list(_etf_options.keys()).index(_etf_default)
                                               if _etf_default in _etf_options else 0,
                                               key="kis_isa_etf_sel")
    etf_code = _etf_options[selected_etf_label]
    st.sidebar.caption(f"?쒓렇?? {selected_trend_label} 湲곗?")

    # WDR ?꾨왂 ?뚮씪誘명꽣
    st.sidebar.subheader("WDR ?꾨왂 ?뚮씪誘명꽣")
    wdr_ov = st.sidebar.number_input("怨좏룊媛 ?꾧퀎媛?(%)", value=config.get("wdr_overvalue", 5.0),
                                      step=0.5, format="%.1f", key="wdr_ov", disabled=IS_CLOUD)
    wdr_uv = st.sidebar.number_input("??됯? ?꾧퀎媛?(%)", value=config.get("wdr_undervalue", -6.0),
                                      step=0.5, format="%.1f", key="wdr_uv", disabled=IS_CLOUD)

    if not IS_CLOUD:
        if st.sidebar.button("?뮶 ISA ?ㅼ젙 ???, key="kis_isa_save"):
            cfg = config.copy()
            cfg["kis_isa_trend_etf"] = selected_trend_label
            cfg["kis_isa_etf"] = selected_etf_label
            cfg["wdr_overvalue"] = wdr_ov
            cfg["wdr_undervalue"] = wdr_uv
            save_config(cfg)
            st.sidebar.success("????꾨즺!")

    # ?? ?몃젅?대뜑 珥덇린????
    @st.cache_resource
    def _get_kis_trader(ak, sk, acct, prdt):
        t = KISTrader(is_mock=False)
        t.app_key = ak
        t.app_secret = sk
        t.account_no = acct
        t.acnt_prdt_cd = prdt
        return t

    kis_trader = None
    if kis_ak and kis_sk:
        kis_trader = _get_kis_trader(kis_ak, kis_sk, kis_acct, kis_prdt)

    # ?? ??援ъ꽦 ??
    tab_i1, tab_i2, tab_i3 = st.tabs(["?? ?ㅼ떆媛?紐⑤땲?곕쭅", "?썟 ?섎룞 二쇰Ц", "?뮩 ?섏닔猷??멸툑"])

    # ?먥븧?먥븧?먥븧?먥븧?먥븧?먥븧?먥븧 Tab 1: ?ㅼ떆媛?紐⑤땲?곕쭅 ?먥븧?먥븧?먥븧?먥븧?먥븧?먥븧?먥븧
    with tab_i1:
        st.header("WDR ?쒓렇??紐⑤땲?곕쭅")
        st.caption(f"ETF: {selected_etf_label} | 怨좏룊媛>{wdr_ov}% | ??됯?<{wdr_uv}%")

        col_r1, _ = st.columns([1, 5])
        with col_r1:
            if st.button("?봽 ?덈줈怨좎묠", key="kis_isa_refresh"):
                st.cache_data.clear()
                st.rerun()

        # 怨꾩쥖 ?꾪솴
        with st.expander("?뮥 怨꾩쥖 ?꾪솴", expanded=True):
            if not kis_trader:
                st.warning("?ъ씠?쒕컮?먯꽌 KIS API Key瑜??낅젰?댁＜?몄슂.")
            else:
                with st.spinner("?붽퀬 議고쉶 以?.."):
                    if kis_trader.auth():
                        bal = kis_trader.get_balance()
                    else:
                        bal = None
                        st.error("KIS ?몄쬆 ?ㅽ뙣. API Key瑜??뺤씤?댁＜?몄슂.")

                if bal:
                    b1, b2, b3, b4 = st.columns(4)
                    b1.metric("?덉닔湲?, f"{bal['cash']:,.0f}??)

                    # ETF 蹂댁쑀 ?뺣낫
                    etf_h = next((h for h in bal['holdings'] if h['code'] == etf_code), None)
                    etf_qty = etf_h['qty'] if etf_h else 0
                    etf_eval = etf_h['eval_amt'] if etf_h else 0
                    etf_pnl = etf_h['pnl_rate'] if etf_h else 0

                    b2.metric("ETF 蹂댁쑀", f"{etf_qty}二?)
                    b3.metric("ETF ?됯?", f"{etf_eval:,.0f}??, delta=f"{etf_pnl:+.1f}%")
                    total = bal['cash'] + sum(h['eval_amt'] for h in bal['holdings'])
                    b4.metric("珥??먯궛", f"{total:,.0f}??)
                else:
                    st.info("?붽퀬 ?뺣낫瑜?遺덈윭?ㅼ? 紐삵뻽?듬땲??")

        # WDR ?쒓렇??遺꾩꽍
        with st.expander("?뱤 WDR ?쒓렇??遺꾩꽍", expanded=True):
            col_cfg1, col_cfg2 = st.columns([2, 1])
            with col_cfg1:
                st.caption(f"ETF: {selected_etf_label} | 怨좏룊媛>{wdr_ov}% | ??됯?<{wdr_uv}%")
            with col_cfg2:
                chart_period = st.radio("?쒖떆 湲곌컙", ["1??, "3??, "5??, "?꾩껜"], index=1, horizontal=True, key="wdr_period_sel")

            strategy = WDRStrategy({'overvalue_threshold': wdr_ov, 'undervalue_threshold': wdr_uv})
            SIGNAL_ETF_CODE = trend_etf_code

            @st.cache_data(ttl=3600) # ?쒓렇???곗씠?곕뒗 濡쒖뺄 ?ъ슜?섎?濡?TTL 湲멸쾶 ?ㅼ젙
            def _fetch_signal_chart_local(code):
                # 1. KIS 罹먯떆 濡쒕뱶
                df = data_cache.load_cached_kis(code, is_overseas=False)
                if df is not None and len(df) > 1000:
                    return df
                
                # 2. 踰덈뱾 CSV 濡쒕뱶 (data/ ?대뜑)
                df = data_cache.load_bundled_csv(code)
                if df is not None:
                    data_cache.save_cache_kis(code, is_overseas=False, df=df)
                    return df
                
                # 3. 理쒗썑???섎떒?쇰줈 API 1?뚮쭔 ?몄텧 (罹먯떆/踰덈뱾 紐⑤몢 ?놁쓣 ?뚮쭔)
                # ??濡쒖쭅? ?ъ슜?먭? 'api議고쉶?섏? 留먭퀬'?쇨퀬 ?덉쑝誘濡?理쒖냼??
                return None

            signal_df = _fetch_signal_chart_local(SIGNAL_ETF_CODE)
            
            if signal_df is None:
                st.error(f"??{selected_trend_label} 濡쒖뺄 ?곗씠?곕? 李얠쓣 ???놁뒿?덈떎. (data/{SIGNAL_ETF_CODE}_daily.csv ?뺤씤 ?꾩슂)")
            elif len(signal_df) < 500:
                st.warning(f"?좑툘 {selected_trend_label} ?곗씠?곌? ?덈Т ?곸뒿?덈떎. ({len(signal_df)}??")
            else:
                signal = strategy.analyze(signal_df)
                if signal:
                    # ?쒓렇??硫뷀듃由?
                    s1, s2, s3, s4 = st.columns(4)
                    div_color = "inverse" if signal['divergence'] > 0 else "normal"
                    s1.metric("?닿꺽??, f"{signal['divergence']:+.2f}%", delta=signal['state'])
                    s2.metric("133690 醫낃?", f"{signal['qqq_price']:,.0f}??)
                    s3.metric("異붿꽭??, f"{signal['trend']:,.0f}??)
                    s4.metric("湲곗???, signal['date'])

                    # 留ㅻℓ 鍮꾩쑉
                    r1, r2 = st.columns(2)
                    r1.info(f"留ㅻ룄 鍮꾩쑉: **{signal['sell_ratio']}%**")
                    r2.info(f"留ㅼ닔 鍮꾩쑉: **{signal['buy_ratio']}%**")

                    # ?곹깭 ?쒖떆
                    if signal['state'] == 'OVERVALUE':
                        st.error(f"?뵶 怨좏룊媛 援ш컙 (?닿꺽??{signal['divergence']:+.2f}% > {wdr_ov}%)")
                    elif signal['state'] == 'UNDERVALUE':
                        st.success(f"?윟 ??됯? 援ш컙 (?닿꺽??{signal['divergence']:+.2f}% < {wdr_uv}%)")
                    else:
                        st.warning(f"?윞 以묐┰ 援ш컙 ({wdr_uv}% ???닿꺽??{signal['divergence']:+.2f}% ??{wdr_ov}%)")

                    # 133690 李⑦듃 + 異붿꽭??
                    weekly = strategy.daily_to_weekly(signal_df)
                    trend = strategy.calc_growth_trend(weekly)

                    fig = make_subplots(rows=2, cols=1, shared_xaxes=True,
                                        row_heights=[0.7, 0.3],
                                        subplot_titles=["TIGER 誘멸뎅?섏뒪??00 (133690) 二쇰큺 vs ?깆옣 異붿꽭??, "?닿꺽??(%)"])

                    # ?쇱씤 ?곗씠??怨꾩궛
                    ov_line = trend * (1 + wdr_ov / 100)
                    uv_line = trend * (1 + wdr_uv / 100)
                    divergences = [(weekly['close'].values[i] - trend[i]) / trend[i] * 100
                                   if not np.isnan(trend[i]) and trend[i] > 0 else np.nan
                                   for i in range(len(trend))]

                    # ?쒖떆 湲곌컙 ?꾪꽣留?(?꾪꽣留???Plotly???꾨떖?댁빞 Y異뺤씠 ?먮룞 由ъ뒪耳?쇰맖)
                    if chart_period != "?꾩껜":
                        p_days = {"1??: 365, "3??: 1095, "5??: 1825}[chart_period]
                        cutoff_date = weekly.index[-1] - pd.Timedelta(days=p_days)
                        weekly_plot = weekly[weekly.index >= cutoff_date].copy()
                        trend_plot = trend[weekly.index >= cutoff_date]
                        ov_plot = ov_line[weekly.index >= cutoff_date]
                        uv_plot = uv_line[weekly.index >= cutoff_date]
                        div_plot = np.array(divergences)[weekly.index >= cutoff_date]
                    else:
                        weekly_plot = weekly
                        trend_plot = trend
                        ov_plot = ov_line
                        uv_plot = uv_line
                        div_plot = divergences

                    fig.add_trace(go.Scatter(x=weekly_plot.index, y=weekly_plot['close'],
                                             name=f'{selected_trend_label} 醫낃?', line=dict(color='#2196F3', width=1.5)), row=1, col=1)
                    fig.add_trace(go.Scatter(x=weekly_plot.index, y=trend_plot,
                                             name='?깆옣 異붿꽭??(260二?', line=dict(color='orange', width=2, dash='dot')), row=1, col=1)

                    # 怨좏룊媛/??됯? ?꾧퀎 ?쇱씤 異붽?
                    fig.add_trace(go.Scatter(x=weekly_plot.index, y=ov_plot,
                                             name=f'怨좏룊媛 ({wdr_ov}%)', line=dict(color='red', width=1, dash='dash')), row=1, col=1)
                    fig.add_trace(go.Scatter(x=weekly_plot.index, y=uv_plot,
                                             name=f'??됯? ({wdr_uv}%)', line=dict(color='green', width=1, dash='dash')), row=1, col=1)

                    # ?닿꺽???쒓퀎??
                    fig.add_trace(go.Scatter(x=weekly_plot.index, y=div_plot,
                                             name='?닿꺽??, line=dict(color='purple', width=1.5)), row=2, col=1)
                    fig.add_hline(y=wdr_ov, line_dash="dash", line_color="red",
                                  annotation_text=f"怨좏룊媛 {wdr_ov}%", row=2, col=1)
                    fig.add_hline(y=wdr_uv, line_dash="dash", line_color="green",
                                  annotation_text=f"??됯? {wdr_uv}%", row=2, col=1)
                    fig.add_hline(y=0, line_dash="dot", line_color="gray", row=2, col=1)

                    fig.update_layout(
                        height=700,
                        margin=dict(l=0, r=0, t=60, b=100),
                        showlegend=True,
                        legend=dict(
                            orientation="h",
                            yanchor="top",
                            y=-0.2,
                            xanchor="center",
                            x=0.5
                        ),
                        xaxis_rangeslider_visible=False
                    )
                    # ?몃젋??李⑦듃(Row 1)?먮룄 X異??쇰꺼(?곕룄) ?쒖떆
                    fig.update_xaxes(showticklabels=True, row=1, col=1)
                    fig.update_xaxes(showticklabels=True, row=2, col=1)

                    st.plotly_chart(fig, use_container_width=True)

                    # ?? 留ㅻℓ ETF ?쒕??덉씠????????????????????????????
                    st.divider()
                    st.subheader(f"?뱢 留ㅻℓ ?쒕??덉씠??({selected_etf_label.split()[0]})")

                    @st.cache_data(ttl=3600)
                    def _load_trade_etf_data(code, _trader=None):
                        _df = data_cache.load_cached_kis(code, is_overseas=False)
                        if _df is not None and len(_df) > 100:
                            return _df
                        _df = data_cache.load_bundled_csv(code)
                        if _df is not None:
                            return _df
                        if _trader:
                            return data_cache.fetch_and_cache_kis_domestic(_trader, code, count=1500)
                        return None

                    trade_etf_df = _load_trade_etf_data(etf_code, kis_trader)

                    if trade_etf_df is None or len(trade_etf_df) < 20:
                        st.info(f"留ㅻℓ ETF ({etf_code}) ?곗씠?곌? ?놁뒿?덈떎. KIS API ?곌껐 ???곗씠?곕? 議고쉶?섍굅??data/{etf_code}_daily.csv ?뚯씪??異붽??댁＜?몄슂.")
                    else:
                        # 留ㅻℓ ETF 二쇰큺 蹂??
                        trade_weekly = strategy.daily_to_weekly(trade_etf_df)

                        # ?쒓렇??weekly??trend/divergence 遺숈씠湲?
                        sig_df = weekly.copy()
                        sig_df['trend'] = trend
                        sig_df['divergence'] = divergences

                        # 怨듯넻 ?좎쭨 inner join
                        merged = sig_df.join(
                            trade_weekly.rename(columns={'close': 'trade_close'}),
                            how='inner'
                        ).dropna(subset=['trade_close', 'trend'])

                        if len(merged) < 10:
                            st.warning("?쒓렇??ETF? 留ㅻℓ ETF??怨듯넻 湲곌컙???덈Т 吏㏃뒿?덈떎.")
                        else:
                            # ?쒕??덉씠???ㅼ젙
                            _sim_c1, _sim_c2 = st.columns(2)
                            sim_capital = _sim_c1.number_input(
                                "珥덇린?먮낯 (??", min_value=1_000_000, value=10_000_000,
                                step=1_000_000, key="wdr_sim_cap"
                            )
                            sim_start_date = _sim_c2.date_input(
                                "?쒖옉??, value=merged.index[0].date(),
                                min_value=merged.index[0].date(),
                                max_value=merged.index[-1].date(),
                                key="wdr_sim_start"
                            )

                            # ?쒖옉???꾪꽣
                            sim_merged = merged[merged.index >= pd.Timestamp(sim_start_date)]
                            if len(sim_merged) < 5:
                                st.warning("?쒕??덉씠??湲곌컙???덈Т 吏㏃뒿?덈떎.")
                            else:
                                # ?? 二쇨컙 ?쒕??덉씠??猷⑦봽 ??
                                comm_rate = strategy.settings['commission_rate']
                                cash_ratio = strategy.settings['initial_cash_ratio']

                                first_price = sim_merged['trade_close'].iloc[0]
                                sim_cash = sim_capital * cash_ratio
                                sim_shares = int((sim_capital * (1 - cash_ratio)) / first_price)
                                sim_cash = sim_capital - sim_shares * first_price  # ?붿뿬 ?꾧툑

                                equity_records = [{
                                    'date': sim_merged.index[0],
                                    'equity': sim_cash + sim_shares * first_price,
                                    'cash': sim_cash, 'shares': sim_shares,
                                    'action': 'INIT', 'quantity': sim_shares,
                                    'price': first_price, 'state': '',
                                    'divergence': sim_merged['divergence'].iloc[0],
                                }]
                                sim_trades = [{
                                    'date': sim_merged.index[0].strftime('%Y-%m-%d'),
                                    'action': '珥덇린留ㅼ닔',
                                    'price': f"{first_price:,.0f}",
                                    'quantity': sim_shares,
                                    'amount': f"{sim_shares * first_price:,.0f}",
                                    'cash': f"{sim_cash:,.0f}",
                                    'shares': sim_shares,
                                    'state': '??,
                                }]

                                for _si in range(1, len(sim_merged)):
                                    _t_price = sim_merged['trade_close'].iloc[_si]
                                    _t_prev = sim_merged['trade_close'].iloc[_si - 1]
                                    _w_pnl = (_t_price - _t_prev) * sim_shares
                                    _div = sim_merged['divergence'].iloc[_si]

                                    if pd.isna(_div):
                                        _div = 0.0

                                    _act = strategy.get_rebalance_action(
                                        _w_pnl, _div, sim_shares, _t_price, sim_cash
                                    )

                                    if _act['action'] == 'SELL' and _act['quantity'] > 0:
                                        _sell_amt = _act['quantity'] * _t_price
                                        _comm = _sell_amt * comm_rate
                                        sim_cash += _sell_amt - _comm
                                        sim_shares -= _act['quantity']
                                        sim_trades.append({
                                            'date': sim_merged.index[_si].strftime('%Y-%m-%d'),
                                            'action': '留ㅻ룄',
                                            'price': f"{_t_price:,.0f}",
                                            'quantity': _act['quantity'],
                                            'amount': f"{_sell_amt:,.0f}",
                                            'cash': f"{sim_cash:,.0f}",
                                            'shares': sim_shares,
                                            'state': _act['state'],
                                        })
                                    elif _act['action'] == 'BUY' and _act['quantity'] > 0:
                                        _buy_amt = _act['quantity'] * _t_price
                                        _comm = _buy_amt * comm_rate
                                        sim_cash -= _buy_amt + _comm
                                        sim_shares += _act['quantity']
                                        sim_trades.append({
                                            'date': sim_merged.index[_si].strftime('%Y-%m-%d'),
                                            'action': '留ㅼ닔',
                                            'price': f"{_t_price:,.0f}",
                                            'quantity': _act['quantity'],
                                            'amount': f"{_buy_amt:,.0f}",
                                            'cash': f"{sim_cash:,.0f}",
                                            'shares': sim_shares,
                                            'state': _act['state'],
                                        })

                                    _total_val = sim_cash + sim_shares * _t_price
                                    equity_records.append({
                                        'date': sim_merged.index[_si],
                                        'equity': _total_val,
                                        'cash': sim_cash, 'shares': sim_shares,
                                        'action': _act['action'] or 'HOLD',
                                        'quantity': _act['quantity'],
                                        'price': _t_price,
                                        'state': _act['state'],
                                        'divergence': _div,
                                    })

                                # ?? ?깃낵 吏??怨꾩궛 ??
                                eq_df = pd.DataFrame(equity_records).set_index('date')
                                eq_series = eq_df['equity']

                                _final_eq = eq_series.iloc[-1]
                                _total_ret = (_final_eq / sim_capital - 1) * 100
                                _days = (eq_series.index[-1] - eq_series.index[0]).days
                                _cagr = (((_final_eq / sim_capital) ** (365 / _days)) - 1) * 100 if _days > 0 else 0

                                _peak = eq_series.cummax()
                                _dd = (eq_series - _peak) / _peak * 100
                                _mdd = _dd.min()

                                # ?고룊洹?MDD
                                _yr_mdds = _dd.groupby(_dd.index.year).min()
                                _avg_yr_mdd = _yr_mdds.mean() if len(_yr_mdds) > 0 else _mdd

                                # Sharpe (二쇨컙 湲곗?)
                                _weekly_ret = eq_series.pct_change().dropna()
                                _sharpe = 0.0
                                if len(_weekly_ret) > 1 and _weekly_ret.std() > 0:
                                    _sharpe = (_weekly_ret.mean() / _weekly_ret.std()) * np.sqrt(52)

                                _calmar = abs(_cagr / _mdd) if _mdd != 0 else 0

                                # 留ㅻℓ ?듦퀎
                                _buy_trades = [t for t in sim_trades if t['action'] == '留ㅼ닔' and t != sim_trades[0]]
                                _sell_trades = [t for t in sim_trades if t['action'] == '留ㅻ룄']
                                _trade_count = len(_buy_trades) + len(_sell_trades)

                                # ?밸쪧 (留ㅻ룄 湲곗? - 留ㅻ룄 ?쒖젏 ?먯궛??吏곸쟾 留ㅼ닔 ?쒖젏蹂대떎 ?믪쑝硫???
                                _win_count = 0
                                if len(_sell_trades) > 0:
                                    for _st_t in _sell_trades:
                                        _st_date = pd.Timestamp(_st_t['date'])
                                        _st_eq = eq_df.loc[eq_df.index <= _st_date, 'equity']
                                        if len(_st_eq) > 1 and _st_eq.iloc[-1] > _st_eq.iloc[-2]:
                                            _win_count += 1
                                    _win_rate = _win_count / len(_sell_trades) * 100
                                else:
                                    _win_rate = 0.0

                                # ?? 硫뷀듃由??쒖떆 ??
                                _m1, _m2, _m3, _m4 = st.columns(4)
                                _m1.metric("珥??섏씡瑜?, f"{_total_ret:+.2f}%")
                                _m2.metric("CAGR", f"{_cagr:+.2f}%")
                                _m3.metric("MDD", f"{_mdd:.2f}%")
                                _m4.metric("?ㅽ봽 鍮꾩쑉", f"{_sharpe:.2f}")
                                _m5, _m6, _m7, _m8, _m9 = st.columns(5)
                                _m5.metric("留ㅻℓ ?잛닔", f"{_trade_count}??)
                                _m6.metric("?밸쪧", f"{_win_rate:.1f}%")
                                _m7.metric("理쒖쥌 ?먯궛", f"{_final_eq:,.0f}??)
                                _m8.metric("Calmar", f"{_calmar:.2f}")
                                _m9.metric("?고룊洹쟋DD", f"{_avg_yr_mdd:.2f}%")

                                # ?? ?먯옘??而ㅻ툕 李⑦듃 ??
                                _eq_ret_pct = (eq_series / sim_capital - 1) * 100
                                # Buy & Hold
                                _bh_prices = sim_merged['trade_close']
                                _bh_pct = (_bh_prices / _bh_prices.iloc[0] - 1) * 100

                                fig_sim = go.Figure()
                                fig_sim.add_trace(go.Scatter(
                                    x=eq_series.index, y=_eq_ret_pct,
                                    mode='lines', name='WDR ?꾨왂',
                                    line=dict(color='royalblue', width=2)
                                ))
                                fig_sim.add_trace(go.Scatter(
                                    x=_bh_pct.index, y=_bh_pct.values,
                                    mode='lines', name='Buy & Hold',
                                    line=dict(color='gray', width=1, dash='dot')
                                ))
                                fig_sim.update_layout(
                                    title=f"?꾩쟻 ?섏씡瑜???WDR ?꾨왂 vs Buy&Hold ({etf_code})",
                                    yaxis_title="?섏씡瑜?(%)", height=350,
                                    margin=dict(l=0, r=0, t=40, b=30),
                                    legend=dict(orientation="h", yanchor="bottom", y=1.02, xanchor="left", x=0)
                                )
                                st.plotly_chart(fig_sim, use_container_width=True)

                                # ?? ?곕룄蹂??깃낵 ?뚯씠釉???
                                _yr_rows = []
                                for _yr in sorted(eq_series.index.year.unique()):
                                    _yr_eq = eq_series[eq_series.index.year == _yr]
                                    if _yr_eq.empty:
                                        continue
                                    _yr_ret = (_yr_eq.iloc[-1] / _yr_eq.iloc[0] - 1) * 100
                                    _yr_peak = _yr_eq.cummax()
                                    _yr_mdd = ((_yr_eq - _yr_peak) / _yr_peak * 100).min()
                                    # BH ?곕룄蹂?
                                    _yr_bh = _bh_prices[_bh_prices.index.year == _yr]
                                    _yr_bh_ret = (_yr_bh.iloc[-1] / _yr_bh.iloc[0] - 1) * 100 if len(_yr_bh) > 0 else 0
                                    _yr_rows.append({
                                        "?곕룄": _yr,
                                        "?섏씡瑜?%)": f"{_yr_ret:+.2f}",
                                        "MDD(%)": f"{_yr_mdd:.2f}",
                                        "Buy&Hold(%)": f"{_yr_bh_ret:+.2f}",
                                        "?쒖옉?먯궛": f"{_yr_eq.iloc[0]:,.0f}",
                                        "理쒖쥌?먯궛": f"{_yr_eq.iloc[-1]:,.0f}",
                                    })
                                if _yr_rows:
                                    _df_yr_sim = pd.DataFrame(_yr_rows)
                                    _avg_ret_s = np.mean([float(r["?섏씡瑜?%)"]) for r in _yr_rows])
                                    _avg_mdd_s = np.mean([float(r["MDD(%)"]) for r in _yr_rows])
                                    _avg_bh_s = np.mean([float(r["Buy&Hold(%)"]) for r in _yr_rows])
                                    _df_yr_sim = pd.concat([_df_yr_sim, pd.DataFrame([{
                                        "?곕룄": "?됯퇏", "?섏씡瑜?%)": f"{_avg_ret_s:+.2f}",
                                        "MDD(%)": f"{_avg_mdd_s:.2f}",
                                        "Buy&Hold(%)": f"{_avg_bh_s:+.2f}",
                                        "?쒖옉?먯궛": "??, "理쒖쥌?먯궛": "??,
                                    }])], ignore_index=True)
                                    st.caption("?곕룄蹂??깃낵")
                                    st.dataframe(_df_yr_sim, use_container_width=True, hide_index=True)

                                # ?? 嫄곕옒 ?댁뿭 ??
                                with st.expander("嫄곕옒 ?댁뿭", expanded=False):
                                    if sim_trades:
                                        st.dataframe(pd.DataFrame(sim_trades), use_container_width=True, hide_index=True)
                                    else:
                                        st.info("?ㅽ뻾??嫄곕옒媛 ?놁뒿?덈떎.")

                else:
                    st.error("WDR ?쒓렇??遺꾩꽍 ?ㅽ뙣 (?곗씠??遺議?")

        # ?먮룞留ㅻℓ 洹쒖튃
        with st.expander("?뽳툘 ?먮룞留ㅻℓ 洹쒖튃", expanded=False):
            st.markdown(f"""
**?ㅽ뻾 ?쒖젏**: GitHub Actions - 留ㅼ＜ 湲덉슂??KST 14:00

**?꾨?由?WDR) 3?④퀎 ?꾨왂**
- TIGER 誘멸뎅?섏뒪??00(133690) ?깆옣 異붿꽭??260二?濡ㅻ쭅) ?鍮??닿꺽?꾨줈 ?쒖옣 ?곹깭 ?먮떒
- 二쇨컙 ?먯씡???곕씪 留ㅻℓ 鍮꾩쑉 ?먮룞 議곗젙

| ?쒖옣 ?곹깭 | 議곌굔 | 留ㅻ룄鍮꾩쑉 | 留ㅼ닔鍮꾩쑉 |
|-----------|------|---------|---------|
| 怨좏룊媛 | ?닿꺽??> {wdr_ov}% | 100% | 66.7% |
| 以묐┰ | {wdr_uv}% ~ {wdr_ov}% | 66.7% | 66.7% |
| ??됯? | ?닿꺽??< {wdr_uv}% | 60% | 120% |

- **?섏씡 二쇨컙**: ?댁씡??留ㅻ룄鍮꾩쑉留뚰겮 ?ㅽ쁽 (?댁씡 ?ㅽ쁽)
- **?먯떎 二쇨컙**: ?먯떎??留ㅼ닔鍮꾩쑉留뚰겮 異붽? 留ㅼ닔 (?媛 留ㅼ닔)
- **?섏닔猷?*: ?쒓뎅?ъ옄利앷텒 ISA 0.014% (?뺣났 ~0.028%)
""")

    # ?먥븧?먥븧?먥븧?먥븧?먥븧?먥븧?먥븧 Tab 2: ?섎룞 二쇰Ц ?먥븧?먥븧?먥븧?먥븧?먥븧?먥븧?먥븧
    with tab_i2:
        st.header("?섎룞 二쇰Ц")
        if not kis_trader:
            st.warning("API Key瑜??ъ씠?쒕컮?먯꽌 ?낅젰?댁＜?몄슂.")
        else:
            # ?꾩옱媛 議고쉶
            cur_price = kis_trader.get_current_price(etf_code) or 0

            mc1, mc2, mc3 = st.columns(3)
            mc1.metric("醫낅ぉ肄붾뱶", etf_code)
            mc2.metric("?꾩옱媛", f"{cur_price:,.0f}?? if cur_price else "議고쉶 ?ㅽ뙣")
            if bal:
                mc3.metric("?덉닔湲?, f"{bal['cash']:,.0f}??)

            buy_tab, sell_tab = st.tabs(["?뵶 留ㅼ닔", "?뵷 留ㅻ룄"])

            with buy_tab:
                i_buy_type = st.radio("二쇰Ц ?좏삎", ["?쒖옣媛", "吏?뺢?"], horizontal=True, key="i_buy_type")
                if i_buy_type == "?쒖옣媛":
                    i_buy_amt = st.number_input("留ㅼ닔 湲덉븸 (??", min_value=10_000, value=100_000,
                                                step=10_000, key="i_buy_amt")
                    if cur_price > 0:
                        st.caption(f"?덉긽 ?섎웾: ~{int(i_buy_amt / cur_price)}二?)
                    if st.button("?쒖옣媛 留ㅼ닔", type="primary", key="i_buy_exec",
                                 use_container_width=True, disabled=IS_CLOUD):
                        with st.spinner("留ㅼ닔 二쇰Ц 以?.."):
                            result = kis_trader.smart_buy_krw(etf_code, i_buy_amt)
                        if result and result.get("success"):
                            st.success(f"留ㅼ닔 ?깃났! 二쇰Ц踰덊샇: {result.get('ord_no', '')}")
                        else:
                            st.error(f"留ㅼ닔 ?ㅽ뙣: {result}")
                else:
                    ic1, ic2 = st.columns(2)
                    i_buy_price = ic1.number_input("留ㅼ닔 媛寃?, min_value=1,
                                                    value=int(cur_price * 0.99) if cur_price else 10000,
                                                    step=5, key="i_buy_price")
                    i_buy_qty = ic2.number_input("留ㅼ닔 ?섎웾 (二?", min_value=1, value=1, step=1, key="i_buy_qty")
                    st.caption(f"珥앹븸: {i_buy_price * i_buy_qty:,.0f}??)
                    if st.button("吏?뺢? 留ㅼ닔", type="primary", key="i_lbuy_exec",
                                 use_container_width=True, disabled=IS_CLOUD):
                        with st.spinner("吏?뺢? 留ㅼ닔 以?.."):
                            result = kis_trader.send_order("BUY", etf_code, i_buy_qty,
                                                           price=i_buy_price, ord_dvsn="00")
                        if result and result.get("success"):
                            st.success(f"吏?뺢? 留ㅼ닔 ?깅줉! 二쇰Ц踰덊샇: {result.get('ord_no', '')}")
                        else:
                            st.error(f"留ㅼ닔 ?ㅽ뙣: {result}")

            with sell_tab:
                i_sell_type = st.radio("二쇰Ц ?좏삎", ["?쒖옣媛", "吏?뺢?"], horizontal=True, key="i_sell_type")
                # 蹂댁쑀 ?섎웾 議고쉶
                holding_qty = kis_trader.get_holding_qty(etf_code)
                st.info(f"蹂댁쑀 ?섎웾: **{holding_qty}二?*")

                if i_sell_type == "?쒖옣媛":
                    i_sell_qty = st.number_input("留ㅻ룄 ?섎웾 (二?", min_value=1,
                                                  value=max(1, holding_qty), step=1, key="i_sell_qty_idx")
                    qc1, qc2, qc3, qc4 = st.columns(4)
                    if holding_qty > 0:
                        if qc1.button("25%", key="is25_idx"):
                            st.session_state['i_sell_qty_idx'] = max(1, holding_qty // 4)
                            st.rerun()
                        if qc2.button("50%", key="is50_idx"):
                            st.session_state['i_sell_qty_idx'] = max(1, holding_qty // 2)
                            st.rerun()
                        if qc3.button("75%", key="is75_idx"):
                            st.session_state['i_sell_qty_idx'] = max(1, holding_qty * 3 // 4)
                            st.rerun()
                        if qc4.button("100%", key="is100_idx"):
                            st.session_state['i_sell_qty_idx'] = holding_qty
                            st.rerun()

                    if st.button("?쒖옣媛 留ㅻ룄", type="primary", key="i_sell_exec_idx",
                                 use_container_width=True, disabled=IS_CLOUD):
                        with st.spinner("留ㅻ룄 二쇰Ц 以?.."):
                            result = kis_trader.smart_sell_qty(etf_code, i_sell_qty)
                        if result and result.get("success"):
                            st.success(f"留ㅻ룄 ?깃났! 二쇰Ц踰덊샇: {result.get('ord_no', '')}")
                        else:
                            st.error(f"留ㅻ룄 ?ㅽ뙣: {result}")
                else:
                    sc1, sc2 = st.columns(2)
                    i_sell_price = sc1.number_input("留ㅻ룄 媛寃?, min_value=1,
                                                     value=int(cur_price * 1.01) if cur_price else 10000,
                                                     step=5, key="i_sell_price_idx")
                    i_sell_qty_l = sc2.number_input("留ㅻ룄 ?섎웾 (二?", min_value=1,
                                                     value=max(1, holding_qty), step=1, key="i_sell_qty_l_idx")
                    if st.button("吏?뺢? 留ㅻ룄", type="primary", key="i_lsell_exec_idx",
                                 use_container_width=True, disabled=IS_CLOUD):
                        with st.spinner("吏?뺢? 留ㅻ룄 以?.."):
                            result = kis_trader.send_order("SELL", etf_code, i_sell_qty_l,
                                                           price=i_sell_price, ord_dvsn="00")
                        if result and result.get("success"):
                            st.success(f"吏?뺢? 留ㅻ룄 ?깅줉! 二쇰Ц踰덊샇: {result.get('ord_no', '')}")
                        else:
                            st.error(f"留ㅻ룄 ?ㅽ뙣: {result}")

    # ?먥븧?먥븧?먥븧?먥븧?먥븧?먥븧?먥븧 Tab 3: ?섏닔猷??멸툑 ?먥븧?먥븧?먥븧?먥븧?먥븧?먥븧?먥븧
    with tab_i3:
        st.header("ISA 怨꾩쥖 ?섏닔猷?諛??멸툑 ?덈궡")
        st.caption("?쒓뎅?ъ옄利앷텒 湲곗? | ?섏닔猷뚮뒗 蹂寃쎈맆 ???덉쑝??怨듭떇 ?덊럹?댁??먯꽌 理쒖떊 ?뺣낫瑜??뺤씤?섏꽭??")

        st.subheader("1. 利앷텒?щ퀎 留ㅻℓ ?섏닔猷?鍮꾧탳")
        fee_data = pd.DataFrame([
            {"利앷텒??: "?쒓뎅?ъ옄利앷텒", "留ㅻℓ ?섏닔猷?: "0.0140396%", "鍮꾧퀬": "?섎Т ?⑤씪??(?꾩옱 ?ъ슜)"},
            {"利앷텒??: "?ㅼ?利앷텒", "留ㅻℓ ?섏닔猷?: "0.015%", "鍮꾧퀬": "?곸썒臾??⑤씪??},
            {"利앷텒??: "誘몃옒?먯뀑", "留ㅻℓ ?섏닔猷?: "0.014%", "鍮꾧퀬": "m.Stock ?⑤씪??},
            {"利앷텒??: "?쇱꽦利앷텒", "留ㅻℓ ?섏닔猷?: "0.015%", "鍮꾧퀬": "mPOP ?⑤씪??},
            {"利앷텒??: "NH?ъ옄", "留ㅻℓ ?섏닔猷?: "0.0140396%", "鍮꾧퀬": "?섎Т ?⑤씪??},
            {"利앷텒??: "?좎뒪利앷텒", "留ㅻℓ ?섏닔猷?: "臾대즺~0.015%", "鍮꾧퀬": "?좉퇋 ?대깽????臾대즺"},
        ])
        st.dataframe(fee_data, use_container_width=True, hide_index=True)

        st.subheader("2. ?쒓렇???뚯뒪 ETF")
        signal_etf_data = pd.DataFrame([
            {"ETF紐?: "TIGER 誘멸뎅?섏뒪??00", "珥앸낫??: "0.07%", "醫낅ぉ肄붾뱶": "133690", "鍮꾧퀬": "?쒓렇?먯슜 (2010.10 ?곸옣, 15?? ?대젰)"},
        ])
        st.dataframe(signal_etf_data, use_container_width=True, hide_index=True)
        st.caption("133690 二쇨컙 醫낃?濡?異붿꽭?졖룹씠寃⑸룄瑜?怨꾩궛?섏뿬 ?쒖옣 ?곹깭瑜??먮떒?⑸땲??")

        st.subheader("3. 留ㅻℓ ????덈쾭由ъ?/?≫떚釉?ETF 蹂댁닔 鍮꾧탳")
        etf_data = pd.DataFrame([
            {"ETF紐?: "TIGER 誘멸뎅?섏뒪??00?덈쾭由ъ?(?⑹꽦)", "珥앸낫??: "0.25%", "醫낅ぉ肄붾뱶": "418660", "援щ텇": "?섏뒪??2x"},
            {"ETF紐?: "KODEX 誘멸뎅?섏뒪??00?덈쾭由ъ?(?⑹꽦 H)", "珥앸낫??: "0.30%", "醫낅ぉ肄붾뱶": "409820", "援щ텇": "?섏뒪??2x(?섑뿤吏)"},
            {"ETF紐?: "TIGER 誘멸뎅?꾨씪?명뵾?꾨컲?꾩껜?덈쾭由ъ?(?⑹꽦)", "珥앸낫??: "0.58%", "醫낅ぉ肄붾뱶": "423920", "援щ텇": "諛섎룄泥?2x"},
            {"ETF紐?: "ACE 誘멸뎅鍮낇뀒?촖OP7 Plus?덈쾭由ъ?(?⑹꽦)", "珥앸낫??: "0.60%", "醫낅ぉ肄붾뱶": "465610", "援щ텇": "鍮낇뀒??2x"},
            {"ETF紐?: "PLUS 誘멸뎅?뚰겕TOP10?덈쾭由ъ?(?⑹꽦)", "珥앸낫??: "0.50%", "醫낅ぉ肄붾뱶": "461910", "援щ텇": "?뚰겕 2x"},
            {"ETF紐?: "TIMEFOLIO 誘멸뎅?섏뒪??00?≫떚釉?, "珥앸낫??: "0.80%", "醫낅ぉ肄붾뱶": "426030", "援щ텇": "?섏뒪???≫떚釉?},
        ])
        st.dataframe(etf_data, use_container_width=True, hide_index=True)
        st.caption("?쒓뎅? 2x源뚯?留??덉슜 (誘멸뎅 TQQQ 3x, SOXL 3x? 李⑥씠) | (H) = ?섑뿤吏, 臾댄몴湲?= ?섎끂異?)

        st.subheader("4. ISA ?몄젣?쒗깮")
        tax_data = pd.DataFrame([
            {"??ぉ": "鍮꾧낵???쒕룄 (?쇰컲??", "?댁슜": "200留뚯썝"},
            {"??ぉ": "鍮꾧낵???쒕룄 (?쒕?쨌泥?뀈??", "?댁슜": "400留뚯썝"},
            {"??ぉ": "?쒕룄 珥덇낵遺?, "?댁슜": "9.9% 遺꾨━怨쇱꽭 (?쇰컲 15.4% ?鍮??좊━)"},
            {"??ぉ": "?섎Т媛?낃린媛?, "?댁슜": "3??},
            {"??ぉ": "?곌컙 ?⑹엯?쒕룄", "?댁슜": "2,000留뚯썝 (珥?1?듭썝)"},
        ])
        st.dataframe(tax_data, use_container_width=True, hide_index=True)
        st.info("?꾨?由??꾨왂??二쇨컙 由щ갭?곗떛 留ㅻℓ李⑥씡??鍮꾧낵???쒕룄 ?댁뿉??硫댁꽭 泥섎━?섏뼱 **?덉꽭 ?④낵 洹밸???*")

def render_kis_overseas_wdr_mode():
    """?쒓뎅?ъ옄利앷텒 ?댁쇅二쇱떇 - TQQQ ?꾨?由?WDR) ?꾨왂 紐⑤뱶"""
    from kis_trader import KISTrader

    st.title("?눣?눡 TQQQ ?꾨?由?WDR) ?꾨왂 (?쒓뎅?ъ옄利앷텒)")

    # ?? ?ъ씠?쒕컮: ?ㅼ젙 ??
    st.sidebar.header("TQQQ ?ㅼ젙")

    try:
        kis_ak = st.secrets.get("KIS_APP_KEY", "")
        kis_sk = st.secrets.get("KIS_APP_SECRET", "")
        kis_acct = st.secrets.get("KIS_ACCOUNT_NO", "")
    except Exception:
        kis_ak = os.getenv("KIS_APP_KEY", "")
        kis_sk = os.getenv("KIS_APP_SECRET", "")
        kis_acct = os.getenv("KIS_ACCOUNT_NO", "")

    if IS_CLOUD:
        st.sidebar.info("?벑 議고쉶 ?꾩슜 紐⑤뱶 (Cloud)")
    else:
        with st.sidebar.expander("KIS API Keys", expanded=False):
            kis_ak = st.text_input("App Key", value=kis_ak, type="password", key="kis_tq_ak")
            kis_sk = st.text_input("Secret Key", value=kis_sk, type="password", key="kis_tq_sk")
            kis_acct = st.text_input("怨꾩쥖踰덊샇", value=kis_acct, key="kis_tq_acct")

    # WDR ?꾨왂 ?뚮씪誘명꽣
    st.sidebar.subheader("WDR ?꾨왂 ?뚮씪誘명꽣")
    wdr_ov = st.sidebar.number_input("怨좏룊媛 ?꾧퀎媛?(%)", value=config.get("wdr_tq_ov", 10.0),
                                      step=1.0, format="%.1f", key="wdr_tq_ov")
    wdr_uv = st.sidebar.number_input("??됯? ?꾧퀎媛?(%)", value=config.get("wdr_tq_uv", -15.0),
                                      step=1.0, format="%.1f", key="wdr_tq_uv")

    if st.sidebar.button("?뮶 TQQQ ?ㅼ젙 ???, key="kis_tq_save"):
        cfg = config.copy()
        cfg["wdr_tq_ov"] = wdr_ov
        cfg["wdr_tq_uv"] = wdr_uv
        save_config(cfg)
        st.sidebar.success("????꾨즺!")

    # ?? ?몃젅?대뜑 珥덇린????
    @st.cache_resource
    def _get_kis_trader(ak, sk, acct):
        t = KISTrader(is_mock=False)
        t.app_key, t.app_secret, t.account_no = ak, sk, acct
        return t

    kis_trader = None
    if kis_ak and kis_sk:
        kis_trader = _get_kis_trader(kis_ak, kis_sk, kis_acct)

    # ?? ??援ъ꽦 ??
    tab_t1, tab_t2, tab_t3 = st.tabs(["?? 紐⑤땲?곕쭅", "?㎦ 諛깊뀒?ㅽ듃", "?뮩 ?ㅼ쟾 媛?대뱶"])

    with tab_t1:
        st.header("TQQQ WDR ?쒓렇??)
        col_r1, col_r2 = st.columns([1, 2])
        with col_r1:
            if st.button("?봽 ?덈줈怨좎묠", key="tq_refresh"):
                st.cache_data.clear()
                st.rerun()
        with col_r2:
            chart_period_tq = st.radio("?쒖떆 湲곌컙", ["1??, "3??, "5??, "?꾩껜"], index=1, horizontal=True, key="tq_period_sel")

        strategy = WDRStrategy({'overvalue_threshold': wdr_ov, 'undervalue_threshold': wdr_uv, 'trend_period_weeks': 260})
        
        @st.cache_data(ttl=3600)
        def _fetch_tq_signal_auto(_trader=None):
            # 1. 濡쒖뺄 罹먯떆/踰덈뱾 ?곗꽑
            df = data_cache.load_cached_kis("QQQ", is_overseas=True)
            if df is not None and len(df) > 1000: return df

            df_bundle = data_cache.load_bundled_csv("QQQ")
            if df_bundle is not None:
                data_cache.save_cache_kis("QQQ", is_overseas=True, df=df_bundle)
                if len(df_bundle) > 1000: return df_bundle

            # 2. ?녾굅??遺議깊븯硫?API ?곕룞 (?몃젅?대뜑 ?덉쓣 ??
            if _trader:
                with st.spinner("?댁쇅 吏??QQQ) ?곗씠??API 議고쉶 以?.."):
                    df_api = data_cache.fetch_and_cache_kis_overseas(_trader, "QQQ", count=6000)
                    if df_api is not None: return df_api

            return df if df is not None else df_bundle

        signal_df = _fetch_tq_signal_auto(kis_trader)

        if signal_df is None:
            st.error("??QQQ 媛寃??곗씠?곕? 媛?몄삱 ???놁뒿?덈떎. API ?ㅼ젙???뺤씤?섍굅??data/QQQ_daily.csv ?뚯씪???뺤씤?댁＜?몄슂.")
        else:
            signal = strategy.analyze(signal_df)
            if signal:
                s1, s2, s3, s4 = st.columns(4)
                s1.metric("?닿꺽??, f"{signal['divergence']:+.2f}%", delta=signal['state'])
                s2.metric("QQQ 醫낃?", f"${signal['qqq_price']:,.2f}")
                s3.metric("異붿꽭??, f"${signal['trend']:,.2f}")
                s4.metric("湲곗???, signal['date'])

                # 李⑦듃 異쒕젰
                weekly = strategy.daily_to_weekly(signal_df)
                trend = strategy.calc_growth_trend(weekly)
                
                fig = make_subplots(rows=2, cols=1, shared_xaxes=True, row_heights=[0.7, 0.3],
                                    subplot_titles=["QQQ 二쇰큺 vs ?깆옣 異붿꽭??, "?닿꺽??(%)"])
                
                # ?쇱씤 ?곗씠??怨꾩궛
                ov_line = trend * (1 + wdr_ov / 100)
                uv_line = trend * (1 + wdr_uv / 100)
                divergences = [(weekly['close'].values[i] - trend[i]) / trend[i] * 100
                               if not np.isnan(trend[i]) and trend[i] > 0 else np.nan
                               for i in range(len(trend))]

                # ?쒖떆 湲곌컙 ?꾪꽣留?
                if chart_period_tq != "?꾩껜":
                    p_days = {"1??: 365, "3??: 1095, "5??: 1825}[chart_period_tq]
                    cutoff_date = weekly.index[-1] - pd.Timedelta(days=p_days)
                    weekly_plot = weekly[weekly.index >= cutoff_date].copy()
                    trend_plot = trend[weekly.index >= cutoff_date]
                    ov_plot = ov_line[weekly.index >= cutoff_date]
                    uv_plot = uv_line[weekly.index >= cutoff_date]
                    div_plot = np.array(divergences)[weekly.index >= cutoff_date]
                else:
                    weekly_plot = weekly
                    trend_plot = trend
                    ov_plot = ov_line
                    uv_plot = uv_line
                    div_plot = divergences

                fig.add_trace(go.Scatter(x=weekly_plot.index, y=weekly_plot['close'], name='QQQ 醫낃?', line=dict(color='#2196F3', width=1.5)), row=1, col=1)
                fig.add_trace(go.Scatter(x=weekly_plot.index, y=trend_plot, name='?깆옣 異붿꽭??, line=dict(color='orange', width=2, dash='dot')), row=1, col=1)

                fig.add_trace(go.Scatter(x=weekly_plot.index, y=ov_plot, name=f'怨좏룊媛 ({wdr_ov}%)', line=dict(color='red', width=1, dash='dash')), row=1, col=1)
                fig.add_trace(go.Scatter(x=weekly_plot.index, y=uv_plot, name=f'??됯? ({wdr_uv}%)', line=dict(color='green', width=1, dash='dash')), row=1, col=1)
                
                # ?닿꺽???쒓퀎??
                fig.add_trace(go.Scatter(x=weekly_plot.index, y=div_plot, name='?닿꺽??, line=dict(color='purple', width=1.5)), row=2, col=1)
                fig.add_hline(y=wdr_ov, line_dash="dash", line_color="red", row=2, col=1)
                fig.add_hline(y=wdr_uv, line_dash="dash", line_color="green", row=2, col=1)
                fig.add_hline(y=0, line_dash="dot", line_color="gray", row=2, col=1)
                
                fig.update_layout(height=600, margin=dict(l=0, r=0, t=60, b=100), showlegend=True,
                                  legend=dict(orientation="h", yanchor="top", y=-0.2, xanchor="center", x=0.5),
                                  xaxis_rangeslider_visible=False)
                
                st.plotly_chart(fig, use_container_width=True)

    with tab_t2:
        st.subheader("?㎦ TQQQ WDR ?꾨왂 諛깊뀒?ㅽ듃")
        if 'signal_df' in locals() and signal_df is not None:
            with st.spinner("諛깊뀒?ㅽ듃 怨꾩궛 以?.."):
                perf = strategy.backtest(signal_df)
                if perf:
                    equity_df = perf['equity_df'].copy()
                    equity_df['year'] = equity_df.index.year
                    yearly_mdds = []
                    for year, group in equity_df.groupby('year'):
                        roll_max = group['equity'].cummax()
                        drawdown = (group['equity'] - roll_max) / roll_max * 100
                        yearly_mdds.append(drawdown.min())
                    avg_yearly_mdd = np.mean(yearly_mdds) if yearly_mdds else perf['mdd']

                    p1, p2, p3, p4, p5 = st.columns(5)
                    p1.metric("珥??섏씡瑜?, f"{perf['total_return']:+.2f}%")
                    p2.metric("CAGR", f"{perf['cagr']:.2f}%")
                    p3.metric("MDD (Max)", f"{perf['mdd']:.2f}%")
                    p4.metric("?고룊洹쟋DD", f"{avg_yearly_mdd:.2f}%")
                    p5.metric("Sharpe", f"{perf.get('sharpe', 0):.2f}")
                    
                    # ?먯옘??而ㅻ툕
                    fig_bt = go.Figure()
                    fig_bt.add_trace(go.Scatter(x=equity_df.index, y=equity_df['equity'], 
                                               name="?꾨왂 ?먯궛", line=dict(color='#2196F3', width=2)))
                    fig_bt.update_layout(title="?꾩쟻 ?섏씡瑜?怨≪꽑 (WDR ?꾨왂 湲곗?)", height=400, margin=dict(l=0, r=0, t=50, b=10))
                    st.plotly_chart(fig_bt, use_container_width=True)

                    # ?곕룄蹂??깃낵 ?뚯씠釉?+ Average ??
                    st.subheader("?뱟 ?곕룄蹂??깃낵")
                    yearly_returns = equity_df['equity'].resample('YE').last().pct_change() * 100
                    # 泥ロ빐 蹂댁젙 (珥덇린?먯궛 100 媛??- equity_df['equity']媛 ?먯궛湲덉븸?대㈃ ?ㅻ쫫. strategy.backtest瑜?遊먯빞 ??
                    # 留뚯빟 1.0 湲곗??대㈃:
                    if not equity_df.empty:
                        first_val = equity_df['equity'].iloc[0]
                        initial_val = 1.0 # 蹂댄넻 1.0?먯꽌 ?쒖옉??
                        yearly_returns.iloc[0] = (equity_df['equity'].resample('YE').last().iloc[0] / initial_val - 1) * 100
                    
                    y_data = []
                    for year in sorted(equity_df['year'].unique()):
                        y_ret = yearly_returns[yearly_returns.index.year == year].values[0] if year in yearly_returns.index.year else 0
                        y_mdd = next((mdd for y, mdd in zip(sorted(equity_df['year'].unique()), yearly_mdds) if y == year), 0)
                        y_data.append({"Year": str(year), "Return (%)": y_ret, "MDD (%)": y_mdd})
                    
                    df_y = pd.DataFrame(y_data).set_index("Year")
                    
                    # Average ??異붽?
                    avg_row = pd.DataFrame(
                        {"Return (%)": [df_y["Return (%)"].mean()], "MDD (%)": [df_y["MDD (%)"].mean()]},
                        index=["Average"]
                    )
                    df_y_final = pd.concat([df_y, avg_row])
                    st.dataframe(df_y_final.style.format("{:.2f}%").background_gradient(cmap='RdYlGn', subset=['Return (%)']).background_gradient(cmap='RdYlGn_r', subset=['MDD (%)']), use_container_width=True)
                else:
                    st.info("異⑸텇???곗씠?곌? ?놁뒿?덈떎.")

    with tab_t3:
        st.subheader("?뮕 TQQQ ?꾨?由?媛?대뱶")
        st.markdown(f"""
        - **?먮━**: ?섏뒪??100吏??QQQ)???κ린 ?곗긽??異붿꽭?좎쓣 ?닿꺽?꾨줈 遺꾩꽍?섏뿬 TQQQ(3諛? 鍮꾩쨷 議곗젅
        - **湲곗?**: 湲곕낯 260二?5?? ?깆옣 異붿꽭??(?뺤옣 ?덈룄???곸슜)
        - **???*:
            - 怨좏룊媛(>{wdr_ov}%): 鍮꾩쨷 異뺤냼 諛??듭젅
            - ??됯?(<{wdr_uv}%): 鍮꾩쨷 ?뺣? 諛?怨듦꺽??留ㅼ닔
        """)

        # ?먮룞留ㅻℓ 洹쒖튃
        with st.expander("?뽳툘 ?먮룞留ㅻℓ 洹쒖튃", expanded=True):
            st.markdown(f"""
**?ㅽ뻾 ?쒖젏**: GitHub Actions - 留ㅼ＜ 湲덉슂??KST 14:00

**?꾨?由?WDR) 3?④퀎 ?꾨왂**
- QQQ(?섏뒪??00) ?깆옣 異붿꽭??260二?濡ㅻ쭅) ?鍮??닿꺽?꾨줈 ?쒖옣 ?곹깭 ?먮떒
- 二쇨컙 ?먯씡???곕씪 TQQQ(3x) 留ㅻℓ 鍮꾩쑉 ?먮룞 議곗젙

| ?쒖옣 ?곹깭 | 議곌굔 | 留ㅻ룄鍮꾩쑉 | 留ㅼ닔鍮꾩쑉 |
|-----------|------|---------|---------|
| 怨좏룊媛 | ?닿꺽??> {wdr_ov}% | 100% | 66.7% |
| 以묐┰ | {wdr_uv}% ~ {wdr_ov}% | 66.7% | 66.7% |
| ??됯? | ?닿꺽??< {wdr_uv}% | 60% | 120% |

- **?섏씡 二쇨컙**: ?댁씡??留ㅻ룄鍮꾩쑉留뚰겮 ?ㅽ쁽 (?댁씡 ?ㅽ쁽)
- **?먯떎 二쇨컙**: ?먯떎??留ㅼ닔鍮꾩쑉留뚰겮 異붽? 留ㅼ닔 (?媛 留ㅼ닔)
""")



def render_kis_pension_mode():
    """?쒓뎅?ъ옄利앷텒 ?곌툑?異?怨꾩쥖 - ??쇰え硫섑?(GEM) ?꾨왂 紐⑤뱶"""
    from kis_trader import KISTrader

    st.title("?뮥 ?곌툑?異???쇰え硫섑?(GEM) ?꾨왂 (?쒓뎅?ъ옄利앷텒)")

    # ?? ?ъ씠?쒕컮: ?ㅼ젙 ??
    st.sidebar.header("?곌툑?異??ㅼ젙")

    try:
        kis_ak = st.secrets.get("KIS_APP_KEY", "")
        kis_sk = st.secrets.get("KIS_APP_SECRET", "")
        kis_acct = st.secrets.get("KIS_PENSION_ACCOUNT_NO", "") or st.secrets.get("KIS_ACCOUNT_NO", "")
        kis_prdt = st.secrets.get("KIS_PENSION_ACNT_PRDT_CD", "") or st.secrets.get("KIS_ACNT_PRDT_CD", "01")
    except Exception:
        kis_ak = os.getenv("KIS_APP_KEY", "")
        kis_sk = os.getenv("KIS_APP_SECRET", "")
        kis_acct = os.getenv("KIS_PENSION_ACCOUNT_NO", "") or os.getenv("KIS_ACCOUNT_NO", "")
        kis_prdt = os.getenv("KIS_PENSION_ACNT_PRDT_CD", "") or os.getenv("KIS_ACNT_PRDT_CD", "01")

    if IS_CLOUD:
        st.sidebar.info("?벑 議고쉶 ?꾩슜 紐⑤뱶 (Cloud)")
    else:
        with st.sidebar.expander("KIS API Keys", expanded=False):
            kis_ak = st.text_input("App Key", value=kis_ak, type="password", key="kis_pen_ak")
            kis_sk = st.text_input("Secret Key", value=kis_sk, type="password", key="kis_pen_sk")
            kis_acct = st.text_input("怨꾩쥖踰덊샇 (8?먮━)", value=kis_acct, key="kis_pen_acct")
            kis_prdt = st.text_input("?곹뭹肄붾뱶", value=kis_prdt, key="kis_pen_prdt")

    # ETF 留ㅽ븨 ?ㅼ젙
    st.sidebar.subheader("ETF 留ㅽ븨")
    _kr_spy_default = config.get("kr_etf_spy", "360750")
    _kr_efa_default = config.get("kr_etf_efa", "453850")
    _kr_agg_default = config.get("kr_etf_agg", "453540")

    spy_options = {"360750 TIGER 誘멸뎅S&P500 (0.07%)": "360750",
                   "379800 KODEX 誘멸뎅S&P500TR (0.045%)": "379800"}
    efa_options = {"453850 TIGER ?좎쭊援쵲SCI World (0.19%)": "453850",
                   "251350 KODEX ?좎쭊援쵲SCI World (0.18%)": "251350"}
    agg_options = {"453540 TIGER 誘멸뎅梨?0?꾩꽑臾?(0.10%)": "453540",
                   "308620 KODEX 誘멸뎅梨?0?꾩꽑臾?(0.09%)": "308620",
                   "471460 ACE 誘멸뎅30?꾧뎅梨꾩븸?곕툕 (0.05%)": "471460"}

    kr_spy = st.sidebar.selectbox("SPY ???ETF", list(spy_options.keys()), key="kr_spy_sel",
                                   disabled=IS_CLOUD)
    kr_efa = st.sidebar.selectbox("EFA ???ETF", list(efa_options.keys()), key="kr_efa_sel",
                                   disabled=IS_CLOUD)
    kr_agg = st.sidebar.selectbox("AGG ???ETF", list(agg_options.keys()), key="kr_agg_sel",
                                   disabled=IS_CLOUD)

    kr_etf_map = {
        'SPY': spy_options[kr_spy],
        'EFA': efa_options[kr_efa],
        'AGG': agg_options[kr_agg],
    }

    if not IS_CLOUD:
        if st.sidebar.button("?뮶 ?곌툑?異??ㅼ젙 ???, key="kis_pen_save"):
            cfg = config.copy()
            cfg["kr_etf_spy"] = spy_options[kr_spy]
            cfg["kr_etf_efa"] = efa_options[kr_efa]
            cfg["kr_etf_agg"] = agg_options[kr_agg]
            save_config(cfg)
            st.sidebar.success("????꾨즺!")

    # ?? ?몃젅?대뜑 珥덇린????
    @st.cache_resource
    def _get_kis_pen_trader(ak, sk, acct, prdt):
        t = KISTrader(is_mock=False)
        t.app_key = ak
        t.app_secret = sk
        t.account_no = acct
        t.acnt_prdt_cd = prdt
        return t

    kis_trader = None
    if kis_ak and kis_sk:
        kis_trader = _get_kis_pen_trader(kis_ak, kis_sk, kis_acct, kis_prdt)

    # ?? ??援ъ꽦 ??
    tab_p1, tab_p2, tab_p3, tab_p4, tab_p5 = st.tabs(["?? ?ㅼ떆媛?紐⑤땲?곕쭅", "?㎦ 諛깊뀒?ㅽ듃", "?썟 ?섎룞 二쇰Ц", "?뱰 ?꾨왂 媛?대뱶", "?뮩 ?섏닔猷??멸툑"])

    # ?먥븧?먥븧?먥븧?먥븧?먥븧?먥븧?먥븧 Tab 1: ?ㅼ떆媛?紐⑤땲?곕쭅 ?먥븧?먥븧?먥븧?먥븧?먥븧?먥븧?먥븧
    with tab_p1:
        st.header("??쇰え硫섑? ?쒓렇??紐⑤땲?곕쭅")
        st.caption(f"SPY??kr_etf_map['SPY']} | EFA??kr_etf_map['EFA']} | AGG??kr_etf_map['AGG']}")

        col_r1, _ = st.columns([1, 5])
        with col_r1:
            if st.button("?봽 ?덈줈怨좎묠", key="kis_pen_refresh"):
                st.cache_data.clear()
                st.rerun()

        # ?곗씠??濡쒕뱶 (?쒓렇??遺꾩꽍??
        strategy = DualMomentumStrategy(settings={'kr_etf_map': {**kr_etf_map, 'BIL': None}})

        @st.cache_data(ttl=3600)
        def _fetch_momentum_data_full(_trader=None):
            data = {}
            tickers = ['SPY', 'EFA', 'BIL', 'AGG']
            for ticker in tickers:
                # 1. 濡쒖뺄 罹먯떆/踰덈뱾 ?곗꽑
                df = data_cache.load_cached_kis(ticker, is_overseas=True)
                if df is None or len(df) < 1000:
                    df = data_cache.load_bundled_csv(ticker)
                    if df is not None:
                        data_cache.save_cache_kis(ticker, is_overseas=True, df=df)
                
                # 2. ?놁쑝硫?API (?몃젅?대뜑 ?덉쓣 ??
                if df is None and _trader:
                    df = data_cache.fetch_and_cache_kis_overseas(_trader, ticker, count=6000)
                
                if df is not None:
                    data[ticker] = df
                time.sleep(0.1)
            return data if len(data) == 4 else None

        with st.status("?곗씠??以鍮?以?(SPY, EFA, BIL, AGG)...", expanded=False) as pen_status:
            price_data = _fetch_momentum_data_full(kis_trader)
            if price_data:
                pen_status.update(label="?곗씠??以鍮??꾨즺", state="complete")
            else:
                pen_status.update(label="?곗씠??以鍮??ㅽ뙣 (API Key ?먮뒗 濡쒖뺄 ?곗씠???뺤씤 ?꾩슂)", state="error")

        if price_data is None:
            st.error("???곗씠??議고쉶 ?ㅽ뙣. ?ъ씠?쒕컮?먯꽌 KIS API ?ㅼ젙???뺤씤?섍굅??濡쒖뺄 罹먯떆瑜??뺤씤?댁＜?몄슂.")
        else:
            # ?쒓렇???붿빟
            signal = strategy.analyze(price_data)
            if signal:
                s1, s2, s3 = st.columns(3)
                s1.metric("諛곕텇 ???, f"{signal['target_ticker']} ??{signal['target_kr_code']}")
                s2.metric("怨듦꺽?먯궛 ?щ?", "怨듦꺽" if signal['is_offensive'] else "諛⑹뼱")
                s3.metric("移대굹由ъ븘(BIL)", f"{signal['canary_return']:.4f}")

                if signal['is_offensive']: st.success(f"?뱢 {signal['reason']}")
                else: st.error(f"?썳截?{signal['reason']}")

            # 怨꾩쥖 ?꾪솴
            with st.expander("?뮥 怨꾩쥖 ?붽퀬 諛?蹂댁쑀 ?꾪솴", expanded=True):
                if not kis_trader:
                    st.warning("KIS API Key媛 ?ㅼ젙?섏? ?딆븯?듬땲?? ?ㅼ떆媛??붽퀬 議고쉶 遺덇?.")
                else:
                    if kis_trader.auth():
                        bal = kis_trader.get_balance()
                        if bal:
                            b1, b2 = st.columns(2)
                            b1.metric("?덉닔湲?, f"{bal['cash']:,.0f}??)
                            total = bal['total_eval'] or (bal['cash'] + sum(h['eval_amt'] for h in bal['holdings']))
                            b2.metric("珥??됯?", f"{total:,.0f}??)
                            if bal['holdings']:
                                df_bal = pd.DataFrame(bal['holdings'])
                                # 而щ읆紐??쒓???
                                df_bal = df_bal.rename(columns={'symbol': '肄붾뱶', 'name': '醫낅ぉ紐?, 'qty': '?섎웾', 'price': '?꾩옱媛', 'eval_amt': '?됯?湲덉븸', 'profit_pct': '?섏씡瑜?%)'})
                                st.dataframe(df_bal, use_container_width=True, hide_index=True)
                            else: st.info("蹂댁쑀 醫낅ぉ ?놁쓬")
                    else: st.error("KIS ?몄쬆 ?ㅽ뙣")

            # 紐⑤찘? ?먯닔 諛?李⑦듃
            if signal:
                with st.expander("?뱤 ?곸꽭 遺꾩꽍 (紐⑤찘? ?먯닔 諛?李⑦듃)", expanded=False):
                    score_data = []
                    for ticker, score in signal['scores'].items():
                        score_data.append({
                            "?곗빱": ticker, "紐⑤찘? ?먯닔": f"{score:.6f}",
                            "?쒓뎅 ETF": kr_etf_map.get(ticker, '-'),
                            "?좏깮": "?? if ticker == signal['target_ticker'] else ""
                        })
                    score_data.append({
                        "?곗빱": "BIL (移대굹由ъ븘)", "紐⑤찘? ?먯닔": f"{signal['canary_return']:.6f}",
                        "?쒓뎅 ETF": "-", "?좏깮": "?? if not signal['is_offensive'] else ""
                    })
                    st.dataframe(pd.DataFrame(score_data).set_index("?곗빱"), use_container_width=True)

                    fig = make_subplots(rows=2, cols=2, subplot_titles=["SPY", "EFA", "AGG", "BIL"])
                    positions = [(1,1), (1,2), (2,1), (2,2)]
                    colors = {'SPY': '#2196F3', 'EFA': '#FF9800', 'AGG': '#4CAF50', 'BIL': '#9C27B0'}
                    for (ticker, (r, c)) in zip(['SPY', 'EFA', 'AGG', 'BIL'], positions):
                        if ticker in price_data:
                            df_t = price_data[ticker].tail(500)
                            fig.add_trace(go.Scatter(x=df_t.index, y=df_t['close'], name=ticker,
                                                     line=dict(color=colors[ticker], width=1.5), showlegend=False), row=r, col=c)
                    fig.update_layout(height=450, margin=dict(l=0, r=0, t=40, b=10))
                    st.plotly_chart(fig, use_container_width=True)

    # ?먥븧?먥븧?먥븧?먥븧?먥븧?먥븧?먥븧 Tab 2: 諛깊뀒?ㅽ듃 ?먥븧?먥븧?먥븧?먥븧?먥븧?먥븧?먥븧
    with tab_p2:
        st.subheader("?㎦ ?꾨왂 諛깊뀒?ㅽ듃 寃곌낵 (?댁쇅 吏??湲곗?)")
        if 'price_data' in locals() and price_data:
            bt = strategy.run_backtest(price_data)
            if bt:
                m = bt['metrics']
                # ?고룊洹?MDD 怨꾩궛
                equity_df = bt['equity_df'].copy()
                equity_df['year'] = equity_df.index.year
                yearly_mdds = []
                for year, group in equity_df.groupby('year'):
                    roll_max = group['equity'].cummax()
                    drawdown = (group['equity'] - roll_max) / roll_max * 100
                    yearly_mdds.append(drawdown.min())
                avg_yearly_mdd = np.mean(yearly_mdds) if yearly_mdds else m['mdd']

                bc1, bc2, bc3, bc4, bc5 = st.columns(5)
                bc1.metric("?꾩쟻 ?섏씡瑜?, f"{m['total_return']:+.2f}%")
                bc2.metric("CAGR", f"{m['cagr']:.2f}%")
                bc3.metric("MDD (Max)", f"{m['mdd']:.2f}%")
                bc4.metric("?고룊洹쟋DD", f"{avg_yearly_mdd:.2f}%")
                bc5.metric("Sharpe", f"{m['sharpe']:.2f}")

                fig_bt = go.Figure()
                fig_bt.add_trace(go.Scatter(x=bt['equity_df'].index, y=bt['equity_df']['equity'], 
                                           name="?꾨왂 ?먯궛", line=dict(color='#2196F3', width=2)))
                fig_bt.update_layout(title="?꾩쟻 ?섏씡瑜?怨≪꽑 (?붾퀎 ?됯?)", height=400, margin=dict(l=0, r=0, t=50, b=10))
                st.plotly_chart(fig_bt, use_container_width=True)

                # ?곕룄蹂??깃낵 ?뚯씠釉?+ Average ??
                st.subheader("?뱟 ?곕룄蹂??깃낵")
                yearly_returns = bt['equity_df']['equity'].resample('YE').last().pct_change() * 100
                yearly_returns.iloc[0] = (bt['equity_df']['equity'].iloc[0] / 100.0 - 1) * 100 # 泥ロ빐 蹂댁젙 (珥덇린?먯궛 100 媛??
                
                y_data = []
                for year in sorted(equity_df['year'].unique()):
                    y_ret = yearly_returns[yearly_returns.index.year == year].values[0] if year in yearly_returns.index.year else 0
                    y_mdd = next((mdd for y, mdd in zip(sorted(equity_df['year'].unique()), yearly_mdds) if y == year), 0)
                    y_data.append({"Year": str(year), "Return (%)": y_ret, "MDD (%)": y_mdd})
                
                df_y = pd.DataFrame(y_data).set_index("Year")
                
                # Average ??異붽?
                avg_row = pd.DataFrame(
                    {"Return (%)": [df_y["Return (%)"].mean()], "MDD (%)": [df_y["MDD (%)"].mean()]},
                    index=["Average"]
                )
                df_y_final = pd.concat([df_y, avg_row])
                st.dataframe(df_y_final.style.format("{:.2f}%").background_gradient(cmap='RdYlGn', subset=['Return (%)']).background_gradient(cmap='RdYlGn_r', subset=['MDD (%)']), use_container_width=True)

                with st.expander("?뱟 ?붾퀎 ?ъ????덉뒪?좊━", expanded=False):
                    pos_df = bt['positions'].sort_values('date', ascending=False).copy()
                    if not pos_df.empty:
                        st.dataframe(pos_df, use_container_width=True, hide_index=True)
            else:
                st.warning("諛깊뀒?ㅽ듃瑜??꾪븳 異⑸텇???대젰???놁뒿?덈떎 (理쒖냼 1?? ?꾩슂)")

    # ?먥븧?먥븧?먥븧?먥븧?먥븧?먥븧?먥븧 Tab 3: ?섎룞 二쇰Ц ?먥븧?먥븧?먥븧?먥븧?먥븧?먥븧?먥븧
    with tab_p3:
        st.header("?썟 ?섎룞 二쇰Ц")
        if not kis_trader:
            st.warning("API Key瑜??ъ씠?쒕컮?먯꽌 ?낅젰?댁＜?몄슂.")
        else:
            # 醫낅ぉ ?좏깮
            all_etfs = {**spy_options, **efa_options, **agg_options}
            selected_order_etf = st.selectbox("留ㅻℓ 醫낅ぉ ?좏깮", list(all_etfs.keys()), key="pen_order_etf")
            order_etf_code = all_etfs[selected_order_etf]

            cur_price = kis_trader.get_current_price(order_etf_code) or 0
            holding_qty = kis_trader.get_holding_qty(order_etf_code)

            mc1, mc2, mc3 = st.columns(3)
            mc1.metric("醫낅ぉ肄붾뱶", order_etf_code)
            mc2.metric("?꾩옱媛", f"{cur_price:,.0f}?? if cur_price else "議고쉶 ?ㅽ뙣")
            mc3.metric("蹂댁쑀 ?섎웾", f"{holding_qty}二?)

            buy_tab, sell_tab = st.tabs(["?뵶 留ㅼ닔 (?쒖옣媛)", "?뵷 留ㅻ룄 (?쒖옣媛)"])

            with buy_tab:
                p_buy_amt = st.number_input("留ㅼ닔 湲덉븸 (??", min_value=10_000, value=100_000,
                                            step=10_000, key="p_buy_amt")
                if cur_price > 0:
                    st.caption(f"?덉긽 ?섎웾: ~{int(p_buy_amt / cur_price)}二?)
                if st.button("?쒖옣媛 留ㅼ닔 ?ㅽ뻾", type="primary", key="p_buy_exec",
                             use_container_width=True, disabled=IS_CLOUD):
                    with st.spinner("留ㅼ닔 二쇰Ц 以?.."):
                        result = kis_trader.smart_buy_krw(order_etf_code, p_buy_amt)
                    if result and result.get("success"):
                        st.success(f"留ㅼ닔 ?깃났! 二쇰Ц踰덊샇: {result.get('ord_no', '')}")
                    else:
                        st.error(f"留ㅼ닔 ?ㅽ뙣: {result}")

            with sell_tab:
                p_sell_qty = st.number_input("留ㅻ룄 ?섎웾 (二?", min_value=1,
                                              value=max(1, holding_qty), step=1, key="p_sell_qty")
                qc1, qc2 = st.columns(2)
                if holding_qty > 0:
                    if qc1.button("50%", key="ps50"):
                        st.session_state['p_sell_qty'] = max(1, holding_qty // 2)
                        st.rerun()
                    if qc2.button("?꾨웾", key="ps100"):
                        st.session_state['p_sell_qty'] = holding_qty
                        st.rerun()

                if st.button("?쒖옣媛 留ㅻ룄 ?ㅽ뻾", type="primary", key="p_sell_exec",
                             use_container_width=True, disabled=IS_CLOUD):
                    with st.spinner("留ㅻ룄 二쇰Ц 以?.."):
                        result = kis_trader.smart_sell_qty(order_etf_code, p_sell_qty)
                    if result and result.get("success"):
                        st.success(f"留ㅻ룄 ?깃났! 二쇰Ц踰덊샇: {result.get('ord_no', '')}")
                    else:
                        st.error(f"留ㅻ룄 ?ㅽ뙣: {result}")
    
    # ?먥븧?먥븧?먥븧?먥븧?먥븧?먥븧?먥븧 Tab 4: ?꾨왂 媛?대뱶 ?먥븧?먥븧?먥븧?먥븧?먥븧?먥븧?먥븧
    with tab_p4:
        st.header("?뱰 ?꾨왂 媛?대뱶")
        st.markdown("""
### 1. ??쇰え硫섑?(GEM)?대??
?멸퀎?곸씤 ???Gary Antonacci媛 怨좎븞???꾨왂?쇰줈, **?곷? 紐⑤찘?**怨?**?덈? 紐⑤찘?**??寃고빀?섏뿬 MDD????텛怨??섏씡瑜좎? 洹밸??뷀빀?덈떎.

### 2. 誘멸뎅 ?먮낯 ?꾨왂 (US)
- **怨듦꺽 ?먯궛**: S&P500(SPY), ?좎쭊援?EFA)
- **諛⑹뼱 ?먯궛**: 誘멸뎅梨?0??AGG)
- **湲곗?(移대굹由ъ븘)**: 珥덈떒湲곗콈(BIL)
- **濡쒖쭅**:
    1. SPY? EFA 以?12媛쒖썡 ?섏씡瑜좎씠 ???믪? 履??좏깮 (?곷?)
    2. ?좏깮???먯궛???섏씡瑜좎씠 BIL蹂대떎 ??쑝硫?AGG濡????(?덈?)

### 3. ?쒓뎅??蹂寃?(KR Adaptation)
?곌툑?異?ISA 怨꾩쥖???댁쇅 ETF 吏곸젒 留ㅻℓ媛 遺덇??ν븯誘濡? 援?궡 ?곸옣??吏??異붿쥌 ETF濡??泥댄빀?덈떎.
- **SPY** ??TIGER 誘멸뎅S&P500
- **EFA** ??TIGER ?좎쭊援쵲SCI World
- **AGG** ??TIGER 誘멸뎅梨?0?꾩꽑臾?

**???쒓렇??*: ?댁쇅 ?먯???US) ?쒖꽭濡??뺥솗?섍쾶 ?먮떒?섎릺, ?ㅼ젣 留ㅻℓ留?援?궡 醫낅ぉ?쇰줈 ?섑뻾?섏뿬 吏???놁씠 異붿쥌?⑸땲??
        """)

        with st.expander("?뽳툘 ?먮룞留ㅻℓ 洹쒖튃", expanded=True):
            st.markdown("""
**?ㅽ뻾 ?쒖젏**: 留ㅼ썡 留덉?留??곸뾽??(KST 14:00)

1. SPY/EFA??理쒓렐 12媛쒖썡 ?섏씡瑜?怨꾩궛
2. ???믪? ?섏씡瑜좎쓣 媛吏??먯궛??'?곷? 紐⑤찘?' ?뱀옄濡??좏깮
3. ?대떦 ?먯궛???섏씡瑜좎씠 ?꾧툑(BIL) ?섏씡瑜좊낫???믪쑝硫??덈? 紐⑤찘?) 留ㅼ닔
4. 洹몃젃吏 ?딆쑝硫??덉쟾 ?먯궛(AGG) 留ㅼ닔(?먮뒗 ?좎?)
5. 留ㅼ썡 留??대떦 ?꾨줈?몄뒪 諛섎났 諛?由щ갭?곗떛
""")

    # ?먥븧?먥븧?먥븧?먥븧?먥븧?먥븧?먥븧 Tab 5: ?섏닔猷??멸툑 ?먥븧?먥븧?먥븧?먥븧?먥븧?먥븧?먥븧
    with tab_p5:
        st.header("?뮩 ?곌툑?異??섏닔猷?諛??몄젣?쒗깮")
        
        c1, c2 = st.columns(2)
        with c1:
            st.subheader("?뮥 怨꾩쥖 ?쒗깮")
            st.markdown("""
- **?몄븸怨듭젣**: ??600留뚯썝(IRP?ы븿 900) ?쒕룄, 13.2~16.5% ?몄븸怨듭젣
- **怨쇱꽭?댁뿰**: 怨꾩쥖 ??諛쒖깮??留ㅻℓ李⑥씡/諛곕떦湲덉뿉 ????몄텧 ?꾧퉴吏 怨쇱꽭 ????
- **??④낵??*: 留?55???댄썑 ?곌툑 ?섎졊 ??3.3~5.5%????? ?몄쑉 ?곸슜
            """)
        with c2:
            st.subheader("?뮯 ?섏닔猷??덈궡")
            st.markdown("""
- **留ㅻℓ?섏닔猷?*: 利앷텒?щ퀎 ?곸씠 (??0.01~0.015%)
- **?좉?湲곌??쒕퉬??*: ??0.004~0.005% 諛쒖깮
- **ETF 蹂댁닔**: 醫낅ぉ蹂???0.05~0.19% (?곌컙)
            """)

        st.divider()
        st.subheader("?뱤 二쇱슂 ETF 蹂댁닔 諛??뺣낫")
        etf_data = [
            {"醫낅ぉ紐?: "TIGER 誘멸뎅S&P500", "肄붾뱶": "360750", "珥앸낫??: "0.07%", "鍮꾧퀬": "SPY ???},
            {"醫낅ぉ紐?: "KODEX 誘멸뎅S&P500TR", "肄붾뱶": "379800", "珥앸낫??: "0.045%", "鍮꾧퀬": "遺꾨같湲??ы닾??},
            {"醫낅ぉ紐?: "TIGER ?좎쭊援쵲SCI World", "肄붾뱶": "453850", "珥앸낫??: "0.19%", "鍮꾧퀬": "EFA ???},
            {"醫낅ぉ紐?: "TIGER 誘멸뎅梨?0?꾩꽑臾?, "肄붾뱶": "453540", "珥앸낫??: "0.10%", "鍮꾧퀬": "AGG ???},
            {"醫낅ぉ紐?: "KODEX 誘멸뎅梨?0?꾩꽑臾?, "肄붾뱶": "308620", "珥앸낫??: "0.09%", "鍮꾧퀬": "AGG ???},
        ]
        st.dataframe(pd.DataFrame(etf_data), use_container_width=True, hide_index=True)



def main():
    # --- ?ъ씠?쒕컮 理쒖긽?? 嫄곕옒 紐⑤뱶 ?좏깮 ---
    st.sidebar.markdown("## ?룱 嫄곕옒 紐⑤뱶")
    trading_mode = st.sidebar.selectbox(
        "嫄곕옒 紐⑤뱶",
        ["?첌 肄붿씤 (Donchian, SMA)", "?쪍 Gold (?ㅼ? | Donchian, SMA)", "?뱢 ISA (?쒗닾 | ?꾨?由?", "?눣?눡 TQ?꾨?由?(?쒗닾 | WDR)", "?뮥 ?곌툑?異?(?쒗닾 | ??쇰え硫섑?)"],
        key="trading_mode",
        label_visibility="collapsed"
    )
    st.sidebar.divider()

    # ?? ?붾젅洹몃옩 ?뚮┝ ?ㅼ젙 (怨듯넻) ??
    with st.sidebar.expander("?벂 ?붾젅洹몃옩 ?뚮┝", expanded=False):
        try:
            _tg_token = st.secrets.get("TELEGRAM_BOT_TOKEN", "")
            _tg_chat = st.secrets.get("TELEGRAM_CHAT_ID", "")
        except Exception:
            _tg_token = os.getenv("TELEGRAM_BOT_TOKEN", "")
            _tg_chat = os.getenv("TELEGRAM_CHAT_ID", "")
        if IS_CLOUD:
            if _tg_token and _tg_chat:
                st.success("?붾젅洹몃옩 ?곌껐??)
            else:
                st.warning("Secrets??TELEGRAM_BOT_TOKEN, TELEGRAM_CHAT_ID瑜?異붽??댁＜?몄슂.")
        else:
            _tg_token = st.text_input("Bot Token", value=_tg_token, type="password", key="tg_token")
            _tg_chat = st.text_input("Chat ID", value=_tg_chat, key="tg_chat")
            if _tg_token and _tg_chat:
                st.caption(f"Chat ID: `{_tg_chat}`")
            else:
                st.caption(".env ?뚯씪??TELEGRAM_BOT_TOKEN, TELEGRAM_CHAT_ID瑜??ㅼ젙?섏꽭??")

    if trading_mode == "?쪍 Gold (?ㅼ? | Donchian, SMA)":
        render_gold_mode()
        return
    elif trading_mode == "?뱢 ISA (?쒗닾 | ?꾨?由?":
        render_kis_isa_mode()
        return
    elif trading_mode == "?눣?눡 TQ?꾨?由?(?쒗닾 | WDR)":
        render_kis_overseas_wdr_mode()
        return
    elif trading_mode == "?뮥 ?곌툑?異?(?쒗닾 | ??쇰え硫섑?)":
        render_kis_pension_mode()
        return

    # === 肄붿씤 紐⑤뱶 (湲곗〈 肄붾뱶) ===
    st.title("?첌 ?낅퉬???먮룞留ㅻℓ ?쒖뒪??)

    # Sticky Header (JS濡?Streamlit DOM 吏곸젒 議곗옉)
    import streamlit.components.v1 as components
    components.html("""
    <script>
        const doc = window.parent.document;
        if (!doc.getElementById('sticky-title-style')) {
            const style = doc.createElement('style');
            style.id = 'sticky-title-style';
            style.textContent = `
                section[data-testid="stMain"] > div.block-container {
                    overflow: visible !important;
                }
                #sticky-title-wrap {
                    position: sticky;
                    top: 0;
                    background: white;
                    z-index: 999;
                    padding-bottom: 6px;
                    border-bottom: 2px solid #e6e6e6;
                }
            `;
            doc.head.appendChild(style);
        }

        function applySticky() {
            if (doc.getElementById('sticky-title-wrap')) return;
            const titles = doc.querySelectorAll('h1');
            for (const h1 of titles) {
                if (h1.textContent.includes('Upbit SMA')) {
                    const wrapper = h1.closest('[data-testid="stVerticalBlockBorderWrapper"]')
                                  || h1.parentElement?.parentElement;
                    if (wrapper) {
                        wrapper.id = 'sticky-title-wrap';
                    }
                    break;
                }
            }
        }
        applySticky();
        setTimeout(applySticky, 500);
        setTimeout(applySticky, 1500);
    </script>
    """, height=0)

    # Keep active tabs on rerun (settings changes trigger rerun in Streamlit).
    components.html("""
    <script>
        (() => {
            const doc = window.parent.document;
            const STORAGE_PREFIX = "upbit_tab_select_";

            function bindAndRestoreTabs() {
                const tablists = Array.from(doc.querySelectorAll('div[role="tablist"]'));
                tablists.forEach((tablist, idx) => {
                    const tabs = Array.from(tablist.querySelectorAll('button[role="tab"]'));
                    if (!tabs.length) return;

                    const key = `${STORAGE_PREFIX}${idx}`;
                    if (!tablist.dataset.upbitTabRestored) {
                        const saved = window.sessionStorage.getItem(key);
                        if (saved) {
                            const target = tabs.find((t) => t.innerText.trim() === saved);
                            if (target && target.getAttribute("aria-selected") !== "true") {
                                target.click();
                            }
                        }
                        tablist.dataset.upbitTabRestored = "1";
                    }

                    tabs.forEach((tab) => {
                        if (tab.dataset.upbitTabBound) return;
                        tab.dataset.upbitTabBound = "1";
                        tab.addEventListener(
                            "click",
                            () => window.sessionStorage.setItem(key, tab.innerText.trim()),
                            { passive: true }
                        );
                    });
                });
            }

            bindAndRestoreTabs();
            const obs = new MutationObserver(() => bindAndRestoreTabs());
            obs.observe(doc.body, { childList: true, subtree: true });
            setTimeout(() => obs.disconnect(), 5000);
        })();
    </script>
    """, height=0)

    # --- Sidebar: Configuration ---
    st.sidebar.header("?ㅼ젙")
    
    # API Keys (Streamlit Cloud secrets ?먮뒗 .env 吏??
    try:
        env_access = st.secrets["UPBIT_ACCESS_KEY"]
        env_secret = st.secrets["UPBIT_SECRET_KEY"]
    except Exception:
        env_access = os.getenv("UPBIT_ACCESS_KEY")
        env_secret = os.getenv("UPBIT_SECRET_KEY")
    
    if IS_CLOUD:
        # Cloud: secrets?먯꽌 ?먮룞 濡쒕뱶, ?몄쭛 遺덇?
        current_ak = env_access
        current_sk = env_secret
        st.sidebar.info("?벑 議고쉶 ?꾩슜 紐⑤뱶 (Cloud)")
    else:
        with st.sidebar.expander("API ??, expanded=False):
            ak_input = st.text_input("Access Key", value=env_access if env_access else "", type="password")
            sk_input = st.text_input("Secret Key", value=env_secret if env_secret else "", type="password")
            current_ak = ak_input if ak_input else env_access
            current_sk = sk_input if sk_input else env_secret

    # Portfolio Management
    st.sidebar.subheader("?ы듃?대━??愿由?)
    st.sidebar.caption("媛?肄붿씤??媛쒕퀎 SMA(?대룞?됯퇏) 湲곌컙???ㅼ젙?????덉뒿?덈떎.")
    
    # Load portfolio from config or default
    # Load portfolio from config or default
    # Interval Mapping for User Friendliness (Simplified)
    INTERVAL_MAP = {
        "?쇰큺": "day",
        "4?쒓컙": "minute240",
        "1?쒓컙": "minute60",
        "30遺?: "minute30",
        "15遺?: "minute15",
        "5遺?: "minute5",
        "1遺?: "minute1"
    }
    INTERVAL_REV_MAP = {v: k for k, v in INTERVAL_MAP.items()}
    CANDLES_PER_DAY = {
        "day": 1, "minute240": 6, "minute60": 24,
        "minute30": 48, "minute15": 96, "minute5": 288, "minute1": 1440
    }
    
    # Load portfolio: user_config.json ??portfolio.json (湲곕낯媛??놁쓬, ?놁쑝硫??ㅻ쪟)
    PORTFOLIO_JSON_LOAD = os.path.join(os.path.dirname(os.path.abspath(__file__)), "portfolio.json")
    # portfolio.json?먯꽌 ?ㅼ젙媛믩룄 濡쒕뱶 (object ?뺥깭 吏??
    _pjson_config = {}
    if os.path.exists(PORTFOLIO_JSON_LOAD):
        try:
            with open(PORTFOLIO_JSON_LOAD, "r", encoding="utf-8") as f:
                _pjson_raw = json.load(f)
            if isinstance(_pjson_raw, dict):
                _pjson_config = _pjson_raw
            elif isinstance(_pjson_raw, list):
                _pjson_config = {"portfolio": _pjson_raw}
        except Exception:
            pass

    default_portfolio = config.get("portfolio", None)
    if not default_portfolio:
        default_portfolio = _pjson_config.get("portfolio", None)
    if not default_portfolio:
        st.error("portfolio.json ?뚯씪???녾굅???ы듃?대━???곗씠?곌? 鍮꾩뼱?덉뒿?덈떎. 濡쒖뺄?먯꽌 ?????push ?댁＜?몄슂.")
        st.stop()
    
    # Convert to DataFrame for Editor (Use Labels)
    sanitized_portfolio = []
    _row_aux_default_base = {
        "ma_short": 5, "ma_long": 20, "threshold": -5.0,
        "tp1_pct": 3.0, "tp2_pct": 10.0, "split_count": 3,
        "buy_seed_mode": "equal", "pyramid_ratio": 1.30,
    }
    _initial_aux_cfg_seed = {}
    def_len = len(default_portfolio)
    for p in default_portfolio:
        api_interval = p.get("interval", "day")
        label_interval = INTERVAL_REV_MAP.get(api_interval, "?쇰큺")
        
        # Migrate old 'sma' key to 'parameter' if needed
        param_val = p.get("parameter", p.get("sma", 20))
        
        # Migration: Map old long names to short names
        strat_map = {"SMA ?꾨왂": "SMA", "SMA Strategy": "SMA", "?덊궎???꾨왂": "Donchian", "Donchian Trend": "Donchian"}
        strat_val = p.get("strategy", "SMA")
        strat_val = strat_map.get(strat_val, strat_val)

        sell_param_val = p.get("sell_parameter", 0)
        _prk = f"{str(p.get('coin', 'BTC')).upper()}|{strat_val}|{int(param_val or 0)}|{int(sell_param_val or 0)}|{label_interval}"
        _initial_aux_cfg_seed[_prk] = {
            "ma_short": int(p.get("aux_ma_short", _row_aux_default_base["ma_short"])),
            "ma_long": int(p.get("aux_ma_long", _row_aux_default_base["ma_long"])),
            "threshold": float(p.get("aux_threshold", _row_aux_default_base["threshold"])),
            "tp1_pct": float(p.get("aux_tp1_pct", _row_aux_default_base["tp1_pct"])),
            "tp2_pct": float(p.get("aux_tp2_pct", _row_aux_default_base["tp2_pct"])),
            "split_count": int(p.get("aux_split_count", _row_aux_default_base["split_count"])),
            "buy_seed_mode": str(p.get("aux_seed_mode", _row_aux_default_base["buy_seed_mode"])).lower(),
            "pyramid_ratio": float(p.get("aux_pyramid_ratio", _row_aux_default_base["pyramid_ratio"])),
        }

        sanitized_portfolio.append({
            "coin": str(p.get("coin", "BTC")).upper(),
            "strategy": strat_val,
            "aux_enabled": bool(p.get("aux_enabled", False)),
            "parameter": param_val,
            "sell_parameter": sell_param_val,
            "weight": p.get("weight", 100 // def_len if def_len > 0 else 100),
            "interval": label_interval
        })
        
    df_portfolio = pd.DataFrame(sanitized_portfolio)
    _portfolio_cols = ["aux_enabled", "coin", "strategy", "parameter", "sell_parameter", "weight", "interval"]
    df_portfolio = df_portfolio[[c for c in _portfolio_cols if c in df_portfolio.columns]]
    
    interval_options = list(INTERVAL_MAP.keys())
    strategy_options = ["SMA", "Donchian"]

    if IS_CLOUD:
        # Cloud: ?쎄린 ?꾩슜 ?뚯씠釉?
        st.sidebar.dataframe(df_portfolio, use_container_width=True, hide_index=True)
        edited_portfolio = df_portfolio
    else:
        edited_portfolio = st.sidebar.data_editor(df_portfolio, num_rows="dynamic", use_container_width=True, hide_index=True,
                                                  column_config={
                                                      "aux_enabled": st.column_config.CheckboxColumn("??, help="泥댄겕?섎㈃ ?꾨옒?먯꽌 蹂댁“ ?꾨왂 ?명똿"),
                                                      "coin": st.column_config.TextColumn("肄붿씤", required=True),
                                                      "strategy": st.column_config.SelectboxColumn("?꾨왂", options=strategy_options, required=True, default="SMA"),
                                                      "parameter": st.column_config.NumberColumn("留ㅼ닔", min_value=5, max_value=300, step=1, required=True),
                                                      "sell_parameter": st.column_config.NumberColumn("留ㅻ룄", min_value=0, max_value=300, step=1, required=False, default=0, help="?덉튂??留ㅻ룄 梨꾨꼸 (0=留ㅼ닔???덈컲)"),
                                                      "weight": st.column_config.NumberColumn("鍮꾩쨷", min_value=0, max_value=100, step=1, required=True, format="%d%%"),
                                                      "interval": st.column_config.SelectboxColumn("?쒓컙遊?, options=interval_options, required=True, default="?쇰큺")
                                                  })

    # ?ы듃?대━???뚯씠釉?諛붾줈 ?꾨옒: 媛쒕퀎 蹂댁“ ?꾨왂 ?명똿(硫붿씤 ?꾨왂 ?섏쐞 ?ㅼ젙)
    _row_aux_default = dict(_row_aux_default_base)
    if "portfolio_aux_cfg" not in st.session_state:
        st.session_state["portfolio_aux_cfg"] = {}
    _aux_cfg_store = st.session_state["portfolio_aux_cfg"]
    for _k_seed, _v_seed in _initial_aux_cfg_seed.items():
        if _k_seed not in _aux_cfg_store:
            _aux_cfg_store[_k_seed] = _v_seed

    def _port_row_key(_r):
        return f"{str(_r.get('coin','')).upper()}|{_r.get('strategy','')}|{int(_r.get('parameter', 0) or 0)}|{int(_r.get('sell_parameter', 0) or 0)}|{_r.get('interval','')}"

    _aux_rows = [r for r in edited_portfolio.to_dict("records") if bool(r.get("aux_enabled", False))]
    if _aux_rows:
        st.sidebar.caption("蹂댁“ ?꾨왂 ?명똿 (硫붿씤 ?꾨왂 ?섏쐞)")
        for _i, _r in enumerate(_aux_rows):
            _rk = _port_row_key(_r)
            _seed = _aux_cfg_store.get(_rk, {})
            _cfg = {**_row_aux_default, **_seed}
            _tag = f"{str(_r.get('coin','')).upper()} | {_r.get('strategy','SMA')} {_r.get('parameter', 0)} | {_r.get('interval','?쇰큺')}"
            with st.sidebar.expander(f"蹂댁“ ?ㅼ젙: {_tag}", expanded=False):
                _c1, _c2 = st.columns(2)
                _ms = int(_c1.number_input("?④린 MA", 2, 100, int(_cfg["ma_short"]), 1, key=f"row_aux_ms_{_i}"))
                _ml = int(_c2.number_input("以묎린 MA", 5, 300, int(_cfg["ma_long"]), 1, key=f"row_aux_ml_{_i}"))
                if _ml <= _ms:
                    _ml = _ms + 1
                _thr = float(st.slider("怨쇰ℓ???꾧퀎媛?%)", -30.0, -0.5, float(_cfg["threshold"]), 0.5, key=f"row_aux_thr_{_i}"))
                _c3, _c4 = st.columns(2)
                _tp1 = float(_c3.number_input("TP1(%)", 1.0, 30.0, float(_cfg["tp1_pct"]), 0.5, key=f"row_aux_tp1_{_i}"))
                _tp2 = float(_c4.number_input("TP2(%)", 1.0, 50.0, float(_cfg["tp2_pct"]), 0.5, key=f"row_aux_tp2_{_i}"))
                _split = int(st.number_input("遺꾪븷 ?잛닔", 1, 20, int(_cfg["split_count"]), 1, key=f"row_aux_split_{_i}"))
                _seed_lbl = st.radio(
                    "?쒕뱶 諛⑹떇", ["洹좊벑", "?쇰씪誘몃뵫"],
                    index=1 if str(_cfg.get("buy_seed_mode", "equal")).lower() == "pyramiding" else 0,
                    horizontal=True, key=f"row_aux_seed_{_i}"
                )
                _seed_mode = "pyramiding" if _seed_lbl == "?쇰씪誘몃뵫" else "equal"
                _pr = float(_cfg["pyramid_ratio"])
                if _seed_mode == "pyramiding":
                    _pr = float(st.number_input("?쇰씪誘몃뵫 諛곗쑉", 1.05, 3.00, float(_cfg["pyramid_ratio"]), 0.05, key=f"row_aux_pr_{_i}"))

                _aux_cfg_store[_rk] = {
                    "ma_short": _ms, "ma_long": _ml, "threshold": _thr,
                    "tp1_pct": _tp1, "tp2_pct": _tp2, "split_count": _split,
                    "buy_seed_mode": _seed_mode, "pyramid_ratio": _pr,
                }
        st.session_state["portfolio_aux_cfg"] = _aux_cfg_store
    else:
        st.sidebar.caption("?쇱そ `??瑜?泥댄겕?섎㈃ 蹂댁“ ?꾨왂 ?명똿???ш린???쒖떆?⑸땲??")
    
    # Calculate Total Weight & Cash
    total_weight = edited_portfolio["weight"].sum()
    if total_weight > 100:
        st.sidebar.error(f"珥?鍮꾩쨷??{total_weight}% ?낅땲?? (100% ?댄븯濡??ㅼ젙?댁＜?몄슂)")
    else:
        cash_weight = 100 - total_weight
        st.sidebar.info(f"?ъ옄 鍮꾩쨷: {total_weight}% | ?꾧툑: {cash_weight}%")
    
    # Convert back to list of dicts (Map Labels back to API Keys)
    portfolio_list = []
    for r in edited_portfolio.to_dict('records'):
        label_key = r['interval']
        api_key = INTERVAL_MAP.get(label_key, "day") # Default to day if not found
        _rk = _port_row_key(r)
        _aux_cfg = st.session_state.get("portfolio_aux_cfg", {}).get(_rk, _row_aux_default)
        
        sell_p = int(r.get('sell_parameter', 0) or 0)
        portfolio_list.append({
            "market": "KRW",
            "coin": r['coin'].upper(),
            "strategy": r['strategy'],
            "parameter": r['parameter'],
            "sell_parameter": sell_p,
            "aux_enabled": bool(r.get('aux_enabled', False)),
            # ?쇱씠釉??ы듃?대━?ㅼ뿉?쒕뒗 蹂댁“ ?꾨왂??硫붿씤 ?꾨왂 ?명똿(?쒓컙遊??ы븿)??洹몃?濡??ъ슜
            "aux_interval": api_key,
            "aux_main_interval": api_key,
            "aux_ma_short": int(_aux_cfg.get("ma_short", _row_aux_default["ma_short"])),
            "aux_ma_long": int(_aux_cfg.get("ma_long", _row_aux_default["ma_long"])),
            "aux_threshold": float(_aux_cfg.get("threshold", _row_aux_default["threshold"])),
            "aux_tp1_pct": float(_aux_cfg.get("tp1_pct", _row_aux_default["tp1_pct"])),
            "aux_tp2_pct": float(_aux_cfg.get("tp2_pct", _row_aux_default["tp2_pct"])),
            "aux_split_count": int(_aux_cfg.get("split_count", _row_aux_default["split_count"])),
            "aux_seed_mode": str(_aux_cfg.get("buy_seed_mode", _row_aux_default["buy_seed_mode"])),
            "aux_pyramid_ratio": float(_aux_cfg.get("pyramid_ratio", _row_aux_default["pyramid_ratio"])),
            "weight": r['weight'],
            "interval": api_key
        })
    
    # Global Settings
    st.sidebar.subheader("怨듯넻 ?ㅼ젙")
    # Interval Removed (Per-Coin Setting)
    
    default_start_str = config.get("start_date", None) or _pjson_config.get("start_date", None)
    if not default_start_str:
        st.error("start_date ?ㅼ젙???놁뒿?덈떎. 濡쒖뺄?먯꽌 portfolio.json??start_date瑜??ㅼ젙 ??push ?댁＜?몄슂.")
        st.stop()
    try:
        default_start = pd.to_datetime(default_start_str).date()
    except:
        st.error(f"start_date ?뺤떇 ?ㅻ쪟: {default_start_str}")
        st.stop()
    start_date = st.sidebar.date_input(
        "湲곗? ?쒖옉??,
        value=default_start,
        help="?섏씡瑜?怨꾩궛 諛??대줎???먯궛 鍮꾧탳瑜??꾪븳 湲곗??쇱엯?덈떎. ?ㅼ젣 留ㅻℓ ?좏샇???臾닿??⑸땲??",
        disabled=IS_CLOUD
    )

    # Capital Input Customization
    default_cap = config.get("initial_cap", None) or _pjson_config.get("initial_cap", None)
    if not default_cap:
        st.error("initial_cap ?ㅼ젙???놁뒿?덈떎. 濡쒖뺄?먯꽌 portfolio.json??initial_cap???ㅼ젙 ??push ?댁＜?몄슂.")
        st.stop()
    initial_cap = st.sidebar.number_input(
        "珥덇린 ?먮낯湲?(KRW - ???⑥쐞)",
        value=default_cap, step=100000, format="%d",
        help="?쒕??덉씠?섏쓣 ?꾪븳 珥덇린 ?ъ옄湲??ㅼ젙?낅땲?? ?ㅼ젣 怨꾩쥖 ?붽퀬???臾닿??섎ŉ, ?섏씡瑜?怨꾩궛??湲곗????⑸땲??",
        disabled=IS_CLOUD
    )
    st.sidebar.caption(f"?ㅼ젙: **{initial_cap:,.0f} KRW**")

    _live_aux_default = {
        "ma_short": 5,
        "ma_long": 20,
        "threshold": -5.0,
        "tp1_pct": 3.0,
        "tp2_pct": 10.0,
        "split_count": 3,
        "buy_seed_mode": "equal",
        "pyramid_ratio": 1.30,
    }
    _cfg_live_aux = config.get("live_aux_defaults", None) or _pjson_config.get("live_aux_defaults", None) or {}
    if not isinstance(_cfg_live_aux, dict):
        _cfg_live_aux = {}
    live_aux_defaults = {**_live_aux_default, **_cfg_live_aux}

    with st.sidebar.expander("蹂댁“ ?꾨왂(?쇱씠釉??ы듃?대━?? 湲곕낯 ?ㅼ젙", expanded=False):
        la1, la2 = st.columns(2)
        live_aux_defaults["ma_short"] = int(la1.number_input("?④린 MA", 2, 100, int(live_aux_defaults["ma_short"]), 1))
        live_aux_defaults["ma_long"] = int(la2.number_input("以묎린 MA", 5, 300, int(live_aux_defaults["ma_long"]), 1))
        if live_aux_defaults["ma_long"] <= live_aux_defaults["ma_short"]:
            live_aux_defaults["ma_long"] = live_aux_defaults["ma_short"] + 1
            st.caption("以묎린 MA???④린 MA蹂대떎 ?ш쾶 ?먮룞 蹂댁젙?⑸땲??")
        live_aux_defaults["threshold"] = float(st.slider("怨쇰ℓ???꾧퀎媛?%)", -30.0, -0.5, float(live_aux_defaults["threshold"]), 0.5))
        la3, la4 = st.columns(2)
        live_aux_defaults["tp1_pct"] = float(la3.number_input("TP1(%)", 1.0, 30.0, float(live_aux_defaults["tp1_pct"]), 0.5))
        live_aux_defaults["tp2_pct"] = float(la4.number_input("TP2(%)", 1.0, 50.0, float(live_aux_defaults["tp2_pct"]), 0.5))
        live_aux_defaults["split_count"] = int(st.number_input("遺꾪븷 ?잛닔", 1, 20, int(live_aux_defaults["split_count"]), 1))
        _live_seed_label = st.radio(
            "?쒕뱶 諛⑹떇",
            ["洹좊벑", "?쇰씪誘몃뵫"],
            index=1 if str(live_aux_defaults.get("buy_seed_mode", "equal")).lower() == "pyramiding" else 0,
            horizontal=True,
        )
        live_aux_defaults["buy_seed_mode"] = "pyramiding" if _live_seed_label == "?쇰씪誘몃뵫" else "equal"
        if live_aux_defaults["buy_seed_mode"] == "pyramiding":
            live_aux_defaults["pyramid_ratio"] = float(
                st.number_input("?쇰씪誘몃뵫 諛곗쑉", 1.05, 3.00, float(live_aux_defaults["pyramid_ratio"]), 0.05)
            )
        st.caption("?ы듃?대━???쒖뿉??`蹂댁“異붽?`瑜?耳??먯궛?먮쭔 ?곸슜?⑸땲?? (硫붿씤 ?꾨왂 ?명똿 洹몃?濡??ъ슜)")
    
    # Strategy Selection REMOVED (Moved to Per-Coin)

    PORTFOLIO_JSON = os.path.join(os.path.dirname(os.path.abspath(__file__)), "portfolio.json")

    if not IS_CLOUD:
        save_col1, save_col2 = st.sidebar.columns(2)

        if save_col1.button("?뮶 ???):
            new_config = {
                "portfolio": portfolio_list,
                "start_date": str(start_date),
                "initial_cap": initial_cap,
                "live_aux_defaults": live_aux_defaults,
            }
            save_config(new_config)
            portfolio_json_data = {
                "portfolio": portfolio_list,
                "start_date": str(start_date),
                "initial_cap": initial_cap,
                "live_aux_defaults": live_aux_defaults,
            }
            with open(PORTFOLIO_JSON, "w", encoding="utf-8") as f:
                json.dump(portfolio_json_data, f, indent=2, ensure_ascii=False)
            st.sidebar.success("????꾨즺!")

        if save_col2.button("?뱛 遺덈윭?ㅺ린"):
            if os.path.exists(PORTFOLIO_JSON):
                try:
                    with open(PORTFOLIO_JSON, "r", encoding="utf-8") as f:
                        imported = json.load(f)
                    if isinstance(imported, list) and len(imported) > 0:
                        new_config = {
                            "portfolio": imported,
                            "start_date": str(start_date),
                            "initial_cap": initial_cap,
                            "live_aux_defaults": live_aux_defaults,
                        }
                        save_config(new_config)
                        st.sidebar.success(f"{len(imported)}媛??먯궛 遺덈윭?ㅺ린 ?꾨즺!")
                        st.rerun()
                    elif isinstance(imported, dict) and isinstance(imported.get("portfolio"), list):
                        new_config = {
                            "portfolio": imported.get("portfolio", []),
                            "start_date": str(imported.get("start_date", start_date)),
                            "initial_cap": imported.get("initial_cap", initial_cap),
                            "live_aux_defaults": imported.get("live_aux_defaults", live_aux_defaults),
                        }
                        save_config(new_config)
                        st.sidebar.success(f"{len(new_config['portfolio'])}媛??먯궛 遺덈윭?ㅺ린 ?꾨즺!")
                        st.rerun()
                    else:
                        st.sidebar.error("?щ컮瑜??ы듃?대━??JSON ?뺤떇???꾨떃?덈떎.")
                except json.JSONDecodeError:
                    st.sidebar.error("JSON ?뚯떛 ?ㅻ쪟. ?뚯씪???뺤씤?댁＜?몄슂.")
            else:
                st.sidebar.warning("portfolio.json ?뚯씪???놁뒿?덈떎.")

    # --- data_manager Import ---
    from data_manager import MarketDataWorker

    # ... (Keep existing history cache if useful, or move to worker too. Let's keep separate for now)
    @st.cache_data(ttl=60)
    # Function to fetch history (Caching disabled for now due to obj hashing)
    def fetch_history_cached(_trader, kind, currency="KRW"):
         try:
            return _trader.get_history(kind, currency)
         except TypeError:
            # Fallback if get_history signature issues
            return _trader.get_history(kind)
    
    # Initialize Objects
    backtest_engine = BacktestEngine()

    @st.cache_data(ttl=300)
    def _cached_backtest(ticker, period, interval, count, start_date_str, initial_balance, strategy_mode, sell_period_ratio, _df_hash):
        """諛깊뀒?ㅽ듃 寃곌낵瑜?5遺꾧컙 罹먯떛 (?숈씪 ?뚮씪誘명꽣 ?ш퀎??諛⑹?)"""
        df_bt_local = data_cache.load_cached(ticker, interval)
        if df_bt_local is None or len(df_bt_local) < period:
            return None
        return backtest_engine.run_backtest(
            ticker, period=period, interval=interval, count=count,
            start_date=start_date_str, initial_balance=initial_balance,
            df=df_bt_local, strategy_mode=strategy_mode,
            sell_period_ratio=sell_period_ratio
        )
    
    trader = None
    if current_ak and current_sk:
        @st.cache_resource
        def get_trader(ak, sk):
            return UpbitTrader(ak, sk)
        trader = get_trader(current_ak, current_sk)

    # --- Background Worker Setup ---
    from data_manager import MarketDataWorker, CoinTradingWorker

    @st.cache_resource
    def get_worker():
        return MarketDataWorker()

    @st.cache_resource
    def get_coin_trading_worker():
        w = CoinTradingWorker()
        w.start()
        return w

    worker = get_worker()
    coin_tw = get_coin_trading_worker()

    # ?낅퉬??KRW 留덉폆 ?멸? ?⑥쐞 (Tick Size)
    def get_tick_size(price):
        """媛寃⑹뿉 ?곕Ⅸ ?낅퉬???멸? ?⑥쐞 諛섑솚"""
        if price >= 2_000_000: return 1000
        elif price >= 1_000_000: return 1000
        elif price >= 500_000: return 500
        elif price >= 100_000: return 100
        elif price >= 50_000: return 50
        elif price >= 10_000: return 10
        elif price >= 5_000: return 5
        elif price >= 1_000: return 1
        elif price >= 100: return 1
        elif price >= 10: return 0.1
        elif price >= 1: return 0.01
        else: return 0.001

    def align_price(price, tick_size):
        """媛寃⑹쓣 ?멸? ?⑥쐞??留욊쾶 ?뺣젹"""
        if tick_size >= 1:
            return int(price // tick_size * tick_size)
        else:
            import math
            decimals = max(0, -int(math.floor(math.log10(tick_size))))
            return round(price // tick_size * tick_size, decimals)

    # ?? TTL 罹먯떆: API ?몄텧 理쒖냼????
    def _ttl_cache(key, fn, ttl=5):
        """?몄뀡 湲곕컲 TTL 罹먯떆. ttl珥??대궡 ?ы샇異쒖떆 罹먯떆 諛섑솚."""
        now = time.time()
        ck, tk = f"__c_{key}", f"__t_{key}"
        if ck in st.session_state and (now - st.session_state.get(tk, 0)) < ttl:
            return st.session_state[ck]
        val = fn()
        st.session_state[ck] = val
        st.session_state[tk] = now
        return val

    def _clear_cache(*keys):
        """嫄곕옒 ??罹먯떆 臾댄슚??""
        for k in keys:
            st.session_state.pop(f"__c_{k}", None)
            st.session_state.pop(f"__t_{k}", None)

    # ?쒓?珥앹븸 ?곸쐞 20 ?곗빱 (湲濡쒕쾶 Market Cap 湲곗?)
    TOP_20_TICKERS = [
        "KRW-BTC", "KRW-ETH", "KRW-XRP", "KRW-SOL", "KRW-DOGE",
        "KRW-ADA", "KRW-SHIB", "KRW-TRX", "KRW-AVAX", "KRW-LINK",
        "KRW-BCH", "KRW-DOT", "KRW-NEAR", "KRW-POL", "KRW-ETC",
        "KRW-XLM", "KRW-STX", "KRW-HBAR", "KRW-EOS", "KRW-SAND"
    ]

    # --- Tabs ---
    tab1, tab5, tab3, tab4 = st.tabs(["?? ?ㅼ떆媛??ы듃?대━??, "?썟 ?섎룞 二쇰Ц", "?뱶 嫄곕옒 ?댁뿭", "?뱤 諛깊뀒?ㅽ듃"])

    # --- Tab 1: Live Portfolio (Default) ---
    with tab1:
        st.header("?ㅼ떆媛??ы듃?대━????쒕낫??)
        st.caption("?ㅼ젙??紐⑤뱺 ?먯궛??紐⑤땲?곕쭅?⑸땲??")
        
        if not trader:
            st.warning("?ъ씠?쒕컮?먯꽌 API ?ㅻ? ?ㅼ젙?댁＜?몄슂.")
        else:
            # Configure and Start Worker
            worker.update_config(portfolio_list)
            worker.start_worker()

            w_msg, w_time = worker.get_status()

            # Control Bar
            col_ctrl1, col_ctrl2 = st.columns([1,3])
            with col_ctrl1:
                if st.button("?봽 ?덈줈怨좎묠"):
                    _clear_cache("krw_bal_t1", "prices_t1", "balances_t1")
                    st.rerun()
            with col_ctrl2:
                st.info(f"?뚯빱 ?곹깭: **{w_msg}**")

            if not portfolio_list:
                st.warning("?ъ씠?쒕컮?먯꽌 ?ы듃?대━?ㅼ뿉 肄붿씤??異붽??댁＜?몄슂.")
            else:
                count = len(portfolio_list)
                per_coin_cap = initial_cap / count

                # ?? ?쇨큵 API ?몄텧 (TTL 罹먯떆): 媛寃㈑룹옍怨좊? 1?뚯뵫留?媛?몄샂 ??
                unique_coins = list(dict.fromkeys(item['coin'].upper() for item in portfolio_list))
                unique_tickers = list(dict.fromkeys(f"{item['market']}-{item['coin'].upper()}" for item in portfolio_list))

                krw_bal = _ttl_cache("krw_bal_t1", lambda: trader.get_balance("KRW") or 0, ttl=10)

                def _fetch_all_prices():
                    """紐⑤뱺 肄붿씤 媛寃⑹쓣 ?쒕쾲??媛?몄샂"""
                    try:
                        result = pyupbit.get_current_price(unique_tickers)
                        if isinstance(result, dict):
                            return result
                        elif isinstance(result, (int, float)) and len(unique_tickers) == 1:
                            return {unique_tickers[0]: result}
                    except:
                        pass
                    return {t: (pyupbit.get_current_price(t) or 0) for t in unique_tickers}

                all_prices = _ttl_cache("prices_t1", _fetch_all_prices, ttl=5)

                def _fetch_all_balances():
                    """紐⑤뱺 肄붿씤 ?붽퀬瑜?1??API ?몄텧濡?媛?몄샂"""
                    if hasattr(trader, 'get_all_balances'):
                        raw = trader.get_all_balances()
                        return {c: raw.get(c, 0) for c in unique_coins}
                    # ?대갚: 媛쒕퀎 ?몄텧
                    return {c: (trader.get_balance(c) or 0) for c in unique_coins}

                all_balances = _ttl_cache("balances_t1", _fetch_all_balances, ttl=10)

                # --- Total Summary Container ---
                st.subheader("?뢾 ?ы듃?대━???붿빟")
                st.caption(f"珥덇린?먮낯: {initial_cap:,.0f} KRW | ?먯궛?? {count} | ?먯궛?? {per_coin_cap:,.0f} KRW")

                sum_col1, sum_col2, sum_col3, sum_col4 = st.columns(4)

                total_real_val = krw_bal
                total_init_val = initial_cap

                # Cash Logic
                total_weight_alloc = sum([item.get('weight', 0) for item in portfolio_list])
                cash_ratio = max(0, 100 - total_weight_alloc) / 100.0
                reserved_cash = initial_cap * cash_ratio

                # Add reserved cash to Theo Value (as it stays as cash)
                total_theo_val = reserved_cash

                # --- ?꾩껜 ?먯궛 ?꾪솴 ?뚯씠釉?(罹먯떆???곗씠???ъ슜) ---
                asset_summary_rows = [{"?먯궛": "KRW (?꾧툑)", "蹂댁쑀??: f"{krw_bal:,.0f}", "?꾩옱媛": "-", "?됯?湲덉븸(KRW)": f"{krw_bal:,.0f}", "?곹깭": "-"}]
                seen_coins_summary = set()
                for s_item in portfolio_list:
                    s_coin = s_item['coin'].upper()
                    if s_coin in seen_coins_summary:
                        continue
                    seen_coins_summary.add(s_coin)
                    s_ticker = f"{s_item['market']}-{s_coin}"
                    s_bal = all_balances.get(s_coin, 0)
                    s_price = all_prices.get(s_ticker, 0) or 0
                    s_val = s_bal * s_price
                    is_holding = s_val >= 5000
                    asset_summary_rows.append({
                        "?먯궛": s_coin,
                        "蹂댁쑀??: (f"{s_bal:.8f}" if s_bal < 1 else f"{s_bal:,.4f}") if s_bal > 0 else "0",
                        "?꾩옱媛": f"{s_price:,.0f}",
                        "?됯?湲덉븸(KRW)": f"{s_val:,.0f}",
                        "?곹깭": "蹂댁쑀以? if is_holding else "誘몃낫??,
                    })
                total_real_summary = krw_bal + sum(
                    all_balances.get(c, 0) * (all_prices.get(f"KRW-{c}", 0) or 0)
                    for c in seen_coins_summary
                )
                asset_summary_rows.append({
                    "?먯궛": "?⑷퀎",
                    "蹂댁쑀??: "",
                    "?꾩옱媛": "",
                    "?됯?湲덉븸(KRW)": f"{total_real_summary:,.0f}",
                    "?곹깭": "",
                })
                with st.expander(f"?뮥 ?꾩껜 ?먯궛 ?꾪솴 (Total: {total_real_summary:,.0f} KRW)", expanded=True):
                    st.dataframe(pd.DataFrame(asset_summary_rows), use_container_width=True, hide_index=True)

                    # ?? ?ы듃?대━??由щ갭?곗떛 (?먯궛?꾪솴 ???듯빀) ??
                    st.divider()
                    st.markdown("**?뽳툘 ?ы듃?대━??由щ갭?곗떛**")
                    krw_balance = krw_bal

                    asset_states = []
                    for rb_idx, rb_item in enumerate(portfolio_list):
                        rb_ticker = f"{rb_item['market']}-{rb_item['coin'].upper()}"
                        rb_coin = rb_item['coin'].upper()
                        rb_weight = rb_item.get('weight', 0)
                        rb_interval = rb_item.get('interval', 'day')
                        rb_strategy = rb_item.get('strategy', 'SMA Strategy')
                        rb_param = rb_item.get('parameter', 20)
                        rb_sell_param = rb_item.get('sell_parameter', 0)

                        rb_coin_bal = all_balances.get(rb_coin, 0)
                        rb_price = all_prices.get(rb_ticker, 0) or 0
                        rb_coin_val = rb_coin_bal * rb_price
                        rb_status = "HOLD" if rb_coin_val > 5000 else "CASH"

                        rb_signal = "N/A"
                        try:
                            rb_df = worker.get_data(rb_ticker, rb_interval)
                            if rb_df is not None and len(rb_df) >= rb_param:
                                if rb_strategy == "Donchian":
                                    rb_eng = DonchianStrategy()
                                    rb_sp = rb_sell_param or max(5, rb_param // 2)
                                    rb_df = rb_eng.create_features(rb_df, buy_period=rb_param, sell_period=rb_sp)
                                    rb_signal = rb_eng.get_signal(rb_df.iloc[-2], buy_period=rb_param, sell_period=rb_sp)
                                else:
                                    rb_eng = SMAStrategy()
                                    rb_df = rb_eng.create_features(rb_df, periods=[rb_param])
                                    rb_signal = rb_eng.get_signal(rb_df.iloc[-2], strategy_type='SMA_CROSS', ma_period=rb_param)
                        except Exception:
                            pass

                        rb_target_krw = total_real_summary * (rb_weight / 100.0)

                        asset_states.append({
                            "ticker": rb_ticker, "coin": rb_coin, "weight": rb_weight,
                            "interval": rb_interval, "strategy": rb_strategy,
                            "param": rb_param, "sell_param": rb_sell_param,
                            "status": rb_status, "signal": rb_signal,
                            "coin_bal": rb_coin_bal, "coin_val": rb_coin_val,
                            "price": rb_price, "target_krw": rb_target_krw,
                        })

                    cash_assets = [a for a in asset_states if a['status'] == 'CASH']
                    hold_assets = [a for a in asset_states if a['status'] == 'HOLD']
                    buy_signal_assets = [a for a in asset_states if a['signal'] == 'BUY']

                    rc1, rc2, rc3 = st.columns(3)
                    rc1.metric("蹂댁쑀 ?꾧툑 (KRW)", f"{krw_balance:,.0f}")
                    rc2.metric("CASH ?먯궛", f"{len(cash_assets)} / {len(asset_states)}")
                    rc3.metric("BUY ?쒓렇??, f"{len(buy_signal_assets)} / {len(asset_states)}")

                    rebal_data = []
                    for a in asset_states:
                        action = ""
                        if a['status'] == 'CASH' and a['signal'] == 'BUY':
                            action = "BUY"
                        elif a['status'] == 'CASH' and a['signal'] != 'BUY':
                            action = "?湲?(?쒓렇???놁쓬)"
                        elif a['status'] == 'HOLD':
                            action = "蹂댁쑀 以?
                        rebal_data.append({
                            "醫낅ぉ": a['ticker'],
                            "?꾨왂": f"{a['strategy']} {a['param']}",
                            "鍮꾩쨷": f"{a['weight']}%",
                            "?쒓컙遊?: a['interval'],
                            "?곹깭": a['status'],
                            "?쒓렇??: a['signal'],
                            "?꾩옱媛移?KRW)": f"{a['coin_val']:,.0f}",
                            "紐⑺몴(KRW)": f"{a['target_krw']:,.0f}",
                            "?≪뀡": action,
                        })
                    st.dataframe(pd.DataFrame(rebal_data), use_container_width=True, hide_index=True)

                    buyable = [a for a in asset_states if a['status'] == 'CASH' and a['signal'] == 'BUY']
                    if not buyable:
                        if len(cash_assets) == 0:
                            st.success("紐⑤뱺 ?먯궛???대? 蹂댁쑀 以묒엯?덈떎.")
                        else:
                            st.info(f"?꾧툑 ?먯궛 {len(cash_assets)}媛쒓? ?덉?留?BUY ?쒓렇?먯씠 ?놁뒿?덈떎. ?쒓렇??諛쒖깮 ??留ㅼ닔 媛?ν빀?덈떎.")
                    else:
                        st.warning(f"**{len(buyable)}媛??먯궛**??BUY ?쒓렇?먯씠 ?덉뒿?덈떎. 由щ갭?곗떛 留ㅼ닔瑜??ㅽ뻾?????덉뒿?덈떎.")
                        total_buy_weight = sum(a['weight'] for a in buyable)
                        available_krw = krw_balance * 0.999

                        buy_plan = []
                        for a in buyable:
                            alloc_krw = available_krw * (a['weight'] / total_buy_weight) if total_buy_weight > 0 else 0
                            alloc_krw = min(alloc_krw, available_krw)
                            buy_plan.append({
                                "醫낅ぉ": a['ticker'], "鍮꾩쨷": f"{a['weight']}%",
                                "諛곕텇 湲덉븸(KRW)": f"{alloc_krw:,.0f}",
                                "?쒓컙遊?: a['interval'], "?꾩옱媛": f"{a['price']:,.0f}",
                                "_ticker": a['ticker'], "_krw": alloc_krw, "_interval": a['interval'],
                            })
                        plan_df = pd.DataFrame(buy_plan)
                        st.dataframe(plan_df[["醫낅ぉ", "鍮꾩쨷", "諛곕텇 湲덉븸(KRW)", "?쒓컙遊?, "?꾩옱媛"]], use_container_width=True, hide_index=True)
                        st.caption(f"珥?諛곕텇 湲덉븸: {sum(p['_krw'] for p in buy_plan):,.0f} KRW / 蹂댁쑀 ?꾧툑: {krw_balance:,.0f} KRW")

                        if st.button("?? 由щ갭?곗떛 留ㅼ닔 ?ㅽ뻾", key="btn_rebalance_exec", type="primary"):
                            rebal_results = []
                            rebal_progress = st.progress(0)
                            rebal_log = st.empty()
                            for pi, plan in enumerate(buy_plan):
                                p_ticker = plan['_ticker']
                                p_krw = plan['_krw']
                                p_interval = plan['_interval']
                                if p_krw < 5000:
                                    rebal_results.append({"醫낅ぉ": p_ticker, "寃곌낵": "湲덉븸 遺議?(5,000??誘몃쭔)"})
                                    continue
                                rebal_log.text(f"留ㅼ닔 以? {p_ticker} ({p_krw:,.0f} KRW)...")
                                try:
                                    exec_res = trader.smart_buy(p_ticker, p_krw, interval=p_interval)
                                    avg_p = exec_res.get('avg_price', 0)
                                    vol = exec_res.get('filled_volume', 0)
                                    rebal_results.append({
                                        "醫낅ぉ": p_ticker,
                                        "寃곌낵": f"泥닿껐 ?꾨즺: {vol:.6f} @ {avg_p:,.0f}",
                                        "湲덉븸": f"{exec_res.get('total_krw', 0):,.0f} KRW"
                                    })
                                except Exception as e:
                                    rebal_results.append({"醫낅ぉ": p_ticker, "寃곌낵": f"?ㅻ쪟: {e}"})
                                rebal_progress.progress((pi + 1) / len(buy_plan))
                                time.sleep(0.5)
                            rebal_progress.progress(1.0)
                            rebal_log.empty()
                            st.success("由щ갭?곗떛 ?꾨즺!")
                            st.dataframe(pd.DataFrame(rebal_results), use_container_width=True, hide_index=True)

                # --- ?④린 紐⑤땲?곕쭅 李⑦듃 (60遊? ---
                with st.expander("?뱤 ?④린 ?쒓렇??紐⑤땲?곕쭅 (60遊?", expanded=True):
                    signal_rows = []

                    # BTC / 鍮껧TC 遺꾨━ (BTC: ?쇰큺???쒓컙遊???
                    interval_order = {'day': 0, 'minute240': 1, 'minute60': 2, 'minute30': 3, 'minute15': 4, 'minute10': 5}
                    btc_items = sorted(
                        [x for x in portfolio_list if x.get('coin', '').upper() == 'BTC'],
                        key=lambda x: interval_order.get(x.get('interval', 'day'), 99)
                    )
                    other_items = sorted(
                        [x for x in portfolio_list if x.get('coin', '').upper() != 'BTC'],
                        key=lambda x: interval_order.get(x.get('interval', 'day'), 99)
                    )

                    # 李⑦듃 ?곗씠???섏쭛 + ?뚮뜑留??⑥닔
                    def render_chart_row(items):
                        if not items:
                            return
                        cols = st.columns(len(items))
                        for ci, item in enumerate(items):
                            p_ticker = f"{item['market']}-{item['coin'].upper()}"
                            p_strategy = item.get('strategy', 'SMA')
                            p_param = item.get('parameter', 20)
                            p_sell_param = item.get('sell_parameter', 0) or max(5, p_param // 2)
                            p_interval = item.get('interval', 'day')
                            iv_label = INTERVAL_REV_MAP.get(p_interval, p_interval)

                            try:
                                # Worker 罹먯떆 ?곗씠???곗꽑 ?ъ슜 (API ?몄텧 ?쒓굅)
                                df_60 = worker.get_data(p_ticker, p_interval)
                                if df_60 is None or len(df_60) < p_param + 5:
                                    # Worker ?곗씠???놁쑝硫?TTL 罹먯떆濡?API ?몄텧
                                    df_60 = _ttl_cache(
                                        f"ohlcv_{p_ticker}_{p_interval}",
                                        lambda t=p_ticker, iv=p_interval, pp=p_param: pyupbit.get_ohlcv(t, interval=iv, count=max(60 + pp, 200)),
                                        ttl=30
                                    )
                                if df_60 is None or len(df_60) < p_param + 5:
                                    continue

                                close_now = df_60['close'].iloc[-1]

                                if p_strategy == "Donchian":
                                    upper_vals = df_60['high'].rolling(window=p_param).max().shift(1)
                                    lower_vals = df_60['low'].rolling(window=p_sell_param).min().shift(1)
                                    buy_target = upper_vals.iloc[-1]
                                    sell_target = lower_vals.iloc[-1]
                                    buy_dist = (close_now - buy_target) / buy_target * 100 if buy_target else 0
                                    sell_dist = (close_now - sell_target) / sell_target * 100 if sell_target else 0

                                    # ?ъ????곹깭 ?쒕??덉씠??(?덉튂?덉? ?곹깭 湲곕컲)
                                    in_position = False
                                    for i in range(len(df_60)):
                                        u = upper_vals.iloc[i]
                                        l = lower_vals.iloc[i]
                                        c = df_60['close'].iloc[i]
                                        if not pd.isna(u) and c > u:
                                            in_position = True
                                        elif not pd.isna(l) and c < l:
                                            in_position = False

                                    if in_position:
                                        position_label = "蹂댁쑀"
                                        signal = "SELL" if close_now < sell_target else "HOLD"
                                    else:
                                        position_label = "?꾧툑"
                                        signal = "BUY" if close_now > buy_target else "WAIT"
                                else:
                                    sma_vals = df_60['close'].rolling(window=p_param).mean()
                                    buy_target = sma_vals.iloc[-1]
                                    sell_target = buy_target
                                    buy_dist = (close_now - buy_target) / buy_target * 100 if buy_target else 0
                                    sell_dist = buy_dist
                                    if close_now > buy_target:
                                        signal = "BUY"
                                        position_label = "蹂댁쑀"
                                    else:
                                        signal = "SELL"
                                        position_label = "?꾧툑"

                                signal_rows.append({
                                    "醫낅ぉ": p_ticker.replace("KRW-", ""),
                                    "?꾨왂": f"{p_strategy} {p_param}",
                                    "?쒓컙遊?: iv_label,
                                    "?ъ???: position_label,
                                    "?꾩옱媛": f"{close_now:,.0f}",
                                    "留ㅼ닔紐⑺몴": f"{buy_target:,.0f}",
                                    "留ㅻ룄紐⑺몴": f"{sell_target:,.0f}",
                                    "留ㅼ닔?닿꺽??: f"{buy_dist:+.2f}%",
                                    "留ㅻ룄?닿꺽??: f"{sell_dist:+.2f}%",
                                })

                                df_chart = df_60.iloc[-60:]
                                with cols[ci]:
                                    fig_m = go.Figure()
                                    fig_m.add_trace(go.Candlestick(
                                        x=df_chart.index, open=df_chart['open'],
                                        high=df_chart['high'], low=df_chart['low'],
                                        close=df_chart['close'], name='媛寃?,
                                        increasing_line_color='#26a69a', decreasing_line_color='#ef5350',
                                    ))

                                    if p_strategy == "Donchian":
                                        upper_chart = upper_vals.loc[df_chart.index]
                                        lower_chart = lower_vals.loc[df_chart.index]
                                        fig_m.add_trace(go.Scatter(
                                            x=df_chart.index, y=upper_chart,
                                            name=f'?곷떒({p_param})', line=dict(color='green', width=1, dash='dot')
                                        ))
                                        fig_m.add_trace(go.Scatter(
                                            x=df_chart.index, y=lower_chart,
                                            name=f'?섎떒({p_sell_param})', line=dict(color='red', width=1, dash='dot')
                                        ))
                                    else:
                                        sma_chart = sma_vals.loc[df_chart.index]
                                        fig_m.add_trace(go.Scatter(
                                            x=df_chart.index, y=sma_chart,
                                            name=f'SMA({p_param})', line=dict(color='orange', width=2)
                                        ))

                                    sig_color = "green" if signal == "BUY" else ("red" if signal == "SELL" else ("blue" if signal == "WAIT" else "gray"))
                                    title_pos = f" [{position_label}]" if p_strategy == "Donchian" else ""
                                    fig_m.update_layout(
                                        title=f"{p_ticker.replace('KRW-','')} {p_strategy}{p_param} ({iv_label}){title_pos} [{buy_dist:+.1f}%]",
                                        title_font_color=sig_color,
                                        height=300, margin=dict(l=0, r=0, t=35, b=30),
                                        xaxis_rangeslider_visible=False,
                                        showlegend=False,
                                        xaxis=dict(showticklabels=True, tickformat='%m/%d %H:%M', tickangle=-45, nticks=6),
                                    )
                                    st.plotly_chart(fig_m, use_container_width=True)

                            except Exception as chart_err:
                                with cols[ci]:
                                    st.warning(f"{p_ticker} ?곗씠??濡쒕뱶 ?ㅽ뙣: {chart_err}")
                                continue

                    # 1?? BTC ?꾨왂 (?쇰큺 ??4?쒓컙遊?
                    render_chart_row(btc_items)
                    # 2?? ETH, SOL ??
                    render_chart_row(other_items)

                    # ?쒓렇???붿빟 ?뚯씠釉?
                    if signal_rows:
                        df_sig = pd.DataFrame(signal_rows)
                        st.dataframe(df_sig, use_container_width=True, hide_index=True)

                # 由щ갭?곗떛 洹쒖튃 (??긽 ?쒖떆)
                with st.expander("?뽳툘 由щ갭?곗떛 洹쒖튃", expanded=False):
                    st.markdown("""
**?ㅽ뻾 ?쒖젏**: GitHub Action ?ㅽ뻾 ?쒕쭏??(?먮룞: 留ㅼ씪 09:05 KST / ?섎룞 ?ㅽ뻾 媛??

**?ㅽ뻾 ?쒖꽌**: ?꾩껜 ?쒓렇??遺꾩꽍 ??留ㅻ룄 癒쇱? ?ㅽ뻾 (?꾧툑 ?뺣낫) ???꾧툑 鍮꾨? 諛곕텇 留ㅼ닔

**留ㅻℓ ?먮떒** (?꾩씪 醫낃? 湲곗?)

| ?꾩옱 ?곹깭 | ?쒓렇??| ?ㅽ뻾 ?댁슜 |
|-----------|--------|-----------|
| 肄붿씤 誘몃낫??| 留ㅼ닔 ?쒓렇??| **留ㅼ닔** ???꾧툑?먯꽌 鍮꾩쨷 鍮꾨? 諛곕텇 |
| 肄붿씤 誘몃낫??| 留ㅻ룄/以묐┰ | **?湲?* ???꾧툑 蹂댁〈 (鍮꾩쨷留뚰겮 ?덈퉬) |
| 肄붿씤 蹂댁쑀 以?| 留ㅻ룄 ?쒓렇??| **留ㅻ룄** ???꾨웾 ?쒖옣媛 留ㅻ룄 |
| 肄붿씤 蹂댁쑀 以?| 留ㅼ닔/以묐┰ | **?좎?** ??怨꾩냽 蹂댁쑀 (異붽? 留ㅼ닔 ?놁쓬) |

**留ㅼ닔 湲덉븸 怨꾩궛**: 蹂댁쑀 以묒씤 ?먯궛? 臾댁떆, ?꾧툑??誘몃낫???먯궛 鍮꾩쨷?쇰━ 鍮꾨? 諛곕텇

> ?? BTC 40%(蹂댁쑀以?, ETH 30%(誘몃낫??, SOL 30%(誘몃낫??
> ??誘몃낫??鍮꾩쨷 ?⑷퀎 = 60%
> ??ETH 留ㅼ닔??= ?꾧툑 횞 30/60, SOL 留ㅼ닔??= ?꾧툑 횞 30/60

**?쒓렇??諛쒖깮 議곌굔**

| | 留ㅼ닔 ?쒓렇??| 留ㅻ룄 ?쒓렇??|
|---|---------|---------|
| **SMA** | 醫낃? > ?대룞?됯퇏??| 醫낃? < ?대룞?됯퇏??|
| **Donchian** | 醫낃? > N??理쒓퀬媛 ?뚰뙆 | 醫낃? < M??理쒖?媛 ?댄깉 |
""")

                # ?⑹궛 ?ы듃?대━???먮━ 誘몃━ ?뺣낫 (?곗씠???섏쭛 ???뚮뜑留?
                combined_portfolio_container = st.container()

                st.write(f"### ?뱥 ?먯궛 ?곸꽭 (?꾧툑 ?덈퉬: {reserved_cash:,.0f} KRW)")

                # ?ы듃?대━???⑹궛???먯옘???섏쭛
                portfolio_equity_data = []  # [(label, equity_series, close_series, per_coin_cap, perf)]

                for asset_idx, item in enumerate(portfolio_list):
                    ticker = f"{item['market']}-{item['coin'].upper()}"
                    
                    # Per-Coin Strategy Settings
                    strategy_mode = item.get('strategy', 'SMA Strategy')
                    param_val = item.get('parameter', item.get('sma', 20)) # Backwards compat
                    aux_enabled = bool(item.get("aux_enabled", False))
                    
                    weight = item.get('weight', 0)
                    interval = item.get('interval', 'day')
                    # ?붿껌?ы빆: 蹂댁“ ?꾨왂? 硫붿씤 ?꾨왂 ?명똿(?쒓컙遊??ы븿)??洹몃?濡??ъ슜
                    aux_exec_interval = interval
                    aux_main_interval = interval
                    
                    # Calculate Allocated Capital
                    per_coin_cap = initial_cap * (weight / 100.0)
                    
                    # Collapse by default to save rendering time
                    _iv_label = INTERVAL_REV_MAP.get(interval, interval)
                    _aux_exec_label = INTERVAL_REV_MAP.get(aux_exec_interval, aux_exec_interval)
                    _aux_main_label = INTERVAL_REV_MAP.get(aux_main_interval, aux_main_interval)
                    _aux_tag = " + AUX(硫붿씤?ㅼ젙?숈씪)" if aux_enabled else ""
                    with st.expander(f"**{ticker}** ({strategy_mode} {param_val}, {weight}%, {_iv_label}){_aux_tag}", expanded=False):
                        try:
                            # 1. Get Data from Worker
                            df_curr = worker.get_data(ticker, interval)
                            
                            if df_curr is None or len(df_curr) < param_val:
                                st.warning(f"?곗씠???湲?以?.. ({ticker}, {interval})")
                                total_theo_val += per_coin_cap 
                                continue
                                
                            # Dynamic Strategy Selection
                            sell_p = item.get('sell_parameter', 0) or max(5, int(param_val) // 2)
                            if strategy_mode == "Donchian":
                                strategy_eng = DonchianStrategy()
                                buy_p = param_val
                                sell_p = item.get('sell_parameter', 0) or max(5, buy_p // 2)
                                
                                df_curr = strategy_eng.create_features(df_curr, buy_period=buy_p, sell_period=sell_p)
                                last_candle = df_curr.iloc[-2]
                                
                                # Visuals for Donchian
                                curr_upper = last_candle.get(f'Donchian_Upper_{buy_p}', 0)
                                curr_lower = last_candle.get(f'Donchian_Lower_{sell_p}', 0)
                                curr_sma = (curr_upper + curr_lower) / 2 # Mid for display
                                
                                curr_signal = strategy_eng.get_signal(last_candle, buy_period=buy_p, sell_period=sell_p)
                                
                            else: # SMA Strategy (Default)
                                strategy_eng = SMAStrategy()
                                calc_periods = [param_val]
                                    
                                df_curr = strategy_eng.create_features(df_curr, periods=calc_periods)
                                last_candle = df_curr.iloc[-2]
                                
                                curr_sma = last_candle[f'SMA_{param_val}']
                                curr_signal = strategy_eng.get_signal(last_candle, strategy_type='SMA_CROSS', ma_period=param_val)
                            # 罹먯떆??媛寃㈑룹옍怨??ъ슜 (?쇨큵 議고쉶 寃곌낵)
                            curr_price = all_prices.get(ticker, 0) or 0
                            coin_sym = item['coin'].upper()
                            coin_bal = all_balances.get(coin_sym, 0)

                            # 3. Theo Backtest (Sync Check) - 罹먯떆??諛깊뀒?ㅽ듃 ?ъ슜
                            sell_ratio = (sell_p / param_val) if param_val > 0 else 0.5
                            if aux_enabled:
                                _aux_ma_short = int(item.get("aux_ma_short", live_aux_defaults["ma_short"]))
                                _aux_ma_long = int(item.get("aux_ma_long", live_aux_defaults["ma_long"]))
                                _aux_thr = float(item.get("aux_threshold", live_aux_defaults["threshold"]))
                                _aux_tp1 = float(item.get("aux_tp1_pct", live_aux_defaults["tp1_pct"]))
                                _aux_tp2 = float(item.get("aux_tp2_pct", live_aux_defaults["tp2_pct"]))
                                _aux_split = int(item.get("aux_split_count", live_aux_defaults["split_count"]))
                                _aux_seed_mode = str(item.get("aux_seed_mode", live_aux_defaults["buy_seed_mode"])).lower()
                                _aux_seed_mode = "pyramiding" if _aux_seed_mode == "pyramiding" else "equal"
                                _aux_ratio = float(item.get("aux_pyramid_ratio", live_aux_defaults["pyramid_ratio"]))

                                _main_strat = "Donchian" if strategy_mode == "Donchian" else "SMA"
                                _exec_df = data_cache.load_cached(ticker, aux_exec_interval)
                                if _exec_df is None or len(_exec_df) < max(50, _aux_ma_long + 5):
                                    _need_count = max(2000, _aux_ma_long + 500)
                                    _exec_df = data_cache.get_ohlcv_cached(ticker, interval=aux_exec_interval, count=_need_count)

                                _main_df = None
                                if aux_main_interval != aux_exec_interval:
                                    _main_df = data_cache.load_cached(ticker, aux_main_interval)
                                    if _main_df is None or len(_main_df) < max(50, int(param_val) + 5):
                                        _main_need_count = max(2000, int(param_val) + 500)
                                        _main_df = data_cache.get_ohlcv_cached(ticker, interval=aux_main_interval, count=_main_need_count)

                                if _exec_df is None or len(_exec_df) < max(50, _aux_ma_long + 5) or (aux_main_interval != aux_exec_interval and (_main_df is None or len(_main_df) < max(50, int(param_val) + 5))):
                                    bt_res = {"error": f"蹂댁“ ?꾨왂 ?곗씠??遺議?({ticker})"}
                                else:
                                    _aux_res = backtest_engine.run_aux_backtest(
                                        _exec_df,
                                        main_strategy=_main_strat,
                                        main_buy_p=int(param_val),
                                        main_sell_p=int(sell_p),
                                        ma_short=_aux_ma_short,
                                        ma_long=_aux_ma_long,
                                        oversold_threshold=_aux_thr,
                                        tp1_pct=_aux_tp1,
                                        tp2_pct=_aux_tp2,
                                        start_date=str(start_date),
                                        initial_balance=per_coin_cap,
                                        split_count=_aux_split,
                                        buy_seed_mode=_aux_seed_mode,
                                        pyramid_ratio=_aux_ratio,
                                        main_df=_main_df,
                                    )
                                    _hist_idx = pd.to_datetime(_aux_res.get("dates")) if _aux_res.get("dates") is not None else _exec_df.index
                                    _eq_curve = np.asarray(_aux_res.get("equity_curve"), dtype=float) if _aux_res.get("equity_curve") is not None else np.array([])
                                    _dd_curve = np.asarray(_aux_res.get("drawdown_curve"), dtype=float) if _aux_res.get("drawdown_curve") is not None else np.array([])
                                    if len(_hist_idx) > 0 and len(_eq_curve) > 0:
                                        _hist_df = pd.DataFrame(index=_hist_idx)
                                        _close_series = _exec_df["close"].copy()
                                        _c_idx = pd.DatetimeIndex(_close_series.index)
                                        _h_idx = pd.DatetimeIndex(_hist_df.index)
                                        if _c_idx.tz is not None:
                                            _c_idx = _c_idx.tz_localize(None)
                                        if _h_idx.tz is not None:
                                            _h_idx = _h_idx.tz_localize(None)
                                        _close_series.index = _c_idx
                                        _hist_df.index = _h_idx
                                        _hist_df["close"] = _close_series.reindex(_h_idx, method="ffill").values
                                        _hist_df["equity"] = _eq_curve
                                        if len(_dd_curve) == len(_hist_df):
                                            _hist_df["drawdown"] = _dd_curve
                                    else:
                                        _hist_df = _exec_df.copy()
                                        _hist_df["equity"] = per_coin_cap
                                        _hist_df["drawdown"] = 0.0

                                    _aux_perf = {
                                        "initial_balance": per_coin_cap,
                                        "final_equity": float(_aux_res.get("final_equity", per_coin_cap)),
                                        "total_return": float(_aux_res.get("total_return", 0.0)),
                                        "cagr": float(_aux_res.get("cagr", 0.0)),
                                        "mdd": float(_aux_res.get("mdd", 0.0)),
                                        "avg_yearly_mdd": float(_aux_res.get("avg_yearly_mdd", _aux_res.get("mdd", 0.0))),
                                        "win_rate": float(_aux_res.get("win_rate", 0.0)),
                                        "trade_count": int(_aux_res.get("trade_count", 0)),
                                        "sharpe": float(_aux_res.get("sharpe", 0.0)),
                                        "yearly_stats": pd.DataFrame(),
                                        "trades": [],
                                        "final_status": _aux_res.get("final_status", "UNKNOWN"),
                                        "next_action": _aux_res.get("next_action", None),
                                    }
                                    bt_res = {"performance": _aux_perf, "df": _hist_df}
                            else:
                                df_bt = data_cache.load_cached(ticker, interval)
                                if df_bt is not None and len(df_bt) >= param_val:
                                    req_count = len(df_bt)
                                    df_hash = f"{len(df_bt)}_{df_bt.index[-1]}"
                                else:
                                    df_bt = df_curr
                                    req_count = len(df_bt)
                                    df_hash = f"{len(df_bt)}_{df_bt.index[-1]}"
                                bt_res = _cached_backtest(
                                    ticker, param_val, interval, req_count,
                                    str(start_date), per_coin_cap, strategy_mode,
                                    sell_ratio, df_hash
                                )
                                if bt_res is None:
                                    bt_res = backtest_engine.run_backtest(
                                        ticker, period=param_val, interval=interval,
                                        count=req_count, start_date=start_date,
                                        initial_balance=per_coin_cap, df=df_bt,
                                        strategy_mode=strategy_mode,
                                        sell_period_ratio=sell_ratio
                                    )
                            
                            expected_eq = 0
                            theo_status = "UNKNOWN"
                            
                            if "error" not in bt_res:
                                perf = bt_res['performance']
                                theo_status = perf['final_status']
                                expected_eq = perf['final_equity']
                                total_theo_val += expected_eq
                                # ?⑹궛 ?ы듃?대━?ㅼ슜 ?먯옘???섏쭛
                                hist_df_tmp = bt_res['df']
                                if aux_enabled:
                                    label = f"{ticker} ({strategy_mode} {param_val}, {_iv_label}) + AUX[{_aux_exec_label}/{_aux_main_label}]"
                                else:
                                    label = f"{ticker} ({strategy_mode} {param_val}, {_iv_label})"
                                portfolio_equity_data.append({
                                    "label": label,
                                    "equity": hist_df_tmp['equity'],
                                    "close": hist_df_tmp['close'],
                                    "cap": per_coin_cap,
                                    "perf": perf,
                                })
                            else:
                                total_theo_val += per_coin_cap # Fallback if error
                                
                            # 4. Real Status
                            coin_val = coin_bal * curr_price
                            total_real_val += coin_val # Add coin value to total
                            real_status = "HOLD" if coin_val > 5000 else "CASH"
                            
                            # --- Display Metrics ---
                            c1, c2, c3, c4 = st.columns(4)
                            c1.metric("媛寃?/ SMA", f"{curr_price:,.0f}", delta=f"{curr_price - curr_sma:,.0f}")
                            
                            
                            # Signal Metric Removed as requested
                            # c2.markdown(f"**Signal**: :{sig_color}[{curr_signal}]")
                            if aux_enabled:
                                c2.metric("?꾨왂", f"{strategy_mode}+蹂댁“")
                                c2.caption("蹂댁“ ?꾨왂: 硫붿씤 ?꾨왂 ?ㅼ젙怨??숈씪")
                            elif strategy_mode == "Donchian":
                                c2.metric("梨꾨꼸", f"{buy_p}/{sell_p}")
                            else:
                                c2.metric("SMA 湲곌컙", f"{param_val}")
                            
                            # Asset Performance
                            roi_theo = (expected_eq - per_coin_cap) / per_coin_cap * 100
                            c3.metric(f"?대줎 ?먯궛", f"{expected_eq:,.0f}", delta=f"{roi_theo:.2f}%")
                            
                            match = (real_status == theo_status)
                            match_color = "green" if match else "red"
                            c4.markdown(f"**?숆린??*: :{match_color}[{'?쇱튂' if match else '遺덉씪移?}]")
                            c4.caption(f"?ㅼ젣: {coin_bal:,.4f} {coin_sym} ({real_status})")
                            
                            st.divider()
                            
                            # --- Tabs for Charts & Orders ---
                            p_tab1, p_tab2 = st.tabs(["?뱢 遺꾩꽍 & 踰ㅼ튂留덊겕", "?뱥 泥닿껐 ?댁뿭"])

                            with p_tab1:
                                if "error" not in bt_res:
                                    hist_df = bt_res['df']
                                    start_equity = hist_df['equity'].iloc[0]
                                    start_price = hist_df['close'].iloc[0]

                                    # Normalized Comparison
                                    hist_df['Norm_Strat'] = hist_df['equity'] / start_equity * 100
                                    hist_df['Norm_Bench'] = hist_df['close'] / start_price * 100

                                    fig_comp = go.Figure()
                                    fig_comp.add_trace(go.Scatter(x=hist_df.index, y=hist_df['Norm_Strat'], name='?꾨왂', line=dict(color='blue')))
                                    fig_comp.add_trace(go.Scatter(x=hist_df.index, y=hist_df['Norm_Bench'], name='踰ㅼ튂留덊겕', line=dict(color='gray', dash='dot')))

                                    # 留ㅼ닔/留ㅻ룄 留덉빱 異붽?
                                    if perf.get('trades'):
                                        buy_trades = [t for t in perf['trades'] if t['type'] == 'buy']
                                        sell_trades = [t for t in perf['trades'] if t['type'] == 'sell']
                                        if buy_trades:
                                            buy_dates = [t['date'] for t in buy_trades]
                                            buy_vals = [hist_df.loc[d, 'Norm_Strat'] if d in hist_df.index else None for d in buy_dates]
                                            fig_comp.add_trace(go.Scatter(
                                                x=buy_dates, y=buy_vals, mode='markers', name='留ㅼ닔',
                                                marker=dict(symbol='triangle-up', size=10, color='green')
                                            ))
                                        if sell_trades:
                                            sell_dates = [t['date'] for t in sell_trades]
                                            sell_vals = [hist_df.loc[d, 'Norm_Strat'] if d in hist_df.index else None for d in sell_dates]
                                            fig_comp.add_trace(go.Scatter(
                                                x=sell_dates, y=sell_vals, mode='markers', name='留ㅻ룄',
                                                marker=dict(symbol='triangle-down', size=10, color='red')
                                            ))

                                    fig_comp.update_layout(height=300, title="?꾨왂 vs ?⑥닚蹂댁쑀 (?뺢퇋??", margin=dict(l=0,r=0,t=80,b=0),
                                        legend=dict(orientation="h", yanchor="bottom", y=1.02, xanchor="left", x=0))
                                    st.plotly_chart(fig_comp, use_container_width=True)

                                    # ?곕룄蹂??깃낵 ?뚯씠釉?
                                    if 'yearly_stats' in perf:
                                        st.caption("?뱟 ?곕룄蹂??깃낵")
                                        ys = perf['yearly_stats'].copy()
                                        # Average ??異붽? (?ъ슜???붿껌)
                                        if not ys.empty:
                                            avg_vals = {col: [ys[col].mean()] for col in ys.columns if ys[col].dtype in [np.float64, np.int64]}
                                            avg_row = pd.DataFrame(avg_vals, index=["?됯퇏"])
                                            ys = pd.concat([ys, avg_row])
                                        ys.index.name = "?곕룄"
                                        st.dataframe(ys.style.format("{:.2f}"), use_container_width=True)
                            
                            with p_tab2:
                                # ?? 媛??諛깊뀒?ㅽ듃) 泥닿껐 ?댁뿭 ??
                                st.markdown("**媛??泥닿껐 (諛깊뀒?ㅽ듃)**")
                                if "error" not in bt_res and perf.get('trades'):
                                    vt_rows = []
                                    for t in perf['trades']:
                                        t_date = t.get('date', '')
                                        if hasattr(t_date, 'strftime'):
                                            t_date = t_date.strftime('%Y-%m-%d')
                                        t_type = t.get('type', '')
                                        t_side = "留ㅼ닔" if t_type == 'buy' else ("留ㅻ룄" if t_type == 'sell' else t_type)
                                        t_price = t.get('price', 0)
                                        t_amount = t.get('amount', 0)
                                        t_equity = t.get('equity', 0)
                                        vt_rows.append({
                                            "?쇱떆": t_date,
                                            "援щ텇": f"?뵶 {t_side}" if t_type == 'buy' else f"?뵷 {t_side}",
                                            "泥닿껐媛": f"{t_price:,.0f}",
                                            "?섎웾": f"{t_amount:.6f}" if t_amount < 1 else f"{t_amount:,.4f}",
                                            "?먯궛(KRW)": f"{t_equity:,.0f}",
                                        })
                                    if vt_rows:
                                        st.dataframe(pd.DataFrame(vt_rows[-20:]), use_container_width=True, hide_index=True)
                                        st.caption(f"理쒓렐 {min(20, len(vt_rows))}嫄?/ 珥?{len(vt_rows)}嫄?)
                                    else:
                                        st.info("諛깊뀒?ㅽ듃 泥닿껐 湲곕줉 ?놁쓬")
                                else:
                                    st.info("諛깊뀒?ㅽ듃 ?곗씠???놁쓬")

                                # ?? ?ㅼ젣 泥닿껐 ?댁뿭 (嫄곕옒?? ??
                                st.markdown("**?ㅼ젣 泥닿껐 (嫄곕옒??**")
                                try:
                                    done = _ttl_cache(
                                        f"done_{ticker}",
                                        lambda t=ticker: trader.get_done_orders(t),
                                        ttl=30
                                    )
                                    if done:
                                        rt_rows = []
                                        for r in done[:20]:
                                            side = r.get('side', '')
                                            side_kr = "留ㅼ닔" if side == 'bid' else ("留ㅻ룄" if side == 'ask' else side)
                                            price_r = float(r.get('price', 0) or 0)
                                            exec_vol = float(r.get('executed_volume', 0) or 0)
                                            if price_r > 0 and exec_vol > 0:
                                                total_k = price_r * exec_vol
                                            elif 'trades' in r and r['trades']:
                                                total_k = sum(float(tr.get('funds', 0)) for tr in r['trades'])
                                            else:
                                                total_k = price_r
                                            created = r.get('created_at', '')
                                            if pd.notna(created):
                                                try: created = pd.to_datetime(created).strftime('%Y-%m-%d %H:%M')
                                                except: pass
                                            rt_rows.append({
                                                "?쇱떆": created,
                                                "援щ텇": f"?뵶 {side_kr}" if side == 'bid' else f"?뵷 {side_kr}",
                                                "泥닿껐媛": f"{price_r:,.0f}" if price_r > 0 else "-",
                                                "?섎웾": f"{exec_vol:.6f}" if exec_vol < 1 else f"{exec_vol:,.4f}",
                                                "湲덉븸(KRW)": f"{total_k:,.0f}",
                                            })
                                        if rt_rows:
                                            st.dataframe(pd.DataFrame(rt_rows), use_container_width=True, hide_index=True)
                                        else:
                                            st.info("泥닿껐 ?꾨즺 二쇰Ц ?놁쓬")
                                    else:
                                        st.info("泥닿껐 ?꾨즺 二쇰Ц ?놁쓬")
                                except Exception:
                                    st.info("泥닿껐 ?댁뿭 議고쉶 遺덇? (API 沅뚰븳 ?뺤씤)")

                        except Exception as e:
                            st.error(f"{ticker} 泥섎━ ?ㅻ쪟: {e}")
                
                # --- Populate Total Summary ---
                total_roi = (total_theo_val - total_init_val) / total_init_val * 100 if total_init_val else 0
                real_roi = (total_real_val - total_init_val) / total_init_val * 100 if total_init_val else 0
                diff_val = total_real_val - total_theo_val

                sum_col1.metric("珥덇린 ?먮낯", f"{total_init_val:,.0f} KRW")
                sum_col2.metric("?대줎 珥앹옄??, f"{total_theo_val:,.0f} KRW", delta=f"{total_roi:.2f}%")
                sum_col3.metric("?ㅼ젣 珥앹옄??, f"{total_real_val:,.0f} KRW", delta=f"{real_roi:.2f}%")
                sum_col4.metric("李⑥씠 (?ㅼ젣-?대줎)", f"{diff_val:,.0f} KRW", delta_color="off" if abs(diff_val)<1000 else "inverse")

                # --- ?⑹궛 ?ы듃?대━???깃낵 (Combined Portfolio) ???꾩뿉 ?덉빟??container???뚮뜑留?---
                if portfolio_equity_data:
                    with combined_portfolio_container:
                        with st.expander("?뱤 ?⑹궛 ?ы듃?대━???깃낵", expanded=True):
                            # 媛??먯궛???먯옘?곕? ?쇱옄 湲곗??쇰줈 ?⑹궛
                            equity_dfs = []
                            bench_dfs = []
                            for ed in portfolio_equity_data:
                                eq = ed['equity'].copy()
                                cl = ed['close'].copy()
                                cap = ed['cap']

                                if hasattr(eq.index, 'tz') and eq.index.tz is not None:
                                    eq.index = eq.index.tz_localize(None)
                                    cl.index = cl.index.tz_localize(None)
                                eq_daily = eq.resample('D').last().dropna()
                                cl_daily = cl.resample('D').last().dropna()

                                bench_daily = (cl_daily / cl_daily.iloc[0]) * cap

                                eq_daily.name = ed['label']
                                bench_daily.name = ed['label']
                                equity_dfs.append(eq_daily)
                                bench_dfs.append(bench_daily)

                            combined_eq = pd.concat(equity_dfs, axis=1).sort_index()
                            combined_bench = pd.concat(bench_dfs, axis=1).sort_index()

                            combined_eq = combined_eq.ffill().bfill()
                            combined_bench = combined_bench.ffill().bfill()

                            combined_eq['cash_reserve'] = reserved_cash
                            combined_bench['cash_reserve'] = reserved_cash

                            total_eq = combined_eq.sum(axis=1)
                            total_bench = combined_bench.sum(axis=1)

                            norm_eq = total_eq / total_eq.iloc[0] * 100
                            norm_bench = total_bench / total_bench.iloc[0] * 100

                            # ?깃낵 吏??怨꾩궛
                            port_final = total_eq.iloc[-1]
                            port_init = total_eq.iloc[0]
                            port_return = (port_final - port_init) / port_init * 100

                            port_days = (total_eq.index[-1] - total_eq.index[0]).days
                            port_cagr = 0
                            if port_days > 0 and port_final > 0:
                                port_cagr = ((port_final / port_init) ** (365 / port_days) - 1) * 100

                            port_peak = total_eq.cummax()
                            port_dd = (total_eq - port_peak) / port_peak * 100
                            port_mdd = port_dd.min()

                            port_returns = total_eq.pct_change().dropna()
                            port_sharpe = 0
                            if port_returns.std() > 0:
                                port_sharpe = (port_returns.mean() / port_returns.std()) * np.sqrt(365)

                            bench_final = total_bench.iloc[-1]
                            bench_init = total_bench.iloc[0]
                            bench_return = (bench_final - bench_init) / bench_init * 100

                            # ?고룊洹?MDD 怨꾩궛
                            _port_yearly_mdd = port_dd.groupby(port_dd.index.year).min()
                            _port_avg_yearly_mdd = _port_yearly_mdd.mean() if len(_port_yearly_mdd) > 0 else port_mdd

                            # 硫뷀듃由??쒖떆
                            pm1, pm2, pm3, pm4, pm5, pm6 = st.columns(6)
                            pm1.metric("珥??섏씡瑜?, f"{port_return:.2f}%")
                            pm2.metric("CAGR", f"{port_cagr:.2f}%")
                            pm3.metric("MDD", f"{port_mdd:.2f}%")
                            pm4.metric("?고룊洹쟋DD", f"{_port_avg_yearly_mdd:.2f}%")
                            pm5.metric("Sharpe", f"{port_sharpe:.2f}")
                            pm6.metric("vs ?⑥닚蹂댁쑀", f"{port_return - bench_return:+.2f}%p")

                            st.caption(f"湲곌컙: {total_eq.index[0].strftime('%Y-%m-%d')} ~ {total_eq.index[-1].strftime('%Y-%m-%d')} ({port_days}?? | 珥덇린?먭툑: {port_init:,.0f} ??理쒖쥌: {port_final:,.0f} KRW")

                            # ?⑹궛 李⑦듃
                            fig_port = go.Figure()
                            fig_port.add_trace(go.Scatter(
                                x=norm_eq.index, y=norm_eq.values,
                                name='?ы듃?대━??(?꾨왂)', line=dict(color='blue', width=2)
                            ))
                            fig_port.add_trace(go.Scatter(
                                x=norm_bench.index, y=norm_bench.values,
                                name='?ы듃?대━??(?⑥닚蹂댁쑀)', line=dict(color='gray', dash='dot')
                            ))

                            # ?⑹궛 李⑦듃??留ㅼ닔/留ㅻ룄 留덉빱 ?쒖떆
                            all_buy_dates = []
                            all_sell_dates = []
                            for ed in portfolio_equity_data:
                                for t in ed['perf'].get('trades', []):
                                    if t['type'] == 'buy':
                                        all_buy_dates.append(t['date'])
                                    elif t['type'] == 'sell':
                                        all_sell_dates.append(t['date'])

                            if all_buy_dates:
                                # ?좎쭨瑜?norm_eq ?몃뜳?ㅼ? 留ㅼ묶 (?쇰큺 由ъ깦?뚮쭅 ?먯쑝誘濡?媛??媛源뚯슫 ?좎쭨 ?ъ슜)
                                buy_vals = []
                                buy_dates_valid = []
                                for d in all_buy_dates:
                                    d_ts = pd.Timestamp(d)
                                    if hasattr(d_ts, 'tz') and d_ts.tz is not None:
                                        d_ts = d_ts.tz_localize(None)
                                    idx = norm_eq.index.get_indexer([d_ts], method='nearest')
                                    if idx[0] >= 0:
                                        buy_dates_valid.append(norm_eq.index[idx[0]])
                                        buy_vals.append(norm_eq.iloc[idx[0]])
                                if buy_dates_valid:
                                    fig_port.add_trace(go.Scatter(
                                        x=buy_dates_valid, y=buy_vals, mode='markers', name='留ㅼ닔',
                                        marker=dict(symbol='triangle-up', size=8, color='green', opacity=0.7)
                                    ))

                            if all_sell_dates:
                                sell_vals = []
                                sell_dates_valid = []
                                for d in all_sell_dates:
                                    d_ts = pd.Timestamp(d)
                                    if hasattr(d_ts, 'tz') and d_ts.tz is not None:
                                        d_ts = d_ts.tz_localize(None)
                                    idx = norm_eq.index.get_indexer([d_ts], method='nearest')
                                    if idx[0] >= 0:
                                        sell_dates_valid.append(norm_eq.index[idx[0]])
                                        sell_vals.append(norm_eq.iloc[idx[0]])
                                if sell_dates_valid:
                                    fig_port.add_trace(go.Scatter(
                                        x=sell_dates_valid, y=sell_vals, mode='markers', name='留ㅻ룄',
                                        marker=dict(symbol='triangle-down', size=8, color='red', opacity=0.7)
                                    ))

                            fig_port.update_layout(
                                height=350,
                                title="?⑹궛 ?ы듃?대━?? ?꾨왂 vs ?⑥닚蹂댁쑀 (?뺢퇋??",
                                yaxis_title="?뺢퇋??(%)",
                                margin=dict(l=0, r=0, t=80, b=0),
                                hovermode='x unified',
                                legend=dict(orientation="h", yanchor="bottom", y=1.02, xanchor="left", x=0)
                            )
                            st.plotly_chart(fig_port, use_container_width=True)

                            # ?ы듃?대━??MDD(Drawdown) 李⑦듃 異붽?
                            fig_dd = go.Figure()
                            fig_dd.add_trace(go.Scatter(
                                x=port_dd.index, y=port_dd.values,
                                name='?숉룺', fill='tozeroy',
                                line=dict(color='red', width=1)
                            ))
                            fig_dd.update_layout(
                                height=200,
                                title="?ы듃?대━???숉룺 (%)",
                                yaxis_title="?숉룺 (%)",
                                margin=dict(l=0, r=0, t=80, b=0),
                                hovermode='x unified',
                                legend=dict(orientation="h", yanchor="bottom", y=1.02, xanchor="left", x=0)
                            )
                            st.plotly_chart(fig_dd, use_container_width=True)

                            # 媛쒕퀎 ?먯궛 ?먯옘??湲곗뿬??李⑦듃
                            fig_stack = go.Figure()
                            for ed in portfolio_equity_data:
                                eq = ed['equity'].copy()
                                if hasattr(eq.index, 'tz') and eq.index.tz is not None:
                                    eq.index = eq.index.tz_localize(None)
                                eq_d = eq.resample('D').last().dropna()
                                fig_stack.add_trace(go.Scatter(
                                    x=eq_d.index, y=eq_d.values,
                                    name=ed['label'], stackgroup='one'
                                ))
                            if reserved_cash > 0:
                                fig_stack.add_trace(go.Scatter(
                                    x=total_eq.index, y=[reserved_cash] * len(total_eq),
                                    name='?꾧툑 ?덈퉬', stackgroup='one',
                                    line=dict(color='lightgray')
                                ))
                            fig_stack.update_layout(
                                height=350,
                                title="?먯궛蹂?湲곗뿬??(?곸링)",
                                yaxis_title="KRW",
                                margin=dict(l=0, r=0, t=80, b=0),
                                hovermode='x unified',
                                legend=dict(orientation="h", yanchor="bottom", y=1.02, xanchor="left", x=0)
                            )
                            st.plotly_chart(fig_stack, use_container_width=True)

                            # 媛쒕퀎 ?먯궛 ?깃낵 ?뚯씠釉?
                            asset_perf_rows = []
                            for ed in portfolio_equity_data:
                                p = ed['perf']
                                asset_perf_rows.append({
                                    "?먯궛": ed['label'],
                                    "諛곕텇?먮낯": f"{ed['cap']:,.0f}",
                                    "理쒖쥌?먯궛": f"{p['final_equity']:,.0f}",
                                    "?섏씡瑜?%)": f"{p['total_return']:.2f}",
                                    "CAGR(%)": f"{p['cagr']:.2f}",
                                    "MDD(%)": f"{p['mdd']:.2f}",
                                    "?밸쪧(%)": f"{p['win_rate']:.1f}",
                                    "嫄곕옒??: p['trade_count'],
                                    "Sharpe": f"{p['sharpe']:.2f}",
                                    "?곹깭": p['final_status'],
                                })
                            st.dataframe(pd.DataFrame(asset_perf_rows), use_container_width=True, hide_index=True)

                            # ?뱟 ?⑹궛 ?ы듃?대━???곕룄蹂??깃낵 ?뚯씠釉?
                            st.caption("?뱟 ?⑹궛 ?ы듃?대━???곕룄蹂??깃낵")
                            port_daily_ret = total_eq.pct_change().fillna(0)
                            port_year = total_eq.index.year
                            port_dd_series = port_dd

                            yearly_rows = []
                            for yr in sorted(port_year.unique()):
                                yr_mask = port_year == yr
                                yr_ret = (1 + port_daily_ret[yr_mask]).prod() - 1
                                yr_mdd = port_dd_series[yr_mask].min()
                                yr_eq_start = total_eq[yr_mask].iloc[0]
                                yr_eq_end = total_eq[yr_mask].iloc[-1]

                                # 踰ㅼ튂留덊겕 ?곕룄蹂?
                                yr_bench_start = total_bench[yr_mask].iloc[0]
                                yr_bench_end = total_bench[yr_mask].iloc[-1]
                                yr_bench_ret = (yr_bench_end - yr_bench_start) / yr_bench_start * 100

                                yearly_rows.append({
                                    "?곕룄": yr,
                                    "?섏씡瑜?%)": f"{yr_ret * 100:.2f}",
                                    "MDD(%)": f"{yr_mdd:.2f}",
                                    "?쒖옉?먯궛": f"{yr_eq_start:,.0f}",
                                    "理쒖쥌?먯궛": f"{yr_eq_end:,.0f}",
                                    "Buy&Hold(%)": f"{yr_bench_ret:.2f}",
                                    "珥덇낵?섏씡(%p)": f"{yr_ret * 100 - yr_bench_ret:.2f}",
                                })
                            # ?됯퇏 ??異붽?
                            _df_port_yr = pd.DataFrame(yearly_rows)
                            _pavg_ret = np.mean([float(r["?섏씡瑜?%)"]) for r in yearly_rows])
                            _pavg_mdd = np.mean([float(r["MDD(%)"]) for r in yearly_rows])
                            _pavg_bh = np.mean([float(r["Buy&Hold(%)"]) for r in yearly_rows])
                            _pavg_excess = np.mean([float(r["珥덇낵?섏씡(%p)"]) for r in yearly_rows])
                            _df_port_yr = pd.concat([_df_port_yr, pd.DataFrame([{
                                "?곕룄": "?됯퇏", "?섏씡瑜?%)": f"{_pavg_ret:.2f}",
                                "MDD(%)": f"{_pavg_mdd:.2f}",
                                "?쒖옉?먯궛": "??, "理쒖쥌?먯궛": "??,
                                "Buy&Hold(%)": f"{_pavg_bh:.2f}",
                                "珥덇낵?섏씡(%p)": f"{_pavg_excess:.2f}",
                            }])], ignore_index=True)
                            st.dataframe(_df_port_yr, use_container_width=True, hide_index=True)

    # --- Tab 5: Manual Trade (嫄곕옒???ㅽ??? ---
    with tab5:
        st.header("?섎룞 二쇰Ц")

        if not trader:
            st.warning("?ъ씠?쒕컮?먯꽌 API ?ㅻ? ?ㅼ젙?댁＜?몄슂.")
        else:
            # 肄붿씤 ?좏깮 (蹂寃쎌떆留?full rerun)
            port_tickers = [f"{r['market']}-{r['coin'].upper()}" for r in portfolio_list]
            manual_options = list(dict.fromkeys(port_tickers + TOP_20_TICKERS))
            mt_col1, mt_col2 = st.columns(2)
            mt_selected = mt_col1.selectbox("肄붿씤 ?좏깮", manual_options + ["吏곸젒?낅젰"], key="mt_ticker")
            if mt_selected == "吏곸젒?낅젰":
                mt_custom = mt_col2.text_input("肄붿씤 ?щ낵", "BTC", key="mt_custom")
                mt_ticker = f"KRW-{mt_custom.upper()}"
            else:
                mt_ticker = mt_selected
                mt_col2.empty()

            mt_coin = mt_ticker.split("-")[1] if "-" in mt_ticker else mt_ticker

            # ?? 肄붿씤 ?몃젅?대뵫 ?뚯빱 ?쒖옉 (諛깃렇?쇱슫??媛깆떊) ??

            @st.cache_resource
            def _get_coin_worker(_trader):
                w = CoinTradingWorker()
                return w

            coin_worker = _get_coin_worker(trader)
            coin_worker.configure(trader, mt_ticker)
            coin_worker.start()

            # ?먥븧???몃젅?대뵫 ?⑤꼸 (fragment ???섎룞 媛깆떊, ?ㅻⅨ ??媛꾩꽠 諛⑹?) ?먥븧??
            @st.fragment
            def trading_panel():
                # ?? ?뚯빱?먯꽌 利됱떆 ?쎄린 (API ?몄텧 ?놁쓬 ??釉붾줈???놁쓬) ??
                mt_price = coin_worker.get('price', 0)
                krw_avail = coin_worker.get('krw_bal', 0)
                mt_coin_bal = coin_worker.get('coin_bal', 0)
                mt_coin_val = mt_coin_bal * mt_price
                mt_tick = get_tick_size(mt_price) if mt_price > 0 else 1
                mt_min_qty = round(5000 / mt_price, 8) if mt_price > 0 else 0.00000001

                # ?곷떒 ?뺣낫 諛?+ ?덈줈怨좎묠
                _r_col, ic1, ic2, ic3, ic4, ic5 = st.columns([0.5, 1, 1, 1, 1, 1])
                _r_col.button("?봽", key="_mt_refresh", help="?쒖꽭 媛깆떊")
                ic1.metric("?꾩옱媛", f"{mt_price:,.0f}")
                ic2.metric(f"{mt_coin} 蹂댁쑀", f"{mt_coin_bal:.8f}" if mt_coin_bal < 1 else f"{mt_coin_bal:,.4f}")
                ic3.metric("?됯?湲덉븸", f"{mt_coin_val:,.0f} KRW")
                ic4.metric("蹂댁쑀 KRW", f"{krw_avail:,.0f}")
                ic5.metric("?멸??⑥쐞", f"{mt_tick:,g}?? if mt_tick >= 1 else f"{mt_tick}??)

                # ?? 理쒓렐 嫄곕옒 寃곌낵 ?뚮┝ 諛?(?몄뀡 ?좎?) ??
                last_trade = st.session_state.get('_last_trade')
                if last_trade:
                    t_type = last_trade.get('type', '')
                    t_time = last_trade.get('time', '')
                    t_ticker = last_trade.get('ticker', '')
                    t_amt = last_trade.get('amount', '')
                    t_price = last_trade.get('price', '')
                    t_qty = last_trade.get('qty', '')
                    is_buy = '留ㅼ닔' in t_type
                    color = '#D32F2F' if is_buy else '#1976D2'
                    detail = t_amt if t_amt else f"{t_price} x {t_qty}"
                    nc1, nc2 = st.columns([6, 1])
                    nc1.markdown(
                        f'<div style="padding:6px 12px;border-radius:6px;background:{color}22;border-left:4px solid {color};font-size:14px;">'
                        f'<b style="color:{color}">{t_type}</b> {t_ticker} | {detail} | {t_time}</div>',
                        unsafe_allow_html=True
                    )
                    if nc2.button("??, key="_dismiss_trade"):
                        del st.session_state['_last_trade']
                        st.rerun()

                st.divider()

                # ?먥븧??硫붿씤 ?덉씠?꾩썐: ?멸?李?醫? + 李⑦듃쨌二쇰Ц(?? ?먥븧??
                ob_col, right_col = st.columns([2, 5])

                # ?? 醫? ?멸?李?(HTML ?뚮뜑留????붾툝?대┃ ?몄쭛 ?놁쓬) ??
                with ob_col:
                    raw_prices = []
                    try:
                        ob_data = coin_worker.get('orderbook')
                        if ob_data and len(ob_data) > 0:
                            ob = ob_data[0] if isinstance(ob_data, list) else ob_data
                            units = ob.get('orderbook_units', [])[:10]

                            if units:
                                max_size = max(
                                    max(u.get('ask_size', 0) for u in units),
                                    max(u.get('bid_size', 0) for u in units)
                                )

                                # ?? HTML ?멸?李??뚯씠釉??앹꽦 ??
                                html = ['<table style="width:100%;border-collapse:collapse;font-size:13px;font-family:monospace;">']
                                html.append('<tr style="border-bottom:2px solid #ddd;font-weight:bold;color:#666"><td>援щ텇</td><td style="text-align:right">?붾웾</td><td style="text-align:right">媛寃?/td><td style="text-align:right">?깅씫</td><td>鍮꾩쑉</td></tr>')

                                ask_prices = []
                                bid_prices = []

                                for u in reversed(units):
                                    ask_p = u.get('ask_price', 0)
                                    ask_s = u.get('ask_size', 0)
                                    diff = ((ask_p / mt_price) - 1) * 100 if mt_price > 0 else 0
                                    bar_w = int(ask_s / max_size * 100) if max_size > 0 else 0
                                    raw_prices.append(ask_p)
                                    ask_prices.append(ask_p)
                                    html.append(
                                        f'<tr style="color:#1976D2;border-bottom:1px solid #f0f0f0;height:28px">'
                                        f'<td>留ㅻ룄</td>'
                                        f'<td style="text-align:right">{ask_s:.4f}</td>'
                                        f'<td style="text-align:right;font-weight:bold">{ask_p:,.0f}</td>'
                                        f'<td style="text-align:right">{diff:+.2f}%</td>'
                                        f'<td><div style="background:#1976D2;height:12px;width:{bar_w}%;opacity:0.3"></div></td>'
                                        f'</tr>'
                                    )

                                # 以묎컙 援щ텇??
                                html.append('<tr style="border-top:3px solid #333;border-bottom:3px solid #333;height:4px"><td colspan="5"></td></tr>')

                                for u in units:
                                    bid_p = u.get('bid_price', 0)
                                    bid_s = u.get('bid_size', 0)
                                    diff = ((bid_p / mt_price) - 1) * 100 if mt_price > 0 else 0
                                    bar_w = int(bid_s / max_size * 100) if max_size > 0 else 0
                                    raw_prices.append(bid_p)
                                    bid_prices.append(bid_p)
                                    html.append(
                                        f'<tr style="color:#D32F2F;border-bottom:1px solid #f0f0f0;height:28px">'
                                        f'<td>留ㅼ닔</td>'
                                        f'<td style="text-align:right">{bid_s:.4f}</td>'
                                        f'<td style="text-align:right;font-weight:bold">{bid_p:,.0f}</td>'
                                        f'<td style="text-align:right">{diff:+.2f}%</td>'
                                        f'<td><div style="background:#D32F2F;height:12px;width:{bar_w}%;opacity:0.3"></div></td>'
                                        f'</tr>'
                                    )

                                html.append('</table>')
                                st.markdown(''.join(html), unsafe_allow_html=True)

                                # ?? ?멸? ?좏깮 ??二쇰Ц媛 諛섏쁺 (on_change: ?ъ슜???좏깮?쒕쭔 諛섏쁺) ??
                                def _on_ob_select():
                                    """?ъ슜?먭? 吏곸젒 ?좏깮?덉쓣 ?뚮쭔 二쇰Ц媛??諛섏쁺"""
                                    sel_label = st.session_state.get('_ob_sel_label', '')
                                    try:
                                        price_str = sel_label.split(' ', 1)[1].replace(',', '')
                                        chosen = int(float(price_str))
                                        tick = get_tick_size(chosen)
                                        if tick >= 1:
                                            st.session_state['mt_buy_price'] = int(chosen)
                                            st.session_state['mt_sell_price'] = int(chosen)
                                        else:
                                            st.session_state['mt_buy_price'] = float(chosen)
                                            st.session_state['mt_sell_price'] = float(chosen)
                                    except (IndexError, ValueError):
                                        pass

                                price_labels = (
                                    [f"留ㅻ룄 {p:,.0f}" for p in ask_prices] +
                                    [f"留ㅼ닔 {p:,.0f}" for p in bid_prices]
                                )

                                st.selectbox(
                                    "?멸? ?좏깮 ??二쇰Ц媛 諛섏쁺",
                                    price_labels,
                                    index=len(ask_prices),  # 湲곕낯: 理쒖슦??留ㅼ닔?멸?
                                    key="_ob_sel_label",
                                    on_change=_on_ob_select,
                                )

                                best_ask = units[0].get('ask_price', 0)
                                best_bid = units[0].get('bid_price', 0)
                                spread = best_ask - best_bid
                                spread_pct = (spread / best_bid * 100) if best_bid > 0 else 0
                                total_ask = ob.get('total_ask_size', 0)
                                total_bid = ob.get('total_bid_size', 0)
                                ob_ratio = total_bid / (total_ask + total_bid) * 100 if (total_ask + total_bid) > 0 else 50
                                st.caption(f"?ㅽ봽?덈뱶 **{spread:,.0f}** ({spread_pct:.3f}%) | 留ㅻ룄 {total_ask:.2f} | 留ㅼ닔 {total_bid:.2f} | 留ㅼ닔鍮꾩쑉 {ob_ratio:.0f}%")
                            else:
                                st.info("?멸? ?곗씠?곌? ?놁뒿?덈떎.")
                        else:
                            st.info("?멸? ?곗씠?곕? 遺덈윭?????놁뒿?덈떎.")
                    except Exception as e:
                        st.warning(f"?멸? 議고쉶 ?ㅽ뙣: {e}")

                # ?? ?? 李⑦듃 + 二쇰Ц ?⑤꼸 ??
                with right_col:
                    # 30遺꾨큺 李⑦듃 (?곷?)
                    st.markdown("**30遺꾨큺 李⑦듃**")
                    df_30m = _ttl_cache(f"m30_{mt_ticker}", lambda: pyupbit.get_ohlcv(mt_ticker, interval="minute30", count=48), ttl=30)
                    if df_30m is not None and len(df_30m) > 0:
                        fig_30m = make_subplots(rows=2, cols=1, shared_xaxes=True,
                                                row_heights=[0.8, 0.2], vertical_spacing=0.02)
                        fig_30m.add_trace(go.Candlestick(
                            x=df_30m.index, open=df_30m['open'], high=df_30m['high'],
                            low=df_30m['low'], close=df_30m['close'], name='30遺꾨큺',
                            increasing_line_color='#26a69a', decreasing_line_color='#ef5350',
                        ), row=1, col=1)
                        ma5 = df_30m['close'].rolling(5).mean()
                        ma20 = df_30m['close'].rolling(20).mean()
                        fig_30m.add_trace(go.Scatter(x=df_30m.index, y=ma5, name='MA5',
                                                     line=dict(color='#FF9800', width=1)), row=1, col=1)
                        fig_30m.add_trace(go.Scatter(x=df_30m.index, y=ma20, name='MA20',
                                                     line=dict(color='#2196F3', width=1)), row=1, col=1)
                        colors_vol = ['#26a69a' if c >= o else '#ef5350'
                                      for c, o in zip(df_30m['close'], df_30m['open'])]
                        fig_30m.add_trace(go.Bar(x=df_30m.index, y=df_30m['volume'],
                                                 marker_color=colors_vol, name='嫄곕옒??, showlegend=False),
                                          row=2, col=1)
                        fig_30m.update_layout(
                            height=320, margin=dict(l=0, r=0, t=10, b=30),
                            xaxis_rangeslider_visible=False, showlegend=True,
                            legend=dict(orientation="h", y=1.02, x=0),
                            xaxis2=dict(showticklabels=True, tickformat='%H:%M', tickangle=-45),
                            yaxis=dict(title="", side="right"),
                            yaxis2=dict(title="", side="right"),
                        )
                        st.plotly_chart(fig_30m, use_container_width=True, key=f"chart30m_{mt_ticker}")
                    else:
                        st.info("李⑦듃 ?곗씠??濡쒕뵫 以?..")

                    # 二쇰Ц ?⑤꼸 (?섎?)
                    buy_tab, sell_tab = st.tabs(["?뵶 留ㅼ닔", "?뵷 留ㅻ룄"])

                    with buy_tab:
                        buy_type = st.radio("二쇰Ц ?좏삎", ["?쒖옣媛", "吏?뺢?"], horizontal=True, key="mt_buy_type")

                        if buy_type == "?쒖옣媛":
                            buy_amount = st.number_input("留ㅼ닔 湲덉븸 (KRW)", min_value=5000, value=10000, step=1000, key="mt_buy_amt")
                            qb1, qb2, qb3, qb4 = st.columns(4)
                            if qb1.button("10%", key="mt_b10"):
                                st.session_state['mt_buy_amt'] = int(krw_avail * 0.1)
                                st.rerun()
                            if qb2.button("25%", key="mt_b25"):
                                st.session_state['mt_buy_amt'] = int(krw_avail * 0.25)
                                st.rerun()
                            if qb3.button("50%", key="mt_b50"):
                                st.session_state['mt_buy_amt'] = int(krw_avail * 0.5)
                                st.rerun()
                            if qb4.button("100%", key="mt_b100"):
                                st.session_state['mt_buy_amt'] = int(krw_avail * 0.999)
                                st.rerun()

                            if mt_price > 0:
                                st.caption(f"?덉긽 ?섎웾: ~{buy_amount / mt_price:.8f} {mt_coin}")

                            if st.button("?쒖옣媛 留ㅼ닔", type="primary", key="mt_buy_exec", use_container_width=True):
                                if buy_amount < 5000:
                                    st.toast("理쒖냼 二쇰Ц湲덉븸: 5,000 KRW", icon="?좑툘")
                                elif buy_amount > krw_avail:
                                    st.toast(f"?붽퀬 遺議?({krw_avail:,.0f} KRW)", icon="?좑툘")
                                else:
                                    with st.spinner("留ㅼ닔 二쇰Ц 以?.."):
                                        result = trader.buy_market(mt_ticker, buy_amount)
                                    coin_worker.invalidate('krw_bal', 'coin_bal')
                                    if result and "error" not in result:
                                        st.toast(f"???쒖옣媛 留ㅼ닔 泥닿껐! {buy_amount:,.0f} KRW", icon="?윟")
                                        st.session_state['_last_trade'] = {"type": "?쒖옣媛 留ㅼ닔", "ticker": mt_ticker, "amount": f"{buy_amount:,.0f} KRW", "result": result, "time": time.strftime('%H:%M:%S')}
                                    else:
                                        st.toast(f"留ㅼ닔 ?ㅽ뙣: {result}", icon="?뵶")

                        else:  # 吏?뺢?
                            buy_default = align_price(mt_price * 0.99, mt_tick) if mt_price > 0 else 1
                            bc1, bc2 = st.columns(2)
                            if mt_tick >= 1:
                                buy_price = bc1.number_input("留ㅼ닔 媛寃?, min_value=1, value=int(buy_default), step=int(mt_tick), key="mt_buy_price")
                            else:
                                buy_price = bc1.number_input("留ㅼ닔 媛寃?, min_value=0.0001, value=float(buy_default), step=float(mt_tick), format="%.4f", key="mt_buy_price")
                            buy_qty = bc2.number_input("留ㅼ닔 ?섎웾", min_value=mt_min_qty, value=max(mt_min_qty, 0.001), format="%.8f", key="mt_buy_qty")

                            buy_total = buy_price * buy_qty
                            st.caption(f"珥앹븸: **{buy_total:,.0f} KRW** | ?멸?: {mt_tick:,g}??| 理쒖냼: {mt_min_qty:.8f}")

                            qbc1, qbc2, qbc3, qbc4 = st.columns(4)
                            if buy_price > 0:
                                if qbc1.button("10%", key="mt_lb10"):
                                    st.session_state['mt_buy_qty'] = round(krw_avail * 0.1 / buy_price, 8)
                                    st.rerun()
                                if qbc2.button("25%", key="mt_lb25"):
                                    st.session_state['mt_buy_qty'] = round(krw_avail * 0.25 / buy_price, 8)
                                    st.rerun()
                                if qbc3.button("50%", key="mt_lb50"):
                                    st.session_state['mt_buy_qty'] = round(krw_avail * 0.5 / buy_price, 8)
                                    st.rerun()
                                if qbc4.button("100%", key="mt_lb100"):
                                    st.session_state['mt_buy_qty'] = round(krw_avail * 0.999 / buy_price, 8)
                                    st.rerun()

                            if st.button("吏?뺢? 留ㅼ닔", type="primary", key="mt_lbuy_exec", use_container_width=True):
                                if buy_total < 5000:
                                    st.toast("理쒖냼 二쇰Ц湲덉븸: 5,000 KRW", icon="?좑툘")
                                elif buy_total > krw_avail:
                                    st.toast(f"?붽퀬 遺議?({krw_avail:,.0f} KRW)", icon="?좑툘")
                                else:
                                    with st.spinner("吏?뺢? 留ㅼ닔 二쇰Ц 以?.."):
                                        result = trader.buy_limit(mt_ticker, buy_price, buy_qty)
                                    coin_worker.invalidate('krw_bal', 'coin_bal')
                                    if result and "error" not in result:
                                        st.toast(f"??吏?뺢? 留ㅼ닔 ?깅줉! {buy_price:,.0f} 횞 {buy_qty:.8f}", icon="?윟")
                                        st.session_state['_last_trade'] = {"type": "吏?뺢? 留ㅼ닔", "ticker": mt_ticker, "price": f"{buy_price:,.0f}", "qty": f"{buy_qty:.8f}", "result": result, "time": time.strftime('%H:%M:%S')}
                                    else:
                                        st.toast(f"二쇰Ц ?ㅽ뙣: {result}", icon="?뵶")

                    with sell_tab:
                        sell_type = st.radio("二쇰Ц ?좏삎", ["?쒖옣媛", "吏?뺢?"], horizontal=True, key="mt_sell_type")

                        if sell_type == "?쒖옣媛":
                            sell_qty = st.number_input(
                                f"留ㅻ룄 ?섎웾 ({mt_coin})", min_value=0.00000001,
                                value=mt_coin_bal if mt_coin_bal > 0 else 0.00000001,
                                format="%.8f", key="mt_sell_qty"
                            )
                            qs1, qs2, qs3, qs4 = st.columns(4)
                            if qs1.button("25%", key="mt_s25"):
                                st.session_state['mt_sell_qty'] = round(mt_coin_bal * 0.25, 8)
                                st.rerun()
                            if qs2.button("50%", key="mt_s50"):
                                st.session_state['mt_sell_qty'] = round(mt_coin_bal * 0.5, 8)
                                st.rerun()
                            if qs3.button("75%", key="mt_s75"):
                                st.session_state['mt_sell_qty'] = round(mt_coin_bal * 0.75, 8)
                                st.rerun()
                            if qs4.button("100%", key="mt_s100"):
                                st.session_state['mt_sell_qty'] = round(mt_coin_bal, 8)
                                st.rerun()

                            if mt_price > 0:
                                st.caption(f"?덉긽 湲덉븸: ~{sell_qty * mt_price:,.0f} KRW")

                            if st.button("?쒖옣媛 留ㅻ룄", type="primary", key="mt_sell_exec", use_container_width=True):
                                if sell_qty <= 0:
                                    st.toast("留ㅻ룄 ?섎웾???낅젰?댁＜?몄슂.", icon="?좑툘")
                                elif mt_price > 0 and sell_qty * mt_price < 5000:
                                    st.toast(f"理쒖냼 二쇰Ц湲덉븸 誘몃떖 ({sell_qty * mt_price:,.0f} KRW < 5,000)", icon="?좑툘")
                                elif sell_qty > mt_coin_bal:
                                    st.toast(f"蹂댁쑀??珥덇낵 ({mt_coin_bal:.8f})", icon="?좑툘")
                                else:
                                    with st.spinner("留ㅻ룄 二쇰Ц 以?.."):
                                        result = trader.sell_market(mt_ticker, sell_qty)
                                    coin_worker.invalidate('krw_bal', 'coin_bal')
                                    if result and "error" not in result:
                                        st.toast(f"???쒖옣媛 留ㅻ룄 泥닿껐! {sell_qty:.8f} {mt_coin}", icon="?뵶")
                                        st.session_state['_last_trade'] = {"type": "?쒖옣媛 留ㅻ룄", "ticker": mt_ticker, "qty": f"{sell_qty:.8f}", "result": result, "time": time.strftime('%H:%M:%S')}
                                    else:
                                        st.toast(f"留ㅻ룄 ?ㅽ뙣: {result}", icon="?뵶")

                        else:  # 吏?뺢?
                            sell_default = align_price(mt_price * 1.01, mt_tick) if mt_price > 0 else 1
                            sc1, sc2 = st.columns(2)
                            if mt_tick >= 1:
                                sell_price = sc1.number_input("留ㅻ룄 媛寃?, min_value=1, value=int(sell_default), step=int(mt_tick), key="mt_sell_price")
                            else:
                                sell_price = sc1.number_input("留ㅻ룄 媛寃?, min_value=0.0001, value=float(sell_default), step=float(mt_tick), format="%.4f", key="mt_sell_price")
                            sell_default_qty = mt_coin_bal if mt_coin_bal > mt_min_qty else mt_min_qty
                            sell_limit_qty = sc2.number_input("留ㅻ룄 ?섎웾", min_value=mt_min_qty, value=sell_default_qty, format="%.8f", key="mt_sell_lqty")

                            sell_total = sell_price * sell_limit_qty
                            st.caption(f"珥앹븸: **{sell_total:,.0f} KRW** | ?멸?: {mt_tick:,g}??| 理쒖냼: {mt_min_qty:.8f}")

                            qsc1, qsc2, qsc3, qsc4 = st.columns(4)
                            if mt_coin_bal > 0:
                                if qsc1.button("25%", key="mt_ls25"):
                                    st.session_state['mt_sell_lqty'] = round(mt_coin_bal * 0.25, 8)
                                    st.rerun()
                                if qsc2.button("50%", key="mt_ls50"):
                                    st.session_state['mt_sell_lqty'] = round(mt_coin_bal * 0.5, 8)
                                    st.rerun()
                                if qsc3.button("75%", key="mt_ls75"):
                                    st.session_state['mt_sell_lqty'] = round(mt_coin_bal * 0.75, 8)
                                    st.rerun()
                                if qsc4.button("100%", key="mt_ls100"):
                                    st.session_state['mt_sell_lqty'] = round(mt_coin_bal, 8)
                                    st.rerun()

                            if st.button("吏?뺢? 留ㅻ룄", type="primary", key="mt_lsell_exec", use_container_width=True):
                                if sell_limit_qty <= 0:
                                    st.toast("留ㅻ룄 ?섎웾???낅젰?댁＜?몄슂.", icon="?좑툘")
                                elif sell_limit_qty > mt_coin_bal:
                                    st.toast(f"蹂댁쑀??珥덇낵 ({mt_coin_bal:.8f})", icon="?좑툘")
                                else:
                                    with st.spinner("吏?뺢? 留ㅻ룄 二쇰Ц 以?.."):
                                        result = trader.sell_limit(mt_ticker, sell_price, sell_limit_qty)
                                    coin_worker.invalidate('krw_bal', 'coin_bal')
                                    if result and "error" not in result:
                                        st.toast(f"??吏?뺢? 留ㅻ룄 ?깅줉! {sell_price:,.0f} 횞 {sell_limit_qty:.8f}", icon="?뵶")
                                        st.session_state['_last_trade'] = {"type": "吏?뺢? 留ㅻ룄", "ticker": mt_ticker, "price": f"{sell_price:,.0f}", "qty": f"{sell_limit_qty:.8f}", "result": result, "time": time.strftime('%H:%M:%S')}
                                    else:
                                        st.toast(f"二쇰Ц ?ㅽ뙣: {result}", icon="?뵶")

                # ?? 誘몄껜寃?二쇰Ц ??
                st.divider()
                st.subheader("誘몄껜寃?二쇰Ц")
                if st.button("誘몄껜寃?二쇰Ц 議고쉶", key="mt_pending"):
                    with st.spinner("議고쉶 以?.."):
                        pending = trader.get_orders(state="wait")
                    if pending and len(pending) > 0:
                        for i, order in enumerate(pending):
                            side_kr = "留ㅼ닔" if order.get('side') == 'bid' else "留ㅻ룄"
                            side_color = "red" if order.get('side') == 'bid' else "blue"
                            market = order.get('market', '')
                            price = float(order.get('price', 0) or 0)
                            remaining = float(order.get('remaining_volume', 0) or 0)
                            created = order.get('created_at', '')
                            if pd.notna(created):
                                try:
                                    created = pd.to_datetime(created).strftime('%m/%d %H:%M')
                                except:
                                    pass
                            oc1, oc2 = st.columns([4, 1])
                            oc1.markdown(f"**:{side_color}[{side_kr}]** {market} | {price:,.0f} 횞 {remaining:.8f} | {created}")
                            if oc2.button("痍⑥냼", key=f"mt_cancel_{i}"):
                                cancel_result = trader.cancel_order(order.get('uuid'))
                                if cancel_result and "error" not in cancel_result:
                                    st.toast("二쇰Ц 痍⑥냼 ?꾨즺", icon="??)
                                    coin_worker.invalidate('krw_bal', 'coin_bal')
                                    st.rerun()
                                else:
                                    st.toast(f"痍⑥냼 ?ㅽ뙣: {cancel_result}", icon="?뵶")
                    else:
                        st.info("誘몄껜寃?二쇰Ц???놁뒿?덈떎.")

            trading_panel()

    # --- Tab 3: History ---
    with tab3:
        st.header("嫄곕옒 ?댁뿭")

        hist_tab1, hist_tab2, hist_tab3 = st.tabs(["?뮯 ?ㅼ젣 嫄곕옒 ?댁뿭 (嫄곕옒??", "?㎦ 媛??濡쒓렇 (?섏씠??", "?뱤 ?щ━?쇱? 遺꾩꽍"])

        with hist_tab1:
            st.subheader("?ㅼ젣 嫄곕옒 ?댁뿭")

            if not trader:
                st.warning("?ъ씠?쒕컮?먯꽌 API ?ㅻ? ?ㅼ젙?댁＜?몄슂.")
            else:
                c_h1, c_h2 = st.columns(2)
                h_type = c_h1.selectbox("議고쉶 ?좏삎", ["?꾩껜", "?낃툑", "異쒓툑", "泥닿껐 二쇰Ц"])
                h_curr = c_h2.selectbox("?뷀룓", ["?꾩껜", "KRW", "BTC", "ETH", "XRP", "SOL", "USDT", "DOGE", "ADA", "AVAX", "LINK"])

                d_h1, d_h2 = st.columns(2)
                h_date_start = d_h1.date_input("議고쉶 ?쒖옉??, value=datetime.now().date() - timedelta(days=90), key="hist_start")
                h_date_end = d_h2.date_input("議고쉶 醫낅즺??, value=datetime.now().date(), key="hist_end")

                if st.button("議고쉶"):
                    with st.spinner("Upbit API 議고쉶 以?.."):
                        api_curr = None if h_curr == "?꾩껜" else h_curr

                        # ?? 議고쉶 ?좏삎蹂??곗씠???섏쭛 ??
                        def _parse_deposit_withdraw(raw, type_label):
                            """?낃툑/異쒓툑 ?곗씠?곕? ?듯빀 ?щ㎎?쇰줈 蹂??""
                            rows = []
                            for r in raw:
                                done = r.get('done_at', r.get('created_at', ''))
                                if pd.notna(done):
                                    try: done = pd.to_datetime(done).strftime('%Y-%m-%d %H:%M')
                                    except: pass
                                amount = float(r.get('amount', 0))
                                fee_val = float(r.get('fee', 0))
                                state = r.get('state', '')
                                state_kr = {"ACCEPTED": "?꾨즺", "REJECTED": "嫄곕?", "CANCELLED": "痍⑥냼", "PROCESSING": "泥섎━以?, "WAITING": "?湲곗쨷"}.get(state, state)
                                rows.append({
                                    "嫄곕옒?쇱떆": done, "?좏삎": type_label,
                                    "?뷀룓/肄붿씤": r.get('currency', ''),
                                    "援щ텇": type_label,
                                    "湲덉븸/?섎웾": f"{amount:,.4f}" if amount < 100 else f"{amount:,.0f}",
                                    "泥닿껐湲덉븸(KRW)": "-",
                                    "?섏닔猷?: f"{fee_val:,.4f}" if fee_val > 0 else "-",
                                    "?곹깭": state_kr,
                                    "_sort_dt": done,
                                })
                            return rows

                        def _parse_orders(raw):
                            """泥닿껐 二쇰Ц ?곗씠?곕? ?듯빀 ?щ㎎?쇰줈 蹂??""
                            rows = []
                            for r in raw:
                                market = r.get('market', '')
                                coin = market.split('-')[1] if '-' in str(market) else market
                                side = r.get('side', '')
                                side_kr = "留ㅼ닔" if side == 'bid' else ("留ㅻ룄" if side == 'ask' else side)
                                state = r.get('state', '')
                                state_kr = {"done": "泥닿껐?꾨즺", "cancel": "痍⑥냼", "wait": "?湲?}.get(state, state)
                                price = float(r.get('price', 0) or 0)
                                executed_vol = float(r.get('executed_volume', 0) or 0)
                                paid_fee = float(r.get('paid_fee', 0) or 0)
                                if price > 0 and executed_vol > 0:
                                    total_krw = price * executed_vol
                                elif 'trades' in r and r['trades']:
                                    total_krw = sum(float(t.get('funds', 0)) for t in r['trades'])
                                else:
                                    total_krw = price
                                ord_type = r.get('ord_type', '')
                                type_kr = {"limit": "吏?뺢?", "price": "?쒖옣媛(留ㅼ닔)", "market": "?쒖옣媛(留ㅻ룄)"}.get(ord_type, ord_type)
                                created = r.get('created_at', '')
                                if pd.notna(created):
                                    try: created = pd.to_datetime(created).strftime('%Y-%m-%d %H:%M')
                                    except: pass
                                rows.append({
                                    "嫄곕옒?쇱떆": created, "?좏삎": f"泥닿껐({type_kr})",
                                    "?뷀룓/肄붿씤": coin,
                                    "援щ텇": side_kr,
                                    "湲덉븸/?섎웾": f"{executed_vol:,.8f}" if executed_vol < 1 else f"{executed_vol:,.4f}",
                                    "泥닿껐湲덉븸(KRW)": f"{total_krw:,.0f}",
                                    "?섏닔猷?: f"{paid_fee:,.2f}",
                                    "?곹깭": state_kr,
                                    "_sort_dt": created,
                                })
                            return rows

                        api_curr = None if h_curr == "?꾩껜" else h_curr
                        all_rows = []
                        error_msgs = []

                        # 議고쉶 ???寃곗젙
                        query_types = []
                        if h_type == "?꾩껜":
                            query_types = [("deposit", "?낃툑"), ("withdraw", "異쒓툑"), ("order", "泥닿껐")]
                        elif "?낃툑" in h_type:
                            query_types = [("deposit", "?낃툑")]
                        elif "異쒓툑" in h_type:
                            query_types = [("withdraw", "異쒓툑")]
                        elif "泥닿껐" in h_type:
                            query_types = [("order", "泥닿껐")]

                        for api_type, label in query_types:
                            try:
                                data, err = trader.get_history(api_type, api_curr)
                                if err:
                                    error_msgs.append(f"{label}: {err}")
                                if data:
                                    if api_type in ("deposit", "withdraw"):
                                        all_rows.extend(_parse_deposit_withdraw(data, label))
                                    else:
                                        all_rows.extend(_parse_orders(data))
                            except Exception as e:
                                error_msgs.append(f"{label}: {e}")

                        # ?먮윭 ?쒖떆
                        for em in error_msgs:
                            if "out_of_scope" in em or "沅뚰븳" in em:
                                st.error(f"API 沅뚰븳 遺議?({em.split(':')[0]})")
                            else:
                                st.error(f"API ?ㅻ쪟: {em}")
                        if error_msgs and not all_rows:
                            st.info("[?낅퉬??> 留덉씠?섏씠吏 > Open API 愿由??먯꽌 **?먯궛議고쉶**, **?낆텧湲?議고쉶** 沅뚰븳???쒖꽦?뷀빐二쇱꽭??")

                        # ?좎쭨 ?꾪꽣 + ?쒖떆
                        if all_rows:
                            result_df = pd.DataFrame(all_rows)
                            # ?좎쭨 ?꾪꽣留?
                            try:
                                result_df['_dt'] = pd.to_datetime(result_df['_sort_dt'], errors='coerce')
                                mask = (result_df['_dt'].dt.date >= h_date_start) & (result_df['_dt'].dt.date <= h_date_end)
                                result_df = result_df[mask].sort_values('_dt', ascending=False)
                            except Exception:
                                pass
                            result_df = result_df.drop(columns=['_sort_dt', '_dt'], errors='ignore')

                            if len(result_df) > 0:
                                st.success(f"{len(result_df)}嫄?議고쉶??)
                                def _color_side(val):
                                    if val == "留ㅼ닔": return "color: #e74c3c"
                                    elif val == "留ㅻ룄": return "color: #2980b9"
                                    elif val == "?낃툑": return "color: #27ae60"
                                    elif val == "異쒓툑": return "color: #8e44ad"
                                    return ""
                                st.dataframe(
                                    result_df.style.map(_color_side, subset=["援щ텇"]),
                                    use_container_width=True, hide_index=True
                                )
                            else:
                                st.warning("?대떦 湲곌컙???댁뿭???놁뒿?덈떎.")
                        elif not error_msgs:
                            st.warning(f"議고쉶 寃곌낵 ?놁쓬. (?좏삎: {h_type}, ?뷀룓: {h_curr})")
                            st.caption("Upbit API??理쒓렐 ?댁뿭留?諛섑솚?⑸땲?? 議고쉶 ?좏삎??蹂寃쏀빐蹂댁꽭??")

            st.caption("Upbit API ?쒗븳: 理쒓렐 100嫄닿퉴吏 議고쉶 媛??)

        with hist_tab2:
            st.subheader("媛??怨꾩쥖 愿由?)

            if 'virtual_adjustment' not in st.session_state:
                st.session_state.virtual_adjustment = 0

            c1, c2 = st.columns(2)
            amount = c1.number_input("湲덉븸 (KRW)", step=100000)
            if c2.button("?낆텧湲?(媛??"):
                st.session_state.virtual_adjustment += amount
                st.success(f"媛???붽퀬 議곗젙: {amount:,.0f} KRW")

            st.info(f"?꾩쟻 媛??議곗젙?? {st.session_state.virtual_adjustment:,.0f} KRW")

        with hist_tab3:
            st.subheader("?щ━?쇱? 遺꾩꽍 (?ㅼ젣 泥닿껐 vs 諛깊뀒?ㅽ듃)")

            if not trader:
                st.warning("API Key媛 ?꾩슂?⑸땲??")
            else:
                sa_col1, sa_col2 = st.columns(2)
                sa_ticker_list = [f"{r['market']}-{r['coin'].upper()}" for r in portfolio_list]
                sa_ticker = sa_col1.selectbox("肄붿씤 ?좏깮", sa_ticker_list, key="sa_ticker")
                sa_interval = sa_col2.selectbox("?쒓컙遊?, list(INTERVAL_MAP.keys()), key="sa_interval")

                if st.button("?щ━?쇱? 遺꾩꽍", key="sa_run"):
                    with st.spinner("泥닿껐 ?곗씠??議고쉶 以?.."):
                        # 1. ?ㅼ젣 泥닿껐 二쇰Ц 議고쉶
                        done_orders = trader.get_done_orders(sa_ticker)

                        if not done_orders:
                            st.info("泥닿껐 ?꾨즺??二쇰Ц???놁뒿?덈떎.")
                        else:
                            df_orders = pd.DataFrame(done_orders)

                            # ?꾩슂??而щ읆 泥섎━
                            if 'created_at' in df_orders.columns:
                                df_orders['date'] = pd.to_datetime(df_orders['created_at'])
                            if 'price' in df_orders.columns:
                                df_orders['exec_price'] = pd.to_numeric(df_orders['price'], errors='coerce')
                            if 'executed_volume' in df_orders.columns:
                                df_orders['exec_volume'] = pd.to_numeric(df_orders['executed_volume'], errors='coerce')

                            # 2. ?대떦 湲곌컙 OHLCV 議고쉶 ??Open 媛寃⑷낵 鍮꾧탳
                            api_interval = INTERVAL_MAP.get(sa_interval, "day")
                            df_ohlcv = pyupbit.get_ohlcv(sa_ticker, interval=api_interval, count=200)

                            if df_ohlcv is not None and 'date' in df_orders.columns and 'exec_price' in df_orders.columns:
                                # ?좎쭨蹂?Open 媛寃?留ㅽ븨
                                df_ohlcv['open_price'] = df_ohlcv['open']

                                slip_data = []
                                for _, order in df_orders.iterrows():
                                    order_date = order.get('date')
                                    exec_price = order.get('exec_price', 0)
                                    side = order.get('side', '')

                                    if pd.isna(order_date) or exec_price == 0:
                                        continue

                                    # 媛??媛源뚯슫 罹붾뱾??Open 媛寃?李얘린
                                    if df_ohlcv.index.tz is not None and order_date.tzinfo is None:
                                        order_date = order_date.tz_localize(df_ohlcv.index.tz)

                                    idx = df_ohlcv.index.searchsorted(order_date)
                                    if idx < len(df_ohlcv):
                                        candle_open = df_ohlcv.iloc[idx]['open']
                                        slippage_pct = (exec_price - candle_open) / candle_open * 100
                                        if side == 'ask':  # 留ㅻ룄
                                            slippage_pct = -slippage_pct

                                        slip_data.append({
                                            'date': order_date,
                                            'side': 'BUY' if side == 'bid' else 'SELL',
                                            'exec_price': exec_price,
                                            'candle_open': candle_open,
                                            'slippage_pct': slippage_pct,
                                            'volume': order.get('exec_volume', 0)
                                        })

                                if slip_data:
                                    df_slip = pd.DataFrame(slip_data)

                                    # ?붿빟 ?듦퀎
                                    avg_slip = df_slip['slippage_pct'].mean()
                                    max_slip = df_slip['slippage_pct'].max()
                                    min_slip = df_slip['slippage_pct'].min()

                                    sc1, sc2, sc3, sc4 = st.columns(4)
                                    sc1.metric("?됯퇏 ?щ━?쇱?", f"{avg_slip:.3f}%")
                                    sc2.metric("理쒕? (遺덈━)", f"{max_slip:.3f}%")
                                    sc3.metric("理쒖냼 (?좊━)", f"{min_slip:.3f}%")
                                    sc4.metric("嫄곕옒 ??, f"{len(df_slip)}嫄?)

                                    # 留ㅼ닔/留ㅻ룄 遺꾨━ ?듦퀎
                                    buy_slip = df_slip[df_slip['side'] == 'BUY']
                                    sell_slip = df_slip[df_slip['side'] == 'SELL']

                                    if not buy_slip.empty:
                                        st.caption(f"留ㅼ닔 ?됯퇏 ?щ━?쇱?: {buy_slip['slippage_pct'].mean():.3f}% ({len(buy_slip)}嫄?")
                                    if not sell_slip.empty:
                                        st.caption(f"留ㅻ룄 ?됯퇏 ?щ━?쇱?: {sell_slip['slippage_pct'].mean():.3f}% ({len(sell_slip)}嫄?")

                                    # 李⑦듃
                                    fig_slip = go.Figure()
                                    fig_slip.add_trace(go.Bar(
                                        x=df_slip['date'], y=df_slip['slippage_pct'],
                                        marker_color=['red' if s > 0 else 'green' for s in df_slip['slippage_pct']],
                                        name='?щ━?쇱? %'
                                    ))
                                    fig_slip.add_hline(y=avg_slip, line_dash="dash", line_color="blue",
                                                       annotation_text=f"Avg: {avg_slip:.3f}%")
                                    fig_slip.update_layout(title="嫄곕옒 ?щ━?쇱? (+ = 遺덈━)", height=350, margin=dict(t=80),
                                        legend=dict(orientation="h", yanchor="bottom", y=1.02, xanchor="left", x=0))
                                    st.plotly_chart(fig_slip, use_container_width=True)

                                    # ?곸꽭 ?뚯씠釉?
                                    st.dataframe(
                                        df_slip.style.format({
                                            'exec_price': '{:,.0f}',
                                            'candle_open': '{:,.0f}',
                                            'slippage_pct': '{:.3f}%',
                                            'volume': '{:.6f}'
                                        }).background_gradient(cmap='RdYlGn_r', subset=['slippage_pct']),
                                        use_container_width=True
                                    )

                                    st.info(
                                        f"沅뚯옣 諛깊뀒?ㅽ듃 ?щ━?쇱?: **{abs(avg_slip):.2f}%** "
                                        f"(?ㅼ젣 ?됯퇏 湲곕컲, 諛깊뀒?ㅽ듃 ??뿉???ㅼ젙)"
                                    )
                                else:
                                    st.info("留ㅼ묶 媛?ν븳 泥닿껐-罹붾뱾 ?곗씠?곌? ?놁뒿?덈떎.")
                            else:
                                st.dataframe(df_orders)
                                st.caption("OHLCV 留ㅼ묶 遺덇? - ?먮낯 二쇰Ц ?곗씠???쒖떆")

    # --- Tab 4: 諛깊뀒?ㅽ듃 ---
    with tab4:
        bt_sub1, bt_sub2, bt_sub5, bt_sub4, bt_sub3 = st.tabs(["?뱢 媛쒕퀎 諛깊뀒?ㅽ듃", "?썱截??뚮씪誘명꽣 理쒖쟻??, "?뱤 遺꾩꽍", "?봽 蹂댁“ ?꾨왂 (??텛??", "?뱻 ?꾩껜 醫낅ぉ ?ㅼ틪"])

        # === ?쒕툕??: 媛쒕퀎 諛깊뀒?ㅽ듃 ===
        with bt_sub1:
            st.header("媛쒕퀎 ?먯궛 諛깊뀒?ㅽ듃")

            port_tickers_bt = [f"{r['market']}-{r['coin'].upper()}" for r in portfolio_list]
            base_options_bt = list(dict.fromkeys(port_tickers_bt + TOP_20_TICKERS))

            selected_ticker_bt = st.selectbox("諛깊뀒?ㅽ듃 ???, base_options_bt + ["吏곸젒?낅젰"], key="bt_target")

            bt_ticker = ""
            bt_sma = 0
            bt_buy_period = 20
            bt_sell_period = 10

            if selected_ticker_bt == "吏곸젒?낅젰":
                bt_custom = st.text_input("肄붿씤", "BTC", key="bt_c")
                bt_ticker = f"KRW-{bt_custom.upper()}"
            else:
                bt_ticker = selected_ticker_bt

            port_match = next((item for item in portfolio_list if f"{item['market']}-{item['coin'].upper()}" == bt_ticker), None)

            default_strat_idx = 0
            if port_match and port_match.get('strategy') == 'Donchian':
                default_strat_idx = 1

            bt_strategy = st.selectbox("?꾨왂 ?좏깮", ["SMA ?꾨왂", "?덊궎???꾨왂"], index=default_strat_idx, key="bt_strategy_sel")

            # 湲곕낯媛?珥덇린??(?꾨왂???곕씪 ??뼱?)
            bt_sma = 60
            bt_buy_period = 20
            bt_sell_period = 10
            bt_sell_mode = "?섎떒??(Lower)"  # SMA?????ъ슜 ???섏?留?undefined 諛⑹?

            if bt_strategy == "SMA ?꾨왂":
                default_sma = port_match.get('parameter', 60) if port_match else 60
                bt_sma = st.number_input("?④린 SMA (異붿꽭)", value=default_sma, key="bt_sma_select", min_value=5, step=1)
            else:
                default_buy = int(port_match.get('parameter', 20)) if port_match and port_match.get('strategy') == 'Donchian' else 20
                default_sell = int(port_match.get('sell_parameter', 10)) if port_match and port_match.get('strategy') == 'Donchian' else 10
                if default_sell == 0:
                    default_sell = max(5, default_buy // 2)
                dc_col1, dc_col2 = st.columns(2)
                with dc_col1:
                    bt_buy_period = st.number_input("留ㅼ닔 梨꾨꼸 湲곌컙", value=default_buy, min_value=5, max_value=300, step=1, key="bt_dc_buy")
                with dc_col2:
                    bt_sell_period = st.number_input("留ㅻ룄 梨꾨꼸 湲곌컙", value=default_sell, min_value=5, max_value=300, step=1, key="bt_dc_sell")

                st.divider()
                st.caption("?뱦 留ㅻ룄 湲곗? ?좏깮")
                bt_sell_mode = st.radio(
                    "留ㅻ룄 ?쇱씤",
                    ["?섎떒??(Lower)", "以묒떖??(Midline)", "??諛⑸쾿 鍮꾧탳"],
                    horizontal=True,
                    key="bt_sell_mode",
                    help="?섎떒?? ?媛 梨꾨꼸 ?댄깉 ??留ㅻ룄 / 以묒떖?? (?곷떒+?섎떒)/2 ?댄깉 ??留ㅻ룄"
                )

            default_interval_idx = 0
            if port_match:
                port_iv_label = INTERVAL_REV_MAP.get(port_match.get('interval', 'day'), '?쇰큺')
                interval_keys = list(INTERVAL_MAP.keys())
                if port_iv_label in interval_keys:
                    default_interval_idx = interval_keys.index(port_iv_label)

            bt_interval_label = st.selectbox("?쒓컙遊??좏깮", options=list(INTERVAL_MAP.keys()), index=default_interval_idx, key="bt_interval_sel")
            bt_interval = INTERVAL_MAP[bt_interval_label]

            DEFAULT_SLIPPAGE = {
                "major": {"day": 0.03, "minute240": 0.05, "minute60": 0.08, "minute30": 0.08, "minute15": 0.10, "minute5": 0.15, "minute1": 0.20},
                "mid":   {"day": 0.05, "minute240": 0.08, "minute60": 0.10, "minute30": 0.10, "minute15": 0.15, "minute5": 0.20, "minute1": 0.30},
                "alt":   {"day": 0.10, "minute240": 0.15, "minute60": 0.20, "minute30": 0.20, "minute15": 0.25, "minute5": 0.35, "minute1": 0.50},
            }
            MAJOR_COINS = {"BTC", "ETH"}
            MID_COINS = {"XRP", "SOL", "DOGE", "ADA", "TRX", "AVAX", "LINK", "BCH", "DOT", "ETC"}

            def get_default_slippage(ticker, interval):
                coin = ticker.split("-")[-1].upper() if "-" in ticker else ticker.upper()
                if coin in MAJOR_COINS:
                    tier = "major"
                elif coin in MID_COINS:
                    tier = "mid"
                else:
                    tier = "alt"
                return DEFAULT_SLIPPAGE[tier].get(interval, 0.10)

            default_slip = get_default_slippage(bt_ticker, bt_interval)

            col1, col2 = st.columns([1, 3])
            with col1:
                st.caption("諛깊뀒?ㅽ듃 湲곌컙")
                d_col1, d_col2 = st.columns(2)
                try:
                    default_start_bt = datetime(2020, 1, 1).date()
                except:
                    default_start_bt = datetime.now().date() - timedelta(days=365)
                default_end_bt = datetime.now().date()

                bt_start = d_col1.date_input("?쒖옉??, value=default_start_bt, max_value=datetime.now().date(), format="YYYY.MM.DD", key="bt_start")
                bt_end = d_col2.date_input("醫낅즺??, value=default_end_bt, max_value=datetime.now().date(), format="YYYY.MM.DD", key="bt_end")

                if bt_start > bt_end:
                    st.error("?쒖옉?쇱? 醫낅즺?쇰낫??鍮⑤씪???⑸땲??")
                    bt_end = bt_start

                days_diff = (bt_end - bt_start).days
                st.caption(f"湲곌컙: {days_diff}??)

                fee = st.number_input("留ㅻℓ ?섏닔猷?(%)", value=0.05, format="%.2f", key="bt_fee") / 100
                bt_slippage = st.number_input("?щ━?쇱? (%)", value=default_slip, min_value=0.0, max_value=2.0, step=0.01, format="%.2f", key="bt_slip")

                fee_pct = fee * 100
                cost_per_trade = fee_pct + bt_slippage
                cost_round_trip = (fee_pct * 2) + (bt_slippage * 2)
                st.caption(f"?몃룄: {cost_per_trade:.2f}% | ?뺣났: {cost_round_trip:.2f}%")

                run_btn = st.button("諛깊뀒?ㅽ듃 ?ㅽ뻾", type="primary", key="bt_run")

            if run_btn:
                if bt_strategy == "?덊궎???꾨왂":
                    req_period = max(bt_buy_period, bt_sell_period)
                    bt_strategy_mode = "Donchian"
                    bt_sell_ratio = bt_sell_period / bt_buy_period if bt_buy_period > 0 else 0.5
                    # 留ㅻ룄諛⑹떇 ?뚯떛
                    _smode_raw = bt_sell_mode if bt_strategy == "?덊궎???꾨왂" else "?섎떒??(Lower)"
                    _compare_mode = _smode_raw == "??諛⑸쾿 鍮꾧탳"
                    _sell_mode_api = "midline" if _smode_raw == "以묒떖??(Midline)" else "lower"
                else:
                    req_period = bt_sma
                    bt_strategy_mode = "SMA ?꾨왂"
                    bt_sell_ratio = 0.5
                    _compare_mode = False
                    _sell_mode_api = "lower"

                to_date = bt_end + timedelta(days=1)
                to_str = to_date.strftime("%Y-%m-%d 09:00:00")
                cpd = CANDLES_PER_DAY.get(bt_interval, 1)
                req_count = days_diff * cpd + req_period + 300
                fetch_count = max(req_count, req_period + 300)

                bt_progress = st.progress(0, text=f"諛깊뀒?ㅽ듃 以鍮?以?({bt_start} ~ {bt_end})")

                def _make_bt_progress_cb(start_p, end_p, prefix):
                    def _cb(cur, total, msg):
                        _t = max(int(total), 1)
                        _r = min(max(float(cur) / float(_t), 0.0), 1.0)
                        _p = min(max(start_p + (end_p - start_p) * _r, 0.0), 1.0)
                        bt_progress.progress(_p, text=f"{prefix} {msg}")
                    return _cb

                bt_progress.progress(0.05, text="罹붾뱾 ?곗씠??議고쉶 以?..")
                df_bt = data_cache.get_ohlcv_cached(bt_ticker, interval=bt_interval, to=to_str, count=fetch_count)
                if df_bt is None or len(df_bt) == 0:
                    bt_progress.progress(1.0, text="諛깊뀒?ㅽ듃 ?ㅽ뙣: ?곗씠??議고쉶 ?ㅽ뙣")
                    st.error("?곗씠?곕? 媛?몄삱 ???놁뒿?덈떎.")
                    st.stop()

                bt_progress.progress(0.20, text="罹붾뱾 ?곗씠??議고쉶 ?꾨즺")
                st.caption(f"議고쉶??罹붾뱾: {len(df_bt)}媛?({df_bt.index[0].strftime('%Y-%m-%d')} ~ {df_bt.index[-1].strftime('%Y-%m-%d')})")

                result = backtest_engine.run_backtest(
                    bt_ticker, period=bt_buy_period if bt_strategy_mode == "Donchian" else bt_sma,
                    interval=bt_interval, count=fetch_count, fee=fee,
                    start_date=bt_start, initial_balance=initial_cap, df=df_bt,
                    strategy_mode=bt_strategy_mode, sell_period_ratio=bt_sell_ratio, slippage=bt_slippage,
                    sell_mode="lower" if _compare_mode else _sell_mode_api,
                    progress_callback=_make_bt_progress_cb(0.20, 0.75, "[硫붿씤]"),
                )
                # 鍮꾧탳 紐⑤뱶: 以묒떖??寃곌낵???ㅽ뻾
                if _compare_mode and bt_strategy_mode == "Donchian":
                    result_mid = backtest_engine.run_backtest(
                        bt_ticker, period=bt_buy_period,
                        interval=bt_interval, count=fetch_count, fee=fee,
                        start_date=bt_start, initial_balance=initial_cap, df=df_bt,
                        strategy_mode=bt_strategy_mode, sell_period_ratio=bt_sell_ratio, slippage=bt_slippage,
                        sell_mode="midline",
                        progress_callback=_make_bt_progress_cb(0.75, 0.88, "[以묒떖??鍮꾧탳]"),
                    )
                else:
                    result_mid = None

                if "error" in result:
                    bt_progress.progress(1.0, text="諛깊뀒?ㅽ듃 ?ㅽ뙣")
                    st.error(result["error"])
                else:
                    bt_progress.progress(0.90, text="寃곌낵 ?뺣━ 以?..")
                    df = result["df"]
                    res = result["performance"]
                    # 遺꾩꽍 ??슜 ?몄뀡 ???
                    _eq_arr = result.get("equity_curve", [])
                    if len(_eq_arr) > 1:
                        _eq_s = pd.Series(_eq_arr, index=df.index[-len(_eq_arr):])
                        _daily_ret = _eq_s.pct_change().dropna().values
                        st.session_state['coin_analysis_data'] = {
                            "label": f"{bt_ticker} {bt_strategy_mode}",
                            "equity_series": _eq_s,
                            "daily_returns": _daily_ret,
                            "trades": res.get("trades", []),
                            "initial_cap": initial_cap,
                            "performance": res,
                        }
                    if True:

                        # ?? 鍮꾧탳 ?붿빟 ?뚯씠釉?(鍮꾧탳紐⑤뱶) ??
                        if _compare_mode and result_mid and "error" not in result_mid:
                            res_mid = result_mid["performance"]
                            st.subheader("?뱤 ?섎떒??vs 以묒떖??鍮꾧탳")
                            cmp_data = {
                                "??ぉ": ["珥??섏씡瑜?, "CAGR", "MDD", "?ㅽ봽鍮꾩쑉", "?밸쪧", "嫄곕옒 ?잛닔", "理쒖쥌 ?먯궛"],
                                f"?섎떒??Lower({bt_sell_period})": [
                                    f"{res['total_return']:,.2f}%",
                                    f"{res.get('cagr', 0):,.2f}%",
                                    f"{res['mdd']:,.2f}%",
                                    f"{res.get('sharpe', 0):.2f}",
                                    f"{res['win_rate']:,.2f}%",
                                    f"{res['trade_count']}??,
                                    f"{res['final_equity']:,.0f} KRW",
                                ],
                                f"以묒떖??Midline": [
                                    f"{res_mid['total_return']:,.2f}%",
                                    f"{res_mid.get('cagr', 0):,.2f}%",
                                    f"{res_mid['mdd']:,.2f}%",
                                    f"{res_mid.get('sharpe', 0):.2f}",
                                    f"{res_mid['win_rate']:,.2f}%",
                                    f"{res_mid['trade_count']}??,
                                    f"{res_mid['final_equity']:,.0f} KRW",
                                ],
                            }
                            st.dataframe(pd.DataFrame(cmp_data).set_index("??ぉ"), use_container_width=True)

                            # ?뱀옄 ?쒖떆
                            if res['total_return'] > res_mid['total_return']:
                                st.success(f"???섎떒??Lower) 諛⑹떇???섏씡瑜?{res['total_return']:.2f}% vs {res_mid['total_return']:.2f}% 濡??곗닔")
                            elif res_mid['total_return'] > res['total_return']:
                                st.success(f"??以묒떖??Midline) 諛⑹떇???섏씡瑜?{res_mid['total_return']:.2f}% vs {res['total_return']:.2f}% 濡??곗닔")
                            else:
                                st.info("??諛⑹떇???섏씡瑜좎씠 ?숈씪?⑸땲??")
                            st.divider()

                        sell_mode_label = "以묒떖??Midline)" if _sell_mode_api == "midline" and not _compare_mode else ("?섎떒??Lower)" if not _compare_mode else "?섎떒??Lower) [湲곗?]")
                        if not _compare_mode:
                            st.caption(f"留ㅻ룄諛⑹떇: **{sell_mode_label}**")

                        m1, m2, m3, m4, m5, m6 = st.columns(6)
                        m1.metric("珥??섏씡瑜?, f"{res['total_return']:,.2f}%")
                        m2.metric("?고룊洹?CAGR)", f"{res.get('cagr', 0):,.2f}%")
                        m3.metric("?밸쪧", f"{res['win_rate']:,.2f}%")
                        m4.metric("理쒕??숉룺(MDD)", f"{res['mdd']:,.2f}%")
                        m5.metric("?고룊洹쟋DD", f"{res.get('avg_yearly_mdd', res['mdd']):,.2f}%")
                        m6.metric("?ㅽ봽鍮꾩쑉", f"{res['sharpe']:.2f}")

                        trade_count = res['trade_count']
                        total_cost_pct = cost_round_trip * trade_count
                        st.success(
                            f"理쒖쥌 ?붽퀬: **{res['final_equity']:,.0f} KRW** (珥덇린 {initial_cap:,.0f} KRW) | "
                            f"嫄곕옒 {trade_count}??| ?뺣났鍮꾩슜 {cost_round_trip:.2f}% | ?꾩쟻 ??{total_cost_pct:.1f}%"
                        )

                        if bt_slippage > 0:
                            result_no_slip = backtest_engine.run_backtest(
                                bt_ticker, period=bt_buy_period if bt_strategy_mode == "Donchian" else bt_sma,
                                interval=bt_interval, count=fetch_count, fee=fee,
                                start_date=bt_start, initial_balance=initial_cap, df=df_bt,
                                strategy_mode=bt_strategy_mode, sell_period_ratio=bt_sell_ratio, slippage=0.0,
                                progress_callback=_make_bt_progress_cb(0.90, 0.97, "[?щ━?쇱? 鍮꾧탳]"),
                            )
                            if "error" not in result_no_slip:
                                res_ns = result_no_slip['performance']
                                slip_ret_diff = res_ns['total_return'] - res['total_return']
                                slip_cost = res_ns['final_equity'] - res['final_equity']
                                st.info(f"?щ━?쇱? ?곹뼢: ?섏씡瑜?李⑥씠 **{slip_ret_diff:,.2f}%p**, 湲덉븸 李⑥씠 **{slip_cost:,.0f} KRW**")

                        st.subheader("媛寃?& ?꾨왂 ?깃낵")
                        fig = make_subplots(rows=2, cols=1, shared_xaxes=True, vertical_spacing=0.03,
                            row_heights=[0.7, 0.3], specs=[[{"secondary_y": True}], [{"secondary_y": False}]])

                        fig.add_trace(go.Candlestick(x=df.index, open=df['open'], high=df['high'],
                            low=df['low'], close=df['close'], name='媛寃?), row=1, col=1, secondary_y=False)

                        if bt_strategy_mode == "Donchian":
                            upper_col = f'Donchian_Upper_{bt_buy_period}'
                            lower_col = f'Donchian_Lower_{bt_sell_period}'
                            if upper_col in df.columns:
                                fig.add_trace(go.Scatter(x=df.index, y=df[upper_col], line=dict(color='green', width=1.5, dash='dash'), name=f'?곷떒 ({bt_buy_period})'), row=1, col=1, secondary_y=False)
                            if lower_col in df.columns:
                                fig.add_trace(go.Scatter(x=df.index, y=df[lower_col], line=dict(color='red', width=1.5, dash='dash'), name=f'?섎떒 ({bt_sell_period})'), row=1, col=1, secondary_y=False)
                        else:
                            fig.add_trace(go.Scatter(x=df.index, y=df[f'SMA_{bt_sma}'], line=dict(color='orange', width=2), name=f'SMA {bt_sma}'), row=1, col=1, secondary_y=False)

                        fig.add_trace(go.Scatter(x=df.index, y=df['equity'], line=dict(color='blue', width=2), name='?꾨왂 ?먯궛'), row=1, col=1, secondary_y=True)

                        buy_dates = [t['date'] for t in res['trades'] if t['type'] == 'buy']
                        buy_prices = [t['price'] for t in res['trades'] if t['type'] == 'buy']
                        sell_dates = [t['date'] for t in res['trades'] if t['type'] == 'sell']
                        sell_prices = [t['price'] for t in res['trades'] if t['type'] == 'sell']
                        if buy_dates:
                            fig.add_trace(go.Scatter(x=buy_dates, y=buy_prices, mode='markers', marker=dict(symbol='triangle-up', size=12, color='green'), name='留ㅼ닔'), row=1, col=1, secondary_y=False)
                        if sell_dates:
                            fig.add_trace(go.Scatter(x=sell_dates, y=sell_prices, mode='markers', marker=dict(symbol='triangle-down', size=12, color='red'), name='留ㅻ룄'), row=1, col=1, secondary_y=False)

                        fig.add_trace(go.Scatter(x=df.index, y=df['drawdown'], name='?숉룺 (%)', fill='tozeroy', line=dict(color='red', width=1)), row=2, col=1)
                        fig.update_layout(height=800, title_text="諛깊뀒?ㅽ듃 寃곌낵", xaxis_rangeslider_visible=False, margin=dict(t=80),
                            legend=dict(orientation="h", yanchor="bottom", y=1.02, xanchor="left", x=0))
                        fig.update_yaxes(title_text="媛寃?(KRW)", row=1, col=1, secondary_y=False)
                        fig.update_yaxes(title_text="?먯궛 (KRW)", row=1, col=1, secondary_y=True)
                        fig.update_yaxes(title_text="?숉룺 (%)", row=2, col=1)
                        st.plotly_chart(fig, use_container_width=True)

                        if 'yearly_stats' in res:
                            st.subheader("?곕룄蹂??깃낵")
                            _ys = res['yearly_stats'].copy()
                            _ys.index = _ys.index.astype(str)
                            _avg_row = pd.DataFrame(
                                {"Return (%)": [_ys["Return (%)"].mean()], "MDD (%)": [_ys["MDD (%)"].mean()]},
                                index=["?됯퇏"]
                            )
                            _ys = pd.concat([_ys, _avg_row])
                            st.dataframe(_ys.style.format("{:.2f}%"))

                        st.info(f"?꾨왂 ?곹깭: **{res['final_status']}** | ?ㅼ쓬 ?됰룞: **{res['next_action'] if res['next_action'] else '?놁쓬'}**")

                        with st.expander("嫄곕옒 ?댁뿭"):
                            if res['trades']:
                                trades_df = pd.DataFrame(res['trades'])
                                st.dataframe(trades_df.style.format({"price": "{:,.2f}", "amount": "{:,.6f}", "balance": "{:,.2f}", "profit": "{:,.2f}%"}))
                            else:
                                st.info("?ㅽ뻾??嫄곕옒媛 ?놁뒿?덈떎.")

                        csv_data = df.to_csv(index=True).encode('utf-8')
                        st.download_button(label="?쇰퀎 濡쒓렇 ?ㅼ슫濡쒕뱶", data=csv_data, file_name=f"{bt_ticker}_{bt_start}_daily_log.csv", mime="text/csv")
                        bt_progress.progress(1.0, text="諛깊뀒?ㅽ듃 ?꾨즺")

        # === ?쒕툕??: ?뚮씪誘명꽣 理쒖쟻??===
        with bt_sub2:
            st.header("?뚮씪誘명꽣 理쒖쟻??)

            with st.expander("?곗씠??罹먯떆 愿由?, expanded=False):
                cache_list = data_cache.list_cache()
                if cache_list:
                    st.dataframe(pd.DataFrame(cache_list), use_container_width=True, hide_index=True)
                else:
                    st.info("罹먯떆???곗씠?곌? ?놁뒿?덈떎.")

                if st.button("罹먯떆 ?꾩껜 ??젣", key="opt_clear_cache"):
                    data_cache.clear_cache()
                    st.success("罹먯떆媛 ??젣?섏뿀?듬땲??")
                    st.rerun()

            # 理쒖쟻??????ㅼ젙
            opt_port_tickers = [f"{r['market']}-{r['coin'].upper()}" for r in portfolio_list]
            opt_base_options = list(dict.fromkeys(opt_port_tickers + TOP_20_TICKERS))
            opt_ticker_sel = st.selectbox("理쒖쟻?????, opt_base_options, key="opt_ticker")
            opt_strategy_sel = st.selectbox("?꾨왂", ["SMA ?꾨왂", "?덊궎???꾨왂"], key="opt_strat_sel")

            with st.form("optimization_form"):
                opt_method = st.radio("理쒖쟻??諛⑸쾿", ["Grid Search (?꾩닔 ?먯깋)", "Optuna (踰좎씠吏??理쒖쟻??"], horizontal=True, key="opt_method")
                use_optuna = "Optuna" in opt_method

                opt_interval_label = st.selectbox("?쒓컙遊?, options=list(INTERVAL_MAP.keys()), index=0, key="opt_interval_sel")
                opt_interval = INTERVAL_MAP[opt_interval_label]

                if opt_strategy_sel == "?덊궎???꾨왂":
                    st.caption("?덉튂??梨꾨꼸??留ㅼ닔/留ㅻ룄 湲곌컙??理쒖쟻?뷀빀?덈떎.")
                    st.markdown("##### 留ㅼ닔 梨꾨꼸 湲곌컙")
                    oc1, oc2, oc3 = st.columns(3)
                    opt_buy_start = oc1.number_input("?쒖옉", 5, 200, 10, key="opt_dc_buy_start")
                    opt_buy_end = oc2.number_input("??, 5, 200, 60, key="opt_dc_buy_end")
                    opt_buy_step = oc3.number_input("媛꾧꺽", 1, 50, 5, key="opt_dc_buy_step")
                    st.markdown("##### 留ㅻ룄 梨꾨꼸 湲곌컙")
                    oc4, oc5, oc6 = st.columns(3)
                    opt_sell_start = oc4.number_input("?쒖옉", 5, 200, 5, key="opt_dc_sell_start")
                    opt_sell_end = oc5.number_input("??, 5, 200, 30, key="opt_dc_sell_end")
                    opt_sell_step = oc6.number_input("媛꾧꺽", 1, 50, 5, key="opt_dc_sell_step")
                    st.markdown("##### 留ㅻ룄 諛⑹떇")
                    st.caption("?섎떒?? ?媛 梨꾨꼸 ?댄깉 ??留ㅻ룄 | 以묒떖?? (?곷떒+?섎떒)/2 ?댄깉 ??留ㅻ룄")
                    opt_dc_sell_mode = st.radio(
                        "留ㅻ룄 ?쇱씤",
                        ["?섎떒??(Lower)", "以묒떖??(Midline)", "??諛⑸쾿 鍮꾧탳"],
                        horizontal=True,
                        key="opt_dc_sell_mode",
                    )
                else:
                    st.caption("SMA ?대룞?됯퇏 湲곌컙??理쒖쟻?뷀빀?덈떎.")
                    st.markdown("##### SMA 湲곌컙")
                    oc1, oc2, oc3 = st.columns(3)
                    opt_s_start = oc1.number_input("?쒖옉", 5, 200, 20, key="opt_s_start")
                    opt_s_end = oc2.number_input("??, 5, 200, 60, key="opt_s_end")
                    opt_s_step = oc3.number_input("媛꾧꺽", 1, 50, 5, key="opt_s_step")

                if use_optuna:
                    st.divider()
                    st.markdown("##### Optuna ?ㅼ젙")
                    opc1, opc2 = st.columns(2)
                    optuna_n_trials = opc1.number_input("?먯깋 ?잛닔", 50, 2000, 200, step=50, key="optuna_trials")
                    optuna_objective = opc2.selectbox("紐⑹쟻?⑥닔", ["Calmar (CAGR/|MDD|)", "Sharpe", "?섏씡瑜?(Return)", "MDD 理쒖냼"], key="optuna_obj")

                # 湲곌컙 ?ㅼ젙
                st.divider()
                opt_d1, opt_d2 = st.columns(2)
                opt_start = opt_d1.date_input("?쒖옉??, value=datetime(2020, 1, 1).date(), key="opt_start_date")
                opt_end = opt_d2.date_input("醫낅즺??, value=datetime.now().date(), key="opt_end_date")
                opt_fee = st.number_input("?섏닔猷?(%)", value=0.05, format="%.2f", key="opt_fee") / 100
                opt_slippage = st.number_input("?щ━?쇱? (%)", value=0.05, min_value=0.0, max_value=2.0, step=0.01, format="%.2f", key="opt_slippage")

                opt_submitted = st.form_submit_button("理쒖쟻???쒖옉", type="primary")

            # opt_dc_sell_mode媛 form ?몃??먯꽌??李몄“?섏? ?딅룄濡?湲곕낯媛??명똿
            if opt_strategy_sel != "?덊궎???꾨왂":
                opt_dc_sell_mode = "?섎떒??(Lower)"

            if opt_submitted:
                import plotly.express as px
                opt_results = []
                opt_days_diff = (opt_end - opt_start).days

                with st.status("理쒖쟻??吏꾪뻾 以?..", expanded=True) as status:
                    progress_bar = st.progress(0)
                    log_area = st.empty()

                    try:
                        import time as _time
                        opt_cpd = CANDLES_PER_DAY.get(opt_interval, 1)
                        to_str_opt = (opt_end + timedelta(days=1)).strftime("%Y-%m-%d 09:00:00")

                        if opt_strategy_sel == "?덊궎???꾨왂":
                            buy_range = range(opt_buy_start, opt_buy_end + 1, opt_buy_step)
                            sell_range = range(opt_sell_start, opt_sell_end + 1, opt_sell_step)
                            total_iter = len(buy_range) * len(sell_range)
                            max_req_p = max(opt_buy_end, opt_sell_end)
                            fetch_count_opt = opt_days_diff * opt_cpd + max_req_p + 300
                        else:
                            sma_range = range(opt_s_start, opt_s_end + 1, opt_s_step)
                            total_iter = len(sma_range)
                            fetch_count_opt = opt_days_diff * opt_cpd + opt_s_end + 300

                        def dl_progress(fetched, total):
                            pct = min(fetched / total, 1.0) if total > 0 else 0
                            progress_bar.progress(pct * 0.3)
                            log_area.text(f"?ㅼ슫濡쒕뱶: {fetched:,}/{total:,} candles ({pct*100:.0f}%)")

                        t0 = _time.time()
                        full_df = data_cache.get_ohlcv_cached(opt_ticker_sel, interval=opt_interval, to=to_str_opt, count=fetch_count_opt, progress_callback=dl_progress)
                        dl_elapsed = _time.time() - t0

                        if full_df is None or full_df.empty:
                            status.update(label="?곗씠??濡쒕뱶 ?ㅽ뙣", state="error")
                        else:
                            st.write(f"?곗씠??以鍮? {len(full_df):,} candles ({dl_elapsed:.1f}珥?")

                            def opt_progress(idx, total, msg):
                                pct = 0.3 + (idx / total) * 0.7
                                progress_bar.progress(min(pct, 1.0))
                                log_area.text(f"{msg} ({idx}/{total})")

                            t1 = _time.time()
                            optuna_result = None

                            if use_optuna:
                                obj_map = {"Calmar (CAGR/|MDD|)": "calmar", "Sharpe": "sharpe", "?섏씡瑜?(Return)": "return", "MDD 理쒖냼": "mdd"}
                                obj_key = obj_map.get(optuna_objective, "calmar")

                                if opt_strategy_sel == "?덊궎???꾨왂":
                                    optuna_result = backtest_engine.optuna_optimize(
                                        full_df, strategy_mode="Donchian", buy_range=(opt_buy_start, opt_buy_end),
                                        sell_range=(opt_sell_start, opt_sell_end), fee=opt_fee, slippage=opt_slippage,
                                        start_date=opt_start, initial_balance=initial_cap, n_trials=optuna_n_trials,
                                        objective_metric=obj_key, progress_callback=opt_progress)
                                else:
                                    optuna_result = backtest_engine.optuna_optimize(
                                        full_df, strategy_mode="SMA ?꾨왂", buy_range=(opt_s_start, opt_s_end),
                                        fee=opt_fee, slippage=opt_slippage, start_date=opt_start,
                                        initial_balance=initial_cap, n_trials=optuna_n_trials,
                                        objective_metric=obj_key, progress_callback=opt_progress)

                                for r in optuna_result['trials']:
                                    row = {"Total Return (%)": r["total_return"], "CAGR (%)": r["cagr"], "MDD (%)": r["mdd"],
                                           "?고룊洹쟋DD (%)": r.get("avg_yearly_mdd", r["mdd"]),
                                           "Calmar": r["calmar"], "Win Rate (%)": r["win_rate"], "Sharpe": r["sharpe"], "Trades": r["trade_count"]}
                                    if opt_strategy_sel == "?덊궎???꾨왂":
                                        row["Buy Period"] = r["Buy Period"]
                                        row["Sell Period"] = r["Sell Period"]
                                    else:
                                        row["SMA Period"] = r["sma_period"]
                                    opt_results.append(row)
                                total_iter = optuna_n_trials
                                st.session_state["opt_single_results"] = {
                                    "rows": opt_results,
                                    "strategy": opt_strategy_sel,
                                    "use_optuna": use_optuna,
                                }
                                st.session_state.pop("opt_compare_results", None)
                            else:
                                if opt_strategy_sel == "?덊궎???꾨왂":
                                    buy_range  = range(opt_buy_start,  opt_buy_end  + 1, opt_buy_step)
                                    sell_range = range(opt_sell_start, opt_sell_end + 1, opt_sell_step)

                                    _modes_to_run = []
                                    if opt_dc_sell_mode == "??諛⑸쾿 鍮꾧탳":
                                        _modes_to_run = [("lower", "?섎떒??), ("midline", "以묒떖??)]
                                    elif opt_dc_sell_mode == "以묒떖??(Midline)":
                                        _modes_to_run = [("midline", "以묒떖??)]
                                    else:
                                        _modes_to_run = [("lower", "?섎떒??)]

                                    _all_mode_results = {}
                                    for _sm, _sm_label in _modes_to_run:
                                        _raw = backtest_engine.optimize_donchian(
                                            full_df, buy_range, sell_range, fee=opt_fee, slippage=opt_slippage,
                                            start_date=opt_start, initial_balance=initial_cap, progress_callback=opt_progress,
                                            sell_mode=_sm)
                                        _mode_rows = []
                                        for r in _raw:
                                            _mode_rows.append({"Buy Period": r["Buy Period"], "Sell Period": r["Sell Period"],
                                                "Total Return (%)": r["total_return"], "CAGR (%)": r["cagr"], "MDD (%)": r["mdd"],
                                                "?고룊洹쟋DD (%)": r.get("avg_yearly_mdd", r["mdd"]),
                                                "Calmar": abs(r["cagr"] / r["mdd"]) if r["mdd"] != 0 else 0,
                                                "Win Rate (%)": r["win_rate"], "Sharpe": r["sharpe"], "Trades": r["trade_count"]})
                                        _all_mode_results[_sm_label] = _mode_rows
                                        # ?⑥씪 紐⑤뱶???뚮뒗 opt_results?먮룄 ?닿린
                                        if len(_modes_to_run) == 1:
                                            opt_results = _mode_rows
                                    # 鍮꾧탳 紐⑤뱶 寃곌낵瑜??몄뀡 ?곹깭?????
                                    if len(_modes_to_run) == 2:
                                        st.session_state["opt_compare_results"] = _all_mode_results
                                        st.session_state.pop("opt_single_results", None)
                                    else:
                                        st.session_state["opt_single_results"] = {
                                            "rows": opt_results,
                                            "strategy": opt_strategy_sel,
                                            "use_optuna": use_optuna,
                                        }
                                        st.session_state.pop("opt_compare_results", None)
                                else:
                                    raw_results = backtest_engine.optimize_sma(
                                        full_df, sma_range, fee=opt_fee, slippage=opt_slippage,
                                        start_date=opt_start, initial_balance=initial_cap, progress_callback=opt_progress)
                                    for r in raw_results:
                                        opt_results.append({"SMA Period": r["SMA Period"],
                                            "Total Return (%)": r["total_return"], "CAGR (%)": r["cagr"], "MDD (%)": r["mdd"],
                                            "?고룊洹쟋DD (%)": r.get("avg_yearly_mdd", r["mdd"]),
                                            "Calmar": abs(r["cagr"] / r["mdd"]) if r["mdd"] != 0 else 0,
                                            "Win Rate (%)": r["win_rate"], "Sharpe": r["sharpe"], "Trades": r["trade_count"]})
                                    st.session_state["opt_single_results"] = {
                                        "rows": opt_results,
                                        "strategy": opt_strategy_sel,
                                        "use_optuna": use_optuna,
                                    }
                                    st.session_state.pop("opt_compare_results", None)

                            opt_elapsed = _time.time() - t1
                            status.update(label=f"?꾨즺! ({total_iter}嫄? {dl_elapsed:.1f}珥?+ {opt_elapsed:.1f}珥?", state="complete")

                    except Exception as e:
                        status.update(label=f"?ㅻ쪟: {e}", state="error")
                        import traceback
                        st.code(traceback.format_exc())

            # ?? 寃곌낵 ?쒖떆 (紐⑤뱺 吏?먯뿉???몄뀡 ?곹깭濡??좎??? ???????????????????????

            def _add_robustness(df_in, neighbor_steps=2):
                """媛?(Buy Period, Sell Period) 議고빀??????몄젒 짹neighbor_steps ?④퀎 Calmar ?됯퇏 = Robustness
                ?덈?媛믪씠 ?꾨땶 ?뺣젹??怨좎쑀媛??몃뜳??湲곗??쇰줈 ?댁썐??李얠븘 step ?ш린??臾닿??섍쾶 ?숈옉."""
                if "Robustness" in df_in.columns: return df_in
                df_out = df_in.copy()
                
                # 1. Donchian (2D)
                if "Buy Period" in df_out.columns and "Sell Period" in df_out.columns:
                    # 怨좎쑀 Buy/Sell 媛믪쓣 ?뺣젹???몃뜳??留ㅽ븨
                    buy_vals  = sorted(df_out["Buy Period"].unique())
                    sell_vals = sorted(df_out["Sell Period"].unique())
                    buy_idx   = {v: i for i, v in enumerate(buy_vals)}
                    sell_idx  = {v: i for i, v in enumerate(sell_vals)}
                    max_bi, max_si = len(buy_vals) - 1, len(sell_vals) - 1

                    calmar_lookup = {}
                    for _, row in df_out.iterrows():
                        calmar_lookup[(row["Buy Period"], row["Sell Period"])] = row["Calmar"]

                    def _rob(bp, sp):
                        bi, si = buy_idx.get(bp, -1), sell_idx.get(sp, -1)
                        if bi == -1 or si == -1: return 0.0
                        vals = []
                        for b_i in range(max(0, bi - neighbor_steps), min(max_bi, bi + neighbor_steps) + 1):
                            for s_i in range(max(0, si - neighbor_steps), min(max_si, si + neighbor_steps) + 1):
                                k = (buy_vals[b_i], sell_vals[s_i])
                                if k in calmar_lookup:
                                    vals.append(calmar_lookup[k])
                        return round(sum(vals) / len(vals), 2) if vals else 0.0
                    df_out["Robustness"] = df_out.apply(lambda r: _rob(r["Buy Period"], r["Sell Period"]), axis=1)
                
                # 2. SMA (1D)
                elif "SMA Period" in df_out.columns:
                    vals = sorted(df_out["SMA Period"].unique())
                    v_idx = {v: i for i, v in enumerate(vals)}
                    max_i = len(vals) - 1
                    lookup = {}
                    for _, row in df_out.iterrows():
                        lookup[row["SMA Period"]] = row["Calmar"]
                    
                    def _rob_sma(val):
                        idx = v_idx.get(val, -1)
                        if idx == -1: return 0.0
                        n_vals = []
                        for i in range(max(0, idx - neighbor_steps), min(max_i, idx + neighbor_steps) + 1):
                            nv = vals[i]
                            if nv in lookup:
                                n_vals.append(lookup[nv])
                        return round(sum(n_vals) / len(n_vals), 2) if n_vals else 0.0
                    df_out["Robustness"] = df_out["SMA Period"].apply(_rob_sma)

                return df_out

            _saved_compare = st.session_state.get("opt_compare_results", {})
            _saved_single  = st.session_state.get("opt_single_results", {})

            if _saved_compare:
                st.subheader("?? 留ㅻ룄諛⑹떇 鍮꾧탳 寃곌낵")
                tab_labels = list(_saved_compare.keys())
                cmp_tabs = st.tabs([f"?뱤 {lbl}" for lbl in tab_labels])
                for _tab, _lbl in zip(cmp_tabs, tab_labels):
                    with _tab:
                        _rows = _saved_compare[_lbl]
                        if _rows:
                            _df = pd.DataFrame(_rows).sort_values("Total Return (%)", ascending=False).reset_index(drop=True)
                            _df = _add_robustness(_df)
                            _df.index = _df.index + 1
                            _df.index.name = "?쒖쐞"
                            _best = _df.iloc[0]
                            st.success(f"??_lbl}??理쒖쟻: 留ㅼ닔 **{int(_best['Buy Period'])}**, 留ㅻ룄 **{int(_best['Sell Period'])}** ???섏씡瑜?{_best['Total Return (%)']:.1f}%, Calmar {_best['Calmar']:.2f}, Robustness {_best['Robustness']:.2f}")
                            st.dataframe(
                                _df.style.background_gradient(cmap='RdYlGn', subset=['Total Return (%)', 'Calmar', 'Sharpe', 'Robustness'])
                                    .background_gradient(cmap='RdYlGn_r', subset=['MDD (%)']).format("{:,.2f}"),
                                use_container_width=True, height=400)
                            import plotly.express as _px
                            _fig = _px.density_heatmap(_df.reset_index(), x="Buy Period", y="Sell Period", z="Total Return (%)",
                                                       histfunc="avg", title=f"[{_lbl}] ?덊듃留?, text_auto=".0f", color_continuous_scale="RdYlGn")
                            st.plotly_chart(_fig, use_container_width=True)
                        else:
                            st.info(f"{_lbl} 寃곌낵 ?놁쓬")

                # ?듭떖 吏??鍮꾧탳 ?뚯씠釉?
                if len(tab_labels) == 2:
                    st.subheader("?뱥 ?듭떖 吏??鍮꾧탳")
                    _compare_rows = []
                    for _lbl in tab_labels:
                        _rows = _saved_compare[_lbl]
                        if _rows:
                            _df2 = pd.DataFrame(_rows)
                            # 鍮꾧탳 ?곗씠?고봽?덉엫?먮룄 Robustness 異붽?
                            _df2 = _add_robustness(_df2)
                            _best2 = _df2.sort_values("Total Return (%)", ascending=False).iloc[0]
                            _compare_rows.append({
                                "留ㅻ룄諛⑹떇": _lbl,
                                "理쒖쟻 留ㅼ닔": int(_best2["Buy Period"]),
                                "理쒖쟻 留ㅻ룄": int(_best2["Sell Period"]),
                                "?섏씡瑜?(%)": round(_best2["Total Return (%)"], 2),
                                "CAGR (%)": round(_best2["CAGR (%)"], 2),
                                "MDD (%)": round(_best2["MDD (%)"], 2),
                                "Calmar": round(_best2["Calmar"], 2),
                                "Robustness": round(_best2["Robustness"], 2),
                                "Sharpe": round(_best2["Sharpe"], 2),
                                "嫄곕옒?잛닔": int(_best2["Trades"]),
                            })
                    if _compare_rows:
                        _cmp_df = pd.DataFrame(_compare_rows).set_index("留ㅻ룄諛⑹떇")
                        st.dataframe(_cmp_df.style.highlight_max(axis=0, color="#d4edda", subset=["?섏씡瑜?(%)", "Calmar", "Robustness", "Sharpe"]).highlight_min(axis=0, color="#f8d7da", subset=["MDD (%)"]), use_container_width=True)

            elif _saved_single:
                import plotly.express as px
                opt_results  = _saved_single["rows"]
                _s_strategy  = _saved_single["strategy"]
                _s_optuna    = _saved_single["use_optuna"]
                if opt_results:
                    opt_df = pd.DataFrame(opt_results)
                    sort_col = "Calmar" if _s_optuna else "Total Return (%)"
                    opt_df = opt_df.sort_values(sort_col, ascending=False).reset_index(drop=True)
                    opt_df = _add_robustness(opt_df)
                    opt_df.index = opt_df.index + 1
                    opt_df.index.name = "?쒖쐞"
                    best_row = opt_df.iloc[0]
                    if _s_strategy == "?덊궎???꾨왂":
                        st.success(f"理쒖쟻: 留ㅼ닔 **{int(best_row['Buy Period'])}**, 留ㅻ룄 **{int(best_row['Sell Period'])}** ???섏씡瑜?{best_row['Total Return (%)']:.1f}%, Calmar {best_row['Calmar']:.2f}, Robustness {best_row.get('Robustness', 0):.2f}")
                    else:
                        st.success(f"理쒖쟻: SMA **{int(best_row['SMA Period'])}** ???섏씡瑜?{best_row['Total Return (%)']:.1f}%, Calmar {best_row['Calmar']:.2f}, Robustness {best_row.get('Robustness', 0):.2f}")
                    _grad_cols = [c for c in ['Total Return (%)', 'Calmar', 'Sharpe', 'Robustness'] if c in opt_df.columns]
                    st.dataframe(
                        opt_df.style.background_gradient(cmap='RdYlGn', subset=_grad_cols)
                            .background_gradient(cmap='RdYlGn_r', subset=['MDD (%)']).format("{:,.2f}"),
                        use_container_width=True, height=500)

                    # ?? ?뚮씪誘명꽣 ?좏깮 踰꾪듉 (?대┃ ??利됱떆 諛깊뀒?ㅽ듃) ??
                    st.divider()
                    st.subheader("?뚮씪誘명꽣 ?좏깮 ??利됱떆 諛깊뀒?ㅽ듃")
                    _ctop5 = opt_df.head(5).reset_index(drop=True)
                    for _cri, _crow in _ctop5.iterrows():
                        _cc1, _cc2 = st.columns([8, 1])
                        if _s_strategy == "?덊궎???꾨왂" and "Buy Period" in _ctop5.columns:
                            _cc1.markdown(f"**#{_cri+1}** Buy={int(_crow['Buy Period'])}, Sell={int(_crow['Sell Period'])} | ?섏씡 {_crow['Total Return (%)']:.1f}%, Calmar {_crow['Calmar']:.2f}")
                        elif "SMA Period" in _ctop5.columns:
                            _cc1.markdown(f"**#{_cri+1}** SMA={int(_crow['SMA Period'])} | ?섏씡 {_crow['Total Return (%)']:.1f}%, Calmar {_crow['Calmar']:.2f}")
                        else:
                            continue
                        if _cc2.button("?ㅽ뻾", key=f"c_obt_{_cri}"):
                            _cbt_base = {
                                'ticker': opt_ticker_sel,
                                'interval': opt_interval,
                                'start_date': str(opt_start),
                                'end_date': str(opt_end),
                                'fee': opt_fee,
                                'slippage': opt_slippage,
                                'initial_cap': initial_cap,
                            }
                            if _s_strategy == "?덊궎???꾨왂" and "Buy Period" in _ctop5.columns:
                                _cbt_base.update({
                                    'strategy': 'Donchian',
                                    'buy_period': int(_crow['Buy Period']),
                                    'sell_period': int(_crow['Sell Period']),
                                })
                            else:
                                _cbt_base.update({
                                    'strategy': 'SMA ?꾨왂',
                                    'sma_period': int(_crow['SMA Period']),
                                })
                            st.session_state['coin_opt_bt_params'] = _cbt_base
                            st.rerun()

                    # ?뵇 ?곸꽭 遺꾩꽍 Expander (Robustness Check)
                    with st.expander("?뵇 理쒖쟻 ?뚮씪誘명꽣 二쇰? ?곸꽭 遺꾩꽍 (Robustness)", expanded=False):
                        try:
                            if _s_strategy == "?덊궎???꾨왂" and "Buy Period" in opt_df.columns:
                                st.caption("理쒖쟻 (Buy, Sell) ?뚮씪誘명꽣 湲곗? 짹2?④퀎 ?댁썐?ㅼ쓽 ?깃낵瑜?遺꾩꽍?⑸땲??")
                                b_val, s_val = int(best_row["Buy Period"]), int(best_row["Sell Period"])
                                b_uniq = sorted(opt_df["Buy Period"].unique())
                                s_uniq = sorted(opt_df["Sell Period"].unique())
                                
                                if b_val in b_uniq and s_val in s_uniq:
                                    b_idx, s_idx = b_uniq.index(b_val), s_uniq.index(s_val)
                                    nb_vals = b_uniq[max(0, b_idx-2) : min(len(b_uniq), b_idx+3)]
                                    ns_vals = s_uniq[max(0, s_idx-2) : min(len(s_uniq), s_idx+3)]
                                    
                                    sub_df = opt_df[
                                        (opt_df["Buy Period"].isin(nb_vals)) & 
                                        (opt_df["Sell Period"].isin(ns_vals))
                                    ].copy()
                                    
                                    c1, c2, c3 = st.columns(3)
                                    c1.metric("?댁썐 ?됯퇏 ?섏씡瑜?, f"{sub_df['Total Return (%)'].mean():.1f}%")
                                    c2.metric("?댁썐 ?됯퇏 Calmar", f"{sub_df['Calmar'].mean():.2f}")
                                    c3.metric("?댁썐 理쒖냼 MDD", f"{sub_df['MDD (%)'].min():.2f}%")
                                    
                                    st.dataframe(sub_df.style.background_gradient(cmap='RdYlGn', subset=['Calmar']), use_container_width=True)
                                else:
                                    st.warning("?뚮씪誘명꽣 ?몃뜳??議고쉶 ?ㅽ뙣")
                            
                            elif _s_strategy != "?덊궎???꾨왂" and "SMA Period" in opt_df.columns:
                                st.caption("理쒖쟻 SMA Period 湲곗? 짹2?④퀎 ?댁썐?ㅼ쓽 ?깃낵瑜?遺꾩꽍?⑸땲??")
                                p_val = int(best_row["SMA Period"])
                                p_uniq = sorted(opt_df["SMA Period"].unique())
                                
                                if p_val in p_uniq:
                                    p_idx = p_uniq.index(p_val)
                                    np_vals = p_uniq[max(0, p_idx-2) : min(len(p_uniq), p_idx+3)]
                                    
                                    sub_df = opt_df[opt_df["SMA Period"].isin(np_vals)].copy()
                                    
                                    c1, c2 = st.columns(2)
                                    c1.metric("?댁썐 ?됯퇏 ?섏씡瑜?, f"{sub_df['Total Return (%)'].mean():.1f}%")
                                    c2.metric("?댁썐 ?됯퇏 Calmar", f"{sub_df['Calmar'].mean():.2f}")
                                    
                                    st.bar_chart(sub_df.set_index("SMA Period")[["Calmar", "Total Return (%)"]])
                                else:
                                    st.warning("?뚮씪誘명꽣 ?몃뜳??議고쉶 ?ㅽ뙣")
                        except Exception as e:
                            st.error(f"?곸꽭 遺꾩꽍 以??ㅻ쪟 諛쒖깮: {e}")

                    if _s_strategy == "?덊궎???꾨왂" and not _s_optuna:
                        fig_opt = px.density_heatmap(opt_df.reset_index(), x="Buy Period", y="Sell Period", z="Total Return (%)", histfunc="avg", title="?덊궎??理쒖쟻???덊듃留?, text_auto=".0f", color_continuous_scale="RdYlGn")
                        st.plotly_chart(fig_opt, use_container_width=True)
                    elif _s_strategy != "?덊궎???꾨왂" and not _s_optuna:
                        _sma_chart_df = opt_df.reset_index()
                        _fig_sma = make_subplots(specs=[[{"secondary_y": True}]])
                        _fig_sma.add_trace(go.Scatter(
                            x=_sma_chart_df["SMA Period"], y=_sma_chart_df["Total Return (%)"],
                            name="Total Return (%)", line=dict(color="royalblue", width=2)), secondary_y=False)
                        _fig_sma.add_trace(go.Scatter(
                            x=_sma_chart_df["SMA Period"], y=_sma_chart_df["MDD (%)"],
                            name="MDD (%)", line=dict(color="red", width=2)), secondary_y=True)
                        if "?고룊洹쟋DD (%)" in _sma_chart_df.columns:
                            _fig_sma.add_trace(go.Scatter(
                                x=_sma_chart_df["SMA Period"], y=_sma_chart_df["?고룊洹쟋DD (%)"],
                                name="?고룊洹쟋DD (%)", line=dict(color="orange", width=2, dash="dot")), secondary_y=True)
                        _fig_sma.update_layout(title="SMA 理쒖쟻??寃곌낵", height=400,
                            margin=dict(l=0, r=0, t=40, b=30),
                            legend=dict(orientation="h", yanchor="bottom", y=1.02, xanchor="left", x=0))
                        _fig_sma.update_yaxes(title_text="Total Return (%)", secondary_y=False)
                        _fig_sma.update_yaxes(title_text="MDD (%)", secondary_y=True)
                        st.plotly_chart(_fig_sma, use_container_width=True)

            # ?? 理쒖쟻??寃곌낵?먯꽌 ?좏깮???뚮씪誘명꽣濡??먮룞 諛깊뀒?ㅽ듃 ??
            if 'coin_opt_bt_params' in st.session_state:
                _cp = st.session_state['coin_opt_bt_params']
                st.divider()
                if _cp['strategy'] == 'Donchian':
                    _cbp = _cp['buy_period']
                    _csp = _cp['sell_period']
                    st.subheader(f"諛깊뀒?ㅽ듃: Donchian Buy={_cbp}, Sell={_csp}")
                    _c_period = _cbp
                    _c_sell_ratio = _csp / _cbp
                    _c_strat_mode = "Donchian"
                else:
                    _csma = _cp['sma_period']
                    st.subheader(f"諛깊뀒?ㅽ듃: SMA Period={_csma}")
                    _c_period = _csma
                    _c_sell_ratio = 1.0
                    _c_strat_mode = "SMA ?꾨왂"

                _c_ticker = _cp['ticker']
                _c_interval = _cp['interval']
                _c_start = _cp['start_date']
                _c_end = _cp['end_date']
                _c_fee = _cp['fee']
                _c_slip = _cp['slippage']
                _c_cap = _cp['initial_cap']

                _c_days = (pd.Timestamp(_c_end) - pd.Timestamp(_c_start)).days
                _c_cpd = CANDLES_PER_DAY.get(_c_interval, 1)
                _c_count = _c_days * _c_cpd + _c_period + 300
                _c_to = (pd.Timestamp(_c_end) + timedelta(days=1)).strftime("%Y-%m-%d 09:00:00")
                _c_df = data_cache.get_ohlcv_cached(_c_ticker, interval=_c_interval, to=_c_to, count=_c_count)

                if _c_df is None or len(_c_df) < _c_period + 5:
                    st.error("?곗씠??遺議? 湲곌컙???뺤씤?섏꽭??")
                else:
                    with st.spinner("諛깊뀒?ㅽ듃 ?ㅽ뻾 以?.."):
                        _c_eng = BacktestEngine()
                        _c_res = _c_eng.run_backtest(
                            ticker=_c_ticker, df=_c_df,
                            period=_c_period, interval=_c_interval, fee=_c_fee,
                            start_date=_c_start, initial_balance=_c_cap,
                            strategy_mode=_c_strat_mode,
                            sell_period_ratio=_c_sell_ratio,
                            slippage=_c_slip,
                        )
                    if "error" in _c_res:
                        st.error(f"諛깊뀒?ㅽ듃 ?ㅻ쪟: {_c_res['error']}")
                    else:
                        _cperf = _c_res["performance"]
                        _cr1, _cr2, _cr3, _cr4 = st.columns(4)
                        _cr1.metric("珥??섏씡瑜?, f"{_cperf['total_return']:+.2f}%")
                        _cr2.metric("CAGR", f"{_cperf['cagr']:+.2f}%")
                        _cr3.metric("MDD", f"{_cperf['mdd']:.2f}%")
                        _cr4.metric("?ㅽ봽 鍮꾩쑉", f"{_cperf['sharpe']:.2f}")
                        _cr5, _cr6, _cr7, _cr8, _cr9 = st.columns(5)
                        _cr5.metric("留ㅻℓ ?잛닔", f"{_cperf['trade_count']}??)
                        _cr6.metric("?밸쪧", f"{_cperf['win_rate']:.1f}%")
                        _cr7.metric("理쒖쥌 ?먯궛", f"{_cperf['final_equity']:,.0f}??)
                        _c_calmar = abs(_cperf['cagr'] / _cperf['mdd']) if _cperf['mdd'] != 0 else 0
                        _cr8.metric("Calmar", f"{_c_calmar:.2f}")
                        _cr9.metric("?고룊洹쟋DD", f"{_cperf.get('avg_yearly_mdd', _cperf['mdd']):.2f}%")

                        _c_df_full = _c_res.get("df")
                        _c_eq_curve = _c_res.get("equity_curve")

                        if _c_df_full is not None and _c_eq_curve is not None:
                            _c_eq_s = pd.Series(_c_eq_curve, index=_c_df_full.index[-len(_c_eq_curve):])
                            _c_daily_ret = _c_eq_s.pct_change().dropna().values
                            st.session_state['coin_analysis_data'] = {
                                "label": f"{_c_ticker} {_c_strat_mode}",
                                "equity_series": _c_eq_s,
                                "daily_returns": _c_daily_ret,
                                "trades": _cperf.get("trades", []),
                                "initial_cap": _c_cap,
                                "performance": _cperf,
                            }
                            _c_yr_rows = []
                            for yr in sorted(_c_eq_s.index.year.unique()):
                                _yr_eq = _c_eq_s[_c_eq_s.index.year == yr]
                                if _yr_eq.empty:
                                    continue
                                _yr_ret = (_yr_eq.iloc[-1] / _yr_eq.iloc[0] - 1) * 100
                                _yr_mdd = ((_yr_eq - _yr_eq.cummax()) / _yr_eq.cummax() * 100).min()
                                _c_yr_rows.append({
                                    "?곕룄": yr, "?섏씡瑜?%)": f"{_yr_ret:+.2f}",
                                    "MDD(%)": f"{_yr_mdd:.2f}",
                                    "?쒖옉?먯궛": f"{_yr_eq.iloc[0]:,.0f}",
                                    "理쒖쥌?먯궛": f"{_yr_eq.iloc[-1]:,.0f}",
                                })
                            if _c_yr_rows:
                                _df_cyr = pd.DataFrame(_c_yr_rows)
                                _cavg_ret = np.mean([float(r["?섏씡瑜?%)"]) for r in _c_yr_rows])
                                _cavg_mdd = np.mean([float(r["MDD(%)"]) for r in _c_yr_rows])
                                _df_cyr = pd.concat([_df_cyr, pd.DataFrame([{
                                    "?곕룄": "?됯퇏", "?섏씡瑜?%)": f"{_cavg_ret:+.2f}",
                                    "MDD(%)": f"{_cavg_mdd:.2f}",
                                    "?쒖옉?먯궛": "??, "理쒖쥌?먯궛": "??,
                                }])], ignore_index=True)
                                st.subheader("?곕룄蹂??깃낵")
                                st.dataframe(_df_cyr, use_container_width=True, hide_index=True)

                            _c_df_eq = pd.DataFrame({"equity": _c_eq_curve}, index=_c_df_full.index[-len(_c_eq_curve):])
                            _c_df_eq["return_pct"] = (_c_df_eq["equity"] / _c_cap - 1) * 100
                            _c_fig = go.Figure()
                            _c_fig.add_trace(go.Scatter(
                                x=_c_df_eq.index, y=_c_df_eq["return_pct"], mode="lines",
                                name="?꾨왂", line=dict(color="royalblue", width=2)))
                            if _cp['strategy'] == 'Donchian':
                                _c_title = f"?꾩쟻 ?섏씡瑜?(Donchian {_cbp}/{_csp})"
                            else:
                                _c_title = f"?꾩쟻 ?섏씡瑜?(SMA {_csma})"
                            _c_fig.update_layout(
                                title=_c_title, yaxis_title="?섏씡瑜?(%)", height=350,
                                margin=dict(l=0, r=0, t=40, b=30),
                                legend=dict(orientation="h", yanchor="bottom", y=1.02, xanchor="left", x=0))
                            st.plotly_chart(_c_fig, use_container_width=True)

                        with st.expander("嫄곕옒 ?댁뿭"):
                            _c_trades = _cperf.get("trades", [])
                            if _c_trades:
                                st.dataframe(pd.DataFrame(_c_trades), use_container_width=True, hide_index=True)
                            else:
                                st.info("?ㅽ뻾??嫄곕옒媛 ?놁뒿?덈떎.")

                if st.button("寃곌낵 ?リ린", key="coin_opt_bt_close"):
                    del st.session_state['coin_opt_bt_params']
                    st.rerun()

        # === ?쒕툕??: 蹂댁“ ?꾨왂 (??텛??遺꾪븷留ㅼ닔) ===
        with bt_sub4:
            st.header("蹂댁“ ?꾨왂: MA ?닿꺽????텛??遺꾪븷留ㅼ닔")
            st.caption("硫붿씤 ?꾨왂???꾧툑 援ш컙???? 怨쇰ℓ??+ 異붽??섎씫 ??遺꾪븷留ㅼ닔 ???됰떒媛 湲곗? TP ?듭젅")
            # Streamlit ?쒖빟: ?대? ?앹꽦???꾩젽 key??媛숈? ?곗뿉??吏곸젒 ?섏젙 遺덇?.
            # 理쒖쟻?붿뿉???좏깮??媛믪쓣 ?ㅼ쓬 rerun ?쒖옉 ?쒖젏(?꾩젽 ?앹꽦 ????諛섏쁺?쒕떎.
            _aux_pending_apply = st.session_state.pop("aux_apply_params", None)
            if isinstance(_aux_pending_apply, dict):
                _allowed_aux_keys = {
                    "aux_ma_short", "aux_ma_long", "aux_threshold",
                    "aux_tp1", "aux_tp2", "aux_split",
                    "aux_seed_mode", "aux_pyramid_ratio",
                    "aux_interval", "aux_main_interval",
                }
                for _k, _v in _aux_pending_apply.items():
                    if _k in _allowed_aux_keys:
                        if _k == "aux_threshold":
                            _v = float(np.clip(float(_v), -30.0, -0.5))
                        elif _k == "aux_pyramid_ratio":
                            _v = float(np.clip(float(_v), 1.05, 3.00))
                        elif _k == "aux_split":
                            _v = int(np.clip(int(_v), 1, 20))
                        elif _k == "aux_ma_short":
                            _v = int(np.clip(int(_v), 3, 100))
                        elif _k == "aux_ma_long":
                            _v = int(np.clip(int(_v), 5, 300))
                        elif _k in ("aux_interval", "aux_main_interval"):
                            if _v not in INTERVAL_MAP:
                                continue
                        st.session_state[_k] = _v

            aux_col1, aux_col2 = st.columns(2)

            with aux_col1:
                st.subheader("硫붿씤 ?꾨왂 ?ㅼ젙")
                st.caption("蹂댁“ ?꾨왂???묐룞??'?꾧툑 援ш컙'??寃곗젙?⑸땲??)
                _aux_port_tickers = [f"{r['market']}-{r['coin'].upper()}" for r in portfolio_list]
                _aux_base = list(dict.fromkeys(_aux_port_tickers + TOP_20_TICKERS))
                aux_ticker = st.selectbox("醫낅ぉ", _aux_base + ["吏곸젒?낅젰"], key="aux_ticker")
                if aux_ticker == "吏곸젒?낅젰":
                    aux_ticker = st.text_input("?곗빱 ?낅젰 (?? KRW-BTC)", "KRW-BTC", key="aux_ticker_custom")

                aux_main_strat = st.selectbox("硫붿씤 ?꾨왂", ["Donchian", "SMA"], key="aux_main_strat")
                _amc1, _amc2 = st.columns(2)
                aux_main_buy = _amc1.number_input("硫붿씤 留ㅼ닔 湲곌컙", 5, 300, 115, key="aux_main_buy")
                aux_main_sell = _amc2.number_input("硫붿씤 留ㅻ룄 湲곌컙", 0, 300, 55, key="aux_main_sell",
                                                    help="SMA??臾댁떆?? 0=留ㅼ닔???덈컲")
                if aux_main_sell == 0:
                    aux_main_sell = max(5, aux_main_buy // 2)

            with aux_col2:
                st.subheader("蹂댁“ ?꾨왂 ?뚮씪誘명꽣")
                st.caption("?닿꺽??怨쇰ℓ??議곌굔 + ?듭젅 ?ㅼ젙")
                _apc1, _apc2 = st.columns(2)
                aux_ma_short = _apc1.number_input("?④린 ?댄룊 (MA1)", 3, 100, 5, key="aux_ma_short")
                aux_ma_long = _apc2.number_input("以묎린 ?댄룊 (MA2)", 5, 300, 20, key="aux_ma_long")
                aux_threshold = st.slider("怨쇰ℓ???꾧퀎媛?(?닿꺽??%)", -30.0, -0.5, -5.0, 0.5,
                                          key="aux_threshold",
                                          help="???댄룊 ?닿꺽?꾧? 紐⑤몢 ??媛??댄븯????留ㅼ닔")
                aux_split = st.number_input("遺꾪븷 留ㅼ닔 ?잛닔", 1, 20, 3, key="aux_split",
                                            help="怨쇰ℓ??+ 異붽??섎씫 ??留?遊됰쭏??1?뚯뵫 N??遺꾪븷留ㅼ닔")
                aux_seed_mode_label = st.radio(
                    "留ㅼ닔 ?쒕뱶 諛⑹떇",
                    ["洹좊벑 留ㅼ닔", "?쇰씪誘몃뵫 留ㅼ닔"],
                    horizontal=True,
                    key="aux_seed_mode",
                    help="洹좊벑: 媛??곗뼱 ?숈씪 湲덉븸 | ?쇰씪誘몃뵫: ?ㅼ쓬 ?곗뼱媛 ?댁쟾 ?곗뼱??諛곗쑉留뚰겮 利앷?",
                )
                aux_seed_mode = "pyramiding" if aux_seed_mode_label == "?쇰씪誘몃뵫 留ㅼ닔" else "equal"
                aux_pyramid_ratio = 1.0
                if aux_seed_mode == "pyramiding":
                    aux_pyramid_ratio = st.number_input(
                        "?쇰씪誘몃뵫 諛곗쑉",
                        min_value=1.05, max_value=3.00, value=1.30, step=0.05,
                        key="aux_pyramid_ratio",
                        help="?? 1.3?대㈃ 7遺꾪븷 湲곗? 1, 1.3, 1.69, ... 鍮꾩쑉濡??쒕뱶 諛곕텇",
                    )
                else:
                    st.caption("洹좊벑 留ㅼ닔: 7遺꾪븷?대㈃ 媛??곗뼱 1/7???숈씪 諛곕텇")

                _seed_weights = np.array([1.0] * int(aux_split))
                if aux_seed_mode == "pyramiding":
                    _seed_weights = np.array([aux_pyramid_ratio ** i for i in range(int(aux_split))], dtype=float)
                _seed_weights = _seed_weights / _seed_weights.sum()
                _seed_weight_text = " ??".join([f"{w*100:.1f}%" for w in _seed_weights])
                st.caption(f"?쒕뱶 鍮꾩쨷({int(aux_split)}遺꾪븷): {_seed_weight_text}")
                _atc1, _atc2 = st.columns(2)
                aux_tp1 = _atc1.number_input("TP1 ?듭젅 (%)", 1.0, 30.0, 3.0, 0.5, key="aux_tp1",
                                              help="?됰떒媛 ?鍮?泥?踰덉㎏ ?듭젅")
                aux_tp2 = _atc2.number_input("TP2 ?듭젅 (%)", 1.0, 50.0, 10.0, 0.5, key="aux_tp2",
                                              help="?됰떒媛 ?鍮?留덉?留??듭젅")
                if aux_split > 1:
                    _tp_lines = [f"{v:.1f}%" for v in np.linspace(aux_tp1, aux_tp2, aux_split)]
                    st.caption(f"?됰떒媛 ?鍮??듭젅 ?쇱씤: {' ??'.join(_tp_lines)}")
                st.caption("?뱦 異붽?留ㅼ닔 議곌굔: 怨쇰ℓ??+ 吏곸쟾 留ㅼ닔媛蹂대떎 ?섎씫 ?쒖뿉留?)

            # 怨듯넻 ?ㅼ젙
            _aux_iv_options = list(INTERVAL_MAP.keys())
            if "aux_interval" not in st.session_state and "1?쒓컙" in _aux_iv_options:
                st.session_state["aux_interval"] = "1?쒓컙"
            if "aux_main_interval" not in st.session_state:
                st.session_state["aux_main_interval"] = "4?쒓컙" if "4?쒓컙" in _aux_iv_options else _aux_iv_options[0]

            aux_set_col1, aux_set_col2, aux_set_col3, aux_set_col4, aux_set_col5 = st.columns(5)
            aux_interval = aux_set_col1.selectbox("蹂댁“ 留ㅻℓ ?쒓컙遊?, _aux_iv_options, key="aux_interval")
            aux_main_interval = aux_set_col2.selectbox("硫붿씤 ?좏샇 ?쒓컙遊?, _aux_iv_options, key="aux_main_interval")
            aux_start = aux_set_col3.date_input("?쒖옉??, value=start_date, key="aux_start")
            aux_fee = aux_set_col4.number_input("?섏닔猷?(%)", 0.0, 1.0, 0.05, 0.01, key="aux_fee") / 100
            aux_slippage = aux_set_col5.number_input("?щ━?쇱? (%)", 0.0, 2.0, 0.1, 0.05, key="aux_slip")

            if aux_interval == aux_main_interval:
                st.caption(f"?쒓컙遊? ?⑥씪 ?쒓컙遊?紐⑤뱶 ({aux_interval})")
            else:
                st.caption(f"?쒓컙遊? 硫????꾪봽?덉엫 紐⑤뱶 (蹂댁“ 留ㅻℓ={aux_interval}, 硫붿씤 ?좏샇={aux_main_interval})")

            _q1, _q2, _q3 = st.columns([1, 1, 4])
            if _q1.button("??30遺?湲곗? ?곸슜", key="aux_quick_30m"):
                st.session_state["aux_apply_params"] = {
                    "aux_interval": "30遺? if "30遺? in INTERVAL_MAP else aux_interval,
                    "aux_main_interval": "4?쒓컙" if "4?쒓컙" in INTERVAL_MAP else aux_main_interval,
                }
                st.rerun()
            if _q2.button("??1?쒓컙 湲곗? ?곸슜", key="aux_quick_1h"):
                st.session_state["aux_apply_params"] = {
                    "aux_interval": "1?쒓컙" if "1?쒓컙" in INTERVAL_MAP else aux_interval,
                    "aux_main_interval": "4?쒓컙" if "4?쒓컙" in INTERVAL_MAP else aux_main_interval,
                }
                st.rerun()

            @st.cache_data(ttl=600)
            def _load_aux_df_cached(ticker, api_interval, count):
                _df = data_cache.load_cached(ticker, api_interval)
                if _df is None or len(_df) < 50:
                    _df = pyupbit.get_ohlcv(ticker, interval=api_interval, count=count)
                return _df

            def _count_from_start(api_interval, start_dt, warmup=400, cap=12000):
                _days = max((datetime.now().date() - start_dt).days + 2, 30)
                _cpd = CANDLES_PER_DAY.get(api_interval, 1)
                _cnt = int(_days * _cpd + warmup)
                return int(np.clip(_cnt, 500, cap))

            st.divider()

            # ?? 諛깊뀒?ㅽ듃 ?ㅽ뻾 ??
            run_aux_bt_col, run_aux_opt_col = st.columns(2)

            with run_aux_bt_col:
                _manual_run_aux = st.button("??蹂댁“ ?꾨왂 諛깊뀒?ㅽ듃 ?ㅽ뻾", type="primary", key="run_aux_bt")
                _auto_run_aux = st.session_state.pop("aux_run_backtest_now", False)
                if _manual_run_aux or _auto_run_aux:
                    aux_bt_progress = st.progress(0, text="蹂댁“ ?꾨왂 諛깊뀒?ㅽ듃 以鍮?以?..")
                    _aux_api_interval = INTERVAL_MAP.get(aux_interval, "day")
                    _aux_main_api_interval = INTERVAL_MAP.get(aux_main_interval, _aux_api_interval)
                    _aux_count = _count_from_start(_aux_api_interval, aux_start, warmup=400, cap=12000)
                    _aux_main_count = _count_from_start(
                        _aux_main_api_interval,
                        aux_start,
                        warmup=max(int(aux_main_buy), int(aux_main_sell), 30) + 400,
                        cap=12000,
                    )

                    aux_bt_progress.progress(0.08, text="罹붾뱾 ?곗씠??議고쉶 以?..")
                    df_aux = _load_aux_df_cached(aux_ticker, _aux_api_interval, _aux_count)
                    df_main_aux = None
                    if aux_main_interval != aux_interval:
                        aux_bt_progress.progress(0.14, text="硫붿씤 ?좏샇 ?쒓컙遊??곗씠??議고쉶 以?..")
                        df_main_aux = _load_aux_df_cached(aux_ticker, _aux_main_api_interval, _aux_main_count)

                    if (
                        df_aux is not None and len(df_aux) >= 50 and
                        (df_main_aux is None or len(df_main_aux) >= 50)
                    ):
                        aux_bt_progress.progress(0.20, text="罹붾뱾 ?곗씠??議고쉶 ?꾨즺")

                        def _aux_bt_cb(cur, total, msg):
                            _t = max(int(total), 1)
                            _r = min(max(float(cur) / float(_t), 0.0), 1.0)
                            _p = min(max(0.20 + 0.78 * _r, 0.20), 0.98)
                            aux_bt_progress.progress(_p, text=f"[蹂댁“ 諛깊뀒?ㅽ듃] {msg}")

                        res_aux = backtest_engine.run_aux_backtest(
                            df_aux, main_strategy=aux_main_strat,
                            main_buy_p=aux_main_buy, main_sell_p=aux_main_sell,
                            ma_short=aux_ma_short, ma_long=aux_ma_long,
                            oversold_threshold=aux_threshold,
                            tp1_pct=aux_tp1, tp2_pct=aux_tp2,
                            fee=aux_fee, slippage=aux_slippage,
                            start_date=str(aux_start),
                            initial_balance=initial_cap,
                            split_count=aux_split,
                            buy_seed_mode=aux_seed_mode,
                            pyramid_ratio=float(aux_pyramid_ratio),
                            progress_callback=_aux_bt_cb,
                            main_df=df_main_aux,
                        )
                        st.session_state["aux_bt_result"] = res_aux
                        aux_bt_progress.progress(1.0, text="蹂댁“ ?꾨왂 諛깊뀒?ㅽ듃 ?꾨즺")
                    else:
                        aux_bt_progress.progress(1.0, text="蹂댁“ ?꾨왂 諛깊뀒?ㅽ듃 ?ㅽ뙣: ?곗씠??議고쉶 ?ㅽ뙣")
                        st.error("?곗씠?곕? 媛?몄삱 ???놁뒿?덈떎.")

            with run_aux_opt_col:
                if st.button("?㎦ ?쒓컙遊?鍮꾧탳 諛깊뀒?ㅽ듃", key="run_aux_tf_compare"):
                    _scan_labels = [x for x in ["?쇰큺", "4?쒓컙", "1?쒓컙", "30遺?, "15遺?, "5遺?] if x in INTERVAL_MAP]
                    scan_progress = st.progress(0, text="?쒓컙遊?鍮꾧탳 諛깊뀒?ㅽ듃 ?쒖옉...")
                    scan_rows = []
                    _main_api = INTERVAL_MAP.get(aux_main_interval, "day")
                    _main_count_scan = _count_from_start(
                        _main_api, aux_start, warmup=max(int(aux_main_buy), int(aux_main_sell), 30) + 400, cap=12000
                    )
                    _main_df_scan = None
                    if aux_main_interval not in _scan_labels or any(iv != aux_main_interval for iv in _scan_labels):
                        _main_df_scan = _load_aux_df_cached(aux_ticker, _main_api, _main_count_scan)

                    for _idx, _iv in enumerate(_scan_labels, start=1):
                        scan_progress.progress((_idx - 1) / len(_scan_labels), text=f"[{_iv}] ?곗씠??議고쉶/諛깊뀒?ㅽ듃 以?..")
                        _exec_api = INTERVAL_MAP[_iv]
                        _exec_count = _count_from_start(_exec_api, aux_start, warmup=400, cap=12000)
                        _df_exec = _load_aux_df_cached(aux_ticker, _exec_api, _exec_count)
                        if _df_exec is None or len(_df_exec) < 50:
                            continue

                        _main_df_for_run = None
                        if _iv != aux_main_interval:
                            if _main_df_scan is None or len(_main_df_scan) < 50:
                                continue
                            _main_df_for_run = _main_df_scan

                        _res_scan = backtest_engine.run_aux_backtest(
                            _df_exec,
                            main_strategy=aux_main_strat,
                            main_buy_p=aux_main_buy,
                            main_sell_p=aux_main_sell,
                            ma_short=aux_ma_short,
                            ma_long=aux_ma_long,
                            oversold_threshold=aux_threshold,
                            tp1_pct=aux_tp1,
                            tp2_pct=aux_tp2,
                            fee=aux_fee,
                            slippage=aux_slippage,
                            start_date=str(aux_start),
                            initial_balance=initial_cap,
                            split_count=aux_split,
                            buy_seed_mode=aux_seed_mode,
                            pyramid_ratio=float(aux_pyramid_ratio),
                            main_df=_main_df_for_run,
                        )
                        _mdd = float(_res_scan.get("mdd", 0.0))
                        _cagr = float(_res_scan.get("cagr", 0.0))
                        _calmar = abs(_cagr / _mdd) if abs(_mdd) > 1e-9 else 0.0
                        scan_rows.append({
                            "蹂댁“ 留ㅻℓ ?쒓컙遊?: _iv,
                            "硫붿씤 ?좏샇 ?쒓컙遊?: aux_main_interval,
                            "嫄곕옒?잛닔": int(_res_scan.get("trade_count", 0)),
                            "?섏씡瑜?%)": float(_res_scan.get("total_return", 0.0)),
                            "CAGR(%)": _cagr,
                            "MDD(%)": _mdd,
                            "Calmar": _calmar,
                            "?밸쪧(%)": float(_res_scan.get("win_rate", 0.0)),
                        })

                    scan_progress.progress(1.0, text="?쒓컙遊?鍮꾧탳 諛깊뀒?ㅽ듃 ?꾨즺")
                    if scan_rows:
                        _scan_df = pd.DataFrame(scan_rows).sort_values(
                            ["嫄곕옒?잛닔", "Calmar", "?섏씡瑜?%)"], ascending=[False, False, False]
                        ).reset_index(drop=True)
                        st.subheader("?쒓컙遊?鍮꾧탳 寃곌낵")
                        st.dataframe(
                            _scan_df.style.format({
                                "?섏씡瑜?%)": "{:.2f}",
                                "CAGR(%)": "{:.2f}",
                                "MDD(%)": "{:.2f}",
                                "Calmar": "{:.3f}",
                                "?밸쪧(%)": "{:.1f}",
                            }),
                            use_container_width=True,
                            hide_index=True,
                        )
                        st.info("嫄곕옒?잛닔瑜??섎━?ㅻ㈃ ?쇰컲?곸쑝濡?蹂댁“ 留ㅻℓ ?쒓컙遊됱쓣 吏㏐쾶(?? 1?쒓컙/30遺? ?먮뒗 履쎌씠 ?좊━?⑸땲??")
                    else:
                        st.warning("?쒓컙遊?鍮꾧탳 寃곌낵媛 ?놁뒿?덈떎. ?쒖옉??醫낅ぉ/?쒓컙遊됱쓣 ?뺤씤??二쇱꽭??")

            # 諛깊뀒?ㅽ듃 寃곌낵 ?쒖떆
            if "aux_bt_result" in st.session_state:
                _abr = st.session_state["aux_bt_result"]
                st.subheader("諛깊뀒?ㅽ듃 寃곌낵")
                m1, m2, m3, m4, m5, m6 = st.columns(6)
                m1.metric("珥??섏씡瑜?, f"{_abr['total_return']:.2f}%")
                m2.metric("CAGR", f"{_abr['cagr']:.2f}%")
                m3.metric("MDD", f"{_abr['mdd']:.2f}%")
                _calmar = abs(_abr['cagr'] / _abr['mdd']) if _abr['mdd'] != 0 else 0
                m4.metric("Calmar", f"{_calmar:.2f}")
                m5.metric("?밸쪧", f"{_abr['win_rate']:.1f}%")
                m6.metric("嫄곕옒 ?잛닔", f"{_abr['trade_count']}")
                _seed_mode_out = _abr.get("buy_seed_mode", aux_seed_mode)
                _seed_mode_kr = "?쇰씪誘몃뵫" if _seed_mode_out == "pyramiding" else "洹좊벑"
                st.caption(
                    f"寃利?吏?? Calmar={_calmar:.2f} | ?고룊洹쟋DD={_abr.get('avg_yearly_mdd', _abr['mdd']):.2f}% | "
                    f"?щ━?쇱?={aux_slippage:.2f}% | ?쒕뱶={_seed_mode_kr}"
                    + (f" x{_abr.get('pyramid_ratio', aux_pyramid_ratio):.2f}" if _seed_mode_out == "pyramiding" else "")
                )
                st.caption(f"?쒓컙遊??ㅼ젙: 蹂댁“ 留ㅻℓ={aux_interval} | 硫붿씤 ?좏샇={aux_main_interval}")

                # ?꾨왂 vs BTC(Buy&Hold) ?섏씡瑜?/ DD 李⑦듃
                _dates = _abr.get("dates")
                _strat_ret = _abr.get("strategy_return_curve")
                _bench_ret = _abr.get("benchmark_return_curve")
                _strat_dd = _abr.get("drawdown_curve")
                _bench_dd = _abr.get("benchmark_dd_curve")
                if _dates is not None and _strat_ret is not None and _bench_ret is not None:
                    _plot_df = pd.DataFrame({
                        "date": pd.to_datetime(_dates),
                        "strategy_return": np.asarray(_strat_ret, dtype=float),
                        "benchmark_return": np.asarray(_bench_ret, dtype=float),
                    }).dropna()
                    if not _plot_df.empty:
                        fig_ret = go.Figure()
                        fig_ret.add_trace(go.Scatter(
                            x=_plot_df["date"], y=_plot_df["strategy_return"],
                            mode="lines", name="?꾨왂 ?섏씡瑜?%)",
                            line=dict(color="royalblue", width=2)
                        ))
                        fig_ret.add_trace(go.Scatter(
                            x=_plot_df["date"], y=_plot_df["benchmark_return"],
                            mode="lines", name=f"{aux_ticker} ?섏씡瑜?%)",
                            line=dict(color="gray", width=1.5, dash="dot")
                        ))
                        fig_ret.update_layout(
                            title=dict(text="?꾨왂 ?섏씡瑜?vs 湲곗??먯궛(Buy&Hold)", x=0.0, xanchor="left"),
                            yaxis_title="?섏씡瑜?(%)",
                            height=360,
                            margin=dict(l=0, r=0, t=55, b=65),
                            legend=dict(
                                orientation="h",
                                yanchor="top",
                                y=-0.15,
                                xanchor="left",
                                x=0.0,
                                font=dict(size=12),
                            ),
                        )
                        st.plotly_chart(fig_ret, use_container_width=True)

                if _dates is not None and _strat_dd is not None:
                    _dd_df = pd.DataFrame({
                        "date": pd.to_datetime(_dates),
                        "strategy_dd": np.asarray(_strat_dd, dtype=float),
                        "benchmark_dd": np.asarray(_bench_dd, dtype=float) if _bench_dd is not None else np.nan,
                    }).dropna(subset=["strategy_dd"])
                    if not _dd_df.empty:
                        fig_dd = go.Figure()
                        fig_dd.add_trace(go.Scatter(
                            x=_dd_df["date"], y=_dd_df["strategy_dd"],
                            mode="lines", name="?꾨왂 DD(%)",
                            fill="tozeroy",
                            line=dict(color="crimson", width=1.5)
                        ))
                        if "benchmark_dd" in _dd_df.columns and _dd_df["benchmark_dd"].notna().any():
                            fig_dd.add_trace(go.Scatter(
                                x=_dd_df["date"], y=_dd_df["benchmark_dd"],
                                mode="lines", name=f"{aux_ticker} DD(%)",
                                line=dict(color="black", width=1.0, dash="dot")
                            ))
                        fig_dd.update_layout(
                            title=dict(text="DD(?숉룺) 鍮꾧탳", x=0.0, xanchor="left"),
                            yaxis_title="DD (%)",
                            height=300,
                            margin=dict(l=0, r=0, t=55, b=65),
                            legend=dict(
                                orientation="h",
                                yanchor="top",
                                y=-0.18,
                                xanchor="left",
                                x=0.0,
                                font=dict(size=12),
                            ),
                        )
                        st.plotly_chart(fig_dd, use_container_width=True)

                st.markdown(
                    """
**?됯? 吏???곸꽭 ?ㅻ챸 (諛깊뀒?ㅽ듃)**
- `珥??섏씡瑜?: ?쒖옉 ?먮낯 ?鍮?理쒖쥌 ?먮낯 利앷??⑥엯?덈떎. 湲곌컙 ?꾩껜???꾩쟻 ?깃낵瑜??섎??⑸땲??
- `CAGR`: 蹂듬━ 湲곗? ?고솚???섏씡瑜좎엯?덈떎. ?ъ옄 湲곌컙??湲????꾨왂???곌컙 ?깆옣?깆쓣 鍮꾧탳?섍린 醫뗭뒿?덈떎.
- `MDD`: 理쒕? ?숉룺(理쒕? ?먯떎 援ш컙)?낅땲?? ?덈뙎媛믪씠 ?댁닔濡??섎씫 由ъ뒪?ш? ?쎈땲??
- `Calmar`: `CAGR / |MDD|`濡?怨꾩궛?섎뒗 ?꾪뿕 ?鍮??섏씡 吏?쒖엯?덈떎. ?믪쓣?섎줉 ?⑥쑉?곸엯?덈떎.
- `?밸쪧`: ?꾩껜 泥?궛 嫄곕옒 以??댁씡?쇰줈 ?앸궃 嫄곕옒 鍮꾩쑉?낅땲??
- `嫄곕옒 ?잛닔`: 留ㅻℓ 鍮덈룄?낅땲?? 吏?섏튂寃?留롮쑝硫??섏닔猷뙿룹뒳由ы뵾吏 ?곹뼢??而ㅼ쭏 ???덉뒿?덈떎.
- `?꾨왂 ?섏씡瑜?vs 湲곗??먯궛`: ?꾨왂???⑥닚 蹂댁쑀(Buy&Hold) ?鍮??곗쐞?몄? ?뺤씤?섎뒗 鍮꾧탳 洹몃옒?꾩엯?덈떎.
- `DD(?숉룺) 鍮꾧탳`: ?섎씫 援ш컙?먯꽌 ?꾨왂 諛⑹뼱?μ씠 湲곗??먯궛 ?鍮??대뼡吏 ?뺤씤?섎뒗 洹몃옒?꾩엯?덈떎.
"""
                )

            st.divider()

            # ?? 理쒖쟻???ㅽ뻾 ??
            st.subheader("?썱截?蹂댁“ ?꾨왂 ?뚮씪誘명꽣 理쒖쟻??(Optuna)")
            st.caption("硫붿씤 ?꾨왂 ?뚮씪誘명꽣???꾩뿉???ㅼ젙??媛믪쓣 怨좎젙?섍퀬, 蹂댁“ ?꾨왂 ?뚮씪誘명꽣瑜?理쒖쟻?뷀빀?덈떎.")

            opt_aux_col1, opt_aux_col2, opt_aux_col3 = st.columns(3)
            with opt_aux_col1:
                _oa_ms_range = st.slider("?④린 ?댄룊 ?먯깋 踰붿쐞", 2, 60, (3, 20), key="oa_ms_range")
                _oa_ml_range = st.slider("以묎린 ?댄룊 ?먯깋 踰붿쐞", 5, 200, (10, 80), key="oa_ml_range")
            with opt_aux_col2:
                _oa_thr_range = st.slider("怨쇰ℓ???꾧퀎媛?踰붿쐞 (%)", -25.0, -0.5, (-15.0, -2.0), 0.5, key="oa_thr_range")
                _oa_split_range = st.slider("遺꾪븷 ?잛닔 踰붿쐞", 1, 20, (1, 7), key="oa_split_range")
            with opt_aux_col3:
                _oa_tp1_range = st.slider("TP1 踰붿쐞 (%)", 1.0, 20.0, (2.0, 8.0), 0.5, key="oa_tp1_range")
                _oa_tp2_range = st.slider("TP2 踰붿쐞 (%)", 3.0, 30.0, (5.0, 15.0), 0.5, key="oa_tp2_range")

            _oa_set1, _oa_set2, _oa_set3 = st.columns(3)
            _oa_trials = _oa_set1.number_input("?쒗뻾 ?잛닔", 50, 2000, 200, 50, key="oa_trials")
            _oa_metric = _oa_set2.selectbox("紐⑹쟻 ?⑥닔", ["Calmar", "Sharpe", "?섏씡瑜?, "MDD 理쒖냼"],
                                             key="oa_metric")
            _oa_min_trades = _oa_set3.number_input("理쒖냼 嫄곕옒?잛닔", 0, 500, 5, 1, key="oa_min_trades")
            _oa_metric_map = {"Calmar": "calmar", "Sharpe": "sharpe", "?섏씡瑜?: "return", "MDD 理쒖냼": "mdd"}

            _oa_tf_col1, _oa_tf_col2, _oa_tf_col3 = st.columns(3)
            _oa_optimize_tf = _oa_tf_col1.checkbox("?쒓컙遊?理쒖쟻???ы븿", value=True, key="oa_optimize_tf")
            if "oa_exec_iv_candidates" not in st.session_state:
                _def_exec_ivs = [aux_interval]
                if "30遺? in _aux_iv_options and "30遺? not in _def_exec_ivs:
                    _def_exec_ivs.append("30遺?)
                st.session_state["oa_exec_iv_candidates"] = _def_exec_ivs
            if "oa_main_iv_candidates" not in st.session_state:
                st.session_state["oa_main_iv_candidates"] = [aux_main_interval]
            _oa_exec_iv_candidates = _oa_tf_col2.multiselect(
                "蹂댁“ 留ㅻℓ ?쒓컙遊??꾨낫",
                _aux_iv_options,
                default=[aux_interval],
                key="oa_exec_iv_candidates",
            )
            _oa_main_iv_candidates = _oa_tf_col3.multiselect(
                "硫붿씤 ?좏샇 ?쒓컙遊??꾨낫",
                _aux_iv_options,
                default=[aux_main_interval],
                key="oa_main_iv_candidates",
            )

            if st.button("??蹂댁“ ?꾨왂 理쒖쟻???ㅽ뻾", type="primary", key="run_aux_opt"):
                with st.spinner("蹂댁“ ?꾨왂 Optuna 理쒖쟻??以?.."):
                    _exec_iv_list = list(dict.fromkeys(_oa_exec_iv_candidates)) if _oa_optimize_tf else [aux_interval]
                    _main_iv_list = list(dict.fromkeys(_oa_main_iv_candidates)) if _oa_optimize_tf else [aux_main_interval]
                    if not _exec_iv_list:
                        _exec_iv_list = [aux_interval]
                    if not _main_iv_list:
                        _main_iv_list = [aux_main_interval]

                    _pairs = [(e, m) for e in _exec_iv_list for m in _main_iv_list]
                    if len(_pairs) > 16:
                        st.warning(f"?쒓컙遊?議고빀??留롮븘 ?곸쐞 16媛?議고빀留??ㅽ뻾?⑸땲?? (?좏깮 {len(_pairs)}媛?")
                        _pairs = _pairs[:16]
                    if not _pairs:
                        st.error("理쒖쟻?뷀븷 ?쒓컙遊?議고빀???놁뒿?덈떎.")
                        _pairs = [(aux_interval, aux_main_interval)]

                    _total_trials = int(_oa_trials)
                    _base = _total_trials // len(_pairs)
                    _rem = _total_trials % len(_pairs)
                    _alloc = [_base + (1 if i < _rem else 0) for i in range(len(_pairs))]
                    _run_pairs = [(_pairs[i], _alloc[i]) for i in range(len(_pairs)) if _alloc[i] > 0]
                    if not _run_pairs:
                        st.error("?쒗뻾 ?잛닔媛 ?덈Т ?곸뼱 ?쒓컙遊?議고빀??諛곕텇?????놁뒿?덈떎.")
                        _run_pairs = [((_pairs[0][0], _pairs[0][1]), 1)]

                    _df_cache = {}

                    def _load_interval_df(_iv_label, _warmup):
                        _key = (_iv_label, int(_warmup))
                        if _key in _df_cache:
                            return _df_cache[_key]
                        _api = INTERVAL_MAP.get(_iv_label, "day")
                        _cnt = _count_from_start(_api, aux_start, warmup=int(_warmup), cap=12000)
                        _df = data_cache.load_cached(aux_ticker, _api)
                        if _df is None or len(_df) < 50:
                            _df = pyupbit.get_ohlcv(aux_ticker, interval=_api, count=_cnt)
                        _df_cache[_key] = _df
                        return _df

                    _opt_progress = st.progress(0, text="理쒖쟻???쒖옉...")
                    _done_trials = 0
                    _all_trials = []

                    for (_exec_iv, _main_iv), _n_trials_local in _run_pairs:
                        _df_exec = _load_interval_df(_exec_iv, 400)
                        _df_main = None
                        if _main_iv != _exec_iv:
                            _df_main = _load_interval_df(_main_iv, max(int(aux_main_buy), int(aux_main_sell), 30) + 400)

                        if _df_exec is None or len(_df_exec) < 50 or (_main_iv != _exec_iv and (_df_main is None or len(_df_main) < 50)):
                            _done_trials += _n_trials_local
                            _opt_progress.progress(
                                min(_done_trials / max(_total_trials, 1), 1.0),
                                text=f"[{_exec_iv}/{_main_iv}] ?곗씠??遺議깆쑝濡?嫄대꼫?",
                            )
                            continue

                        def _aux_opt_cb(current, total, msg, _exec=_exec_iv, _main=_main_iv, _done=_done_trials):
                            _ratio = (_done + min(max(current, 0), max(total, 1))) / max(_total_trials, 1)
                            _opt_progress.progress(min(_ratio, 1.0), text=f"[蹂댁“={_exec} | 硫붿씤={_main}] {msg}")

                        _res_local = backtest_engine.optimize_aux(
                            _df_exec,
                            main_strategy=aux_main_strat,
                            main_buy_p=aux_main_buy, main_sell_p=aux_main_sell,
                            ma_short_range=_oa_ms_range,
                            ma_long_range=_oa_ml_range,
                            threshold_range=_oa_thr_range,
                            tp1_range=_oa_tp1_range,
                            tp2_range=_oa_tp2_range,
                            split_count_range=_oa_split_range,
                            fee=aux_fee, slippage=aux_slippage,
                            start_date=str(aux_start),
                            initial_balance=initial_cap,
                            n_trials=int(_n_trials_local),
                            objective_metric=_oa_metric_map[_oa_metric],
                            progress_callback=_aux_opt_cb,
                            buy_seed_mode=aux_seed_mode,
                            pyramid_ratio=float(aux_pyramid_ratio),
                            main_df=_df_main,
                            min_trade_count=int(_oa_min_trades),
                        )
                        for _tr in _res_local.get("trials", []):
                            _tr["Exec Interval"] = _exec_iv
                            _tr["Main Interval"] = _main_iv
                        _all_trials.extend(_res_local.get("trials", []))
                        _done_trials += _n_trials_local
                        _opt_progress.progress(min(_done_trials / max(_total_trials, 1), 1.0),
                                               text=f"[蹂댁“={_exec_iv} | 硫붿씤={_main_iv}] ?꾨즺")

                    _opt_progress.empty()
                    if _all_trials:
                        _df_all = pd.DataFrame(_all_trials)
                        _sort_key = "score" if "score" in _df_all.columns else ("calmar" if "calmar" in _df_all.columns else None)
                        if _sort_key is not None:
                            _df_all = _df_all.sort_values(_sort_key, ascending=False).reset_index(drop=True)
                        _best_row = _df_all.iloc[0]
                        _best_params = {
                            "ma_short": int(_best_row.get("MA Short", 0)),
                            "ma_long": int(_best_row.get("MA Long", 0)),
                            "threshold": float(_best_row.get("Threshold", 0.0)),
                            "tp1_pct": float(_best_row.get("TP1 %", 0.0)),
                            "tp2_pct": float(_best_row.get("TP2 %", 0.0)),
                            "split_count": int(_best_row.get("Split", 1)),
                            "exec_interval": _best_row.get("Exec Interval", aux_interval),
                            "main_interval": _best_row.get("Main Interval", aux_main_interval),
                        }
                        st.session_state["aux_opt_result"] = {
                            "best_params": _best_params,
                            "best_value": float(_best_row.get(_sort_key, 0.0)) if _sort_key is not None else 0.0,
                            "trials": _all_trials,
                            "study": None,
                        }
                    else:
                        st.error("理쒖쟻??寃곌낵媛 ?놁뒿?덈떎. ?쒓컙遊??쒖옉??理쒖냼 嫄곕옒?잛닔瑜??뺤씤??二쇱꽭??")

            # 理쒖쟻??寃곌낵 ?쒖떆
            if "aux_opt_result" in st.session_state:
                _aor = st.session_state["aux_opt_result"]
                trials = _aor["trials"]
                if trials:
                    df_trials = pd.DataFrame(trials)
                    _min_trades_filter = int(st.session_state.get("oa_min_trades", 0))
                    # 理쒖쟻??寃利? ?몄젒 ?뚮씪誘명꽣??Calmar ?됯퇏(濡쒕쾭?ㅽ듃?덉뒪) 怨꾩궛
                    _pcols = ["MA Short", "MA Long", "Threshold", "TP1 %", "TP2 %", "Split"]
                    _have_cols = [c for c in _pcols if c in df_trials.columns]
                    if "Robustness" not in df_trials.columns and _have_cols and len(df_trials) >= 5:
                        _scaled = df_trials[_have_cols].copy()
                        for _c in _have_cols:
                            _std = _scaled[_c].std()
                            if _std and not np.isnan(_std) and _std > 0:
                                _scaled[_c] = (_scaled[_c] - _scaled[_c].mean()) / _std
                            else:
                                _scaled[_c] = 0.0

                        _calmar_vals = df_trials["calmar"].values if "calmar" in df_trials.columns else np.zeros(len(df_trials))
                        _rob_vals = []
                        _k = min(15, len(df_trials))
                        for _i in range(len(df_trials)):
                            _d = ((_scaled - _scaled.iloc[_i]) ** 2).sum(axis=1)
                            _near_idx = _d.nsmallest(_k).index
                            _rob_vals.append(float(np.mean(_calmar_vals[_near_idx])))
                        df_trials["Robustness"] = np.round(_rob_vals, 4)

                    _before_filter_n = len(df_trials)
                    if "trade_count" in df_trials.columns and _min_trades_filter > 0:
                        df_trials = df_trials[df_trials["trade_count"] >= _min_trades_filter].copy()
                    st.caption(
                        f"嫄곕옒?잛닔 ?꾪꽣: {_min_trades_filter}???댁긽 | "
                        f"?듦낵 {len(df_trials)}/{_before_filter_n} 議고빀"
                    )
                    if len(df_trials) == 0:
                        st.warning("嫄곕옒?잛닔 ?꾪꽣瑜?留뚯”?섎뒗 議고빀???놁뒿?덈떎. 理쒖냼 嫄곕옒?잛닔瑜???텛嫄곕굹 ?먯깋 踰붿쐞瑜??꾪솕??二쇱꽭??")

                    # ?뺣젹
                    sort_col = "calmar"
                    if sort_col in df_trials.columns:
                        df_trials = df_trials.sort_values(sort_col, ascending=False)

                    top20 = df_trials.head(20).reset_index(drop=True)
                    top20_disp = top20.copy()
                    if "Buy Seed Mode" in top20_disp.columns:
                        top20_disp["Buy Seed Mode"] = top20_disp["Buy Seed Mode"].astype(str).str.lower().map(
                            {"equal": "洹좊벑", "pyramiding": "?쇰씪誘몃뵫"}
                        ).fillna(top20_disp["Buy Seed Mode"])
                    top20_disp = top20_disp.rename(columns={
                        "Exec Interval": "蹂댁“ 留ㅻℓ ?쒓컙遊?,
                        "Main Interval": "硫붿씤 ?좏샇 ?쒓컙遊?,
                        "MA Short": "?④린 ?댄룊",
                        "MA Long": "以묎린 ?댄룊",
                        "Threshold": "怨쇰ℓ???꾧퀎媛?,
                        "TP1 %": "TP1(%)",
                        "TP2 %": "TP2(%)",
                        "Split": "遺꾪븷",
                        "Buy Seed Mode": "留ㅼ닔 ?쒕뱶 諛⑹떇",
                        "Pyramid Ratio": "?쇰씪誘몃뵫 諛곗쑉",
                        "total_return": "?섏씡瑜?%)",
                        "cagr": "CAGR(%)",
                        "mdd": "MDD(%)",
                        "calmar": "Calmar",
                        "Robustness": "寃ш퀬??Robustness)",
                        "sharpe": "Sharpe",
                        "win_rate": "?밸쪧(%)",
                        "trade_count": "嫄곕옒?잛닔",
                    })

                    # ?쒖떆??而щ읆
                    show_cols = [c for c in ["蹂댁“ 留ㅻℓ ?쒓컙遊?, "硫붿씤 ?좏샇 ?쒓컙遊?,
                                             "?④린 ?댄룊", "以묎린 ?댄룊", "怨쇰ℓ???꾧퀎媛?, "TP1(%)", "TP2(%)",
                                             "遺꾪븷", "留ㅼ닔 ?쒕뱶 諛⑹떇", "?쇰씪誘몃뵫 諛곗쑉",
                                             "?섏씡瑜?%)", "CAGR(%)", "MDD(%)", "Calmar", "寃ш퀬??Robustness)",
                                             "Sharpe", "?밸쪧(%)", "嫄곕옒?잛닔"] if c in top20_disp.columns]
                    st.subheader("理쒖쟻??寃곌낵 (Top 20)")
                    st.dataframe(
                        top20_disp[show_cols].style.format({
                            "怨쇰ℓ???꾧퀎媛?: "{:.1f}", "TP1(%)": "{:.1f}", "TP2(%)": "{:.1f}",
                            "?쇰씪誘몃뵫 諛곗쑉": "{:.2f}",
                            "?섏씡瑜?%)": "{:.2f}", "CAGR(%)": "{:.2f}", "MDD(%)": "{:.2f}",
                            "Calmar": "{:.3f}", "寃ш퀬??Robustness)": "{:.3f}",
                            "Sharpe": "{:.3f}", "?밸쪧(%)": "{:.1f}",
                        }),
                        use_container_width=True, height=500
                    )

                    # 理쒖쟻??寃利??붿빟
                    _val_df = df_trials.head(min(50, len(df_trials))).copy()
                    _cv_calmar = 0.0
                    _cv_cagr = 0.0
                    _cv_mdd = 0.0
                    if not _val_df.empty:
                        if "calmar" in _val_df.columns and abs(_val_df["calmar"].mean()) > 1e-9:
                            _cv_calmar = (_val_df["calmar"].std() / abs(_val_df["calmar"].mean())) * 100
                        if "cagr" in _val_df.columns and abs(_val_df["cagr"].mean()) > 1e-9:
                            _cv_cagr = (_val_df["cagr"].std() / abs(_val_df["cagr"].mean())) * 100
                        if "mdd" in _val_df.columns and abs(_val_df["mdd"].mean()) > 1e-9:
                            _cv_mdd = (_val_df["mdd"].std() / abs(_val_df["mdd"].mean())) * 100
                    def _cv_level(_v):
                        if np.isnan(_v):
                            return "怨꾩궛遺덇?"
                        if _v < 20:
                            return "?덉젙"
                        if _v < 40:
                            return "蹂댄넻"
                        return "誘쇨컧"

                    _vc1, _vc2, _vc3 = st.columns(3)
                    _vc1.metric("Calmar 蹂?숆퀎??CV, Top50)", f"{_cv_calmar:.1f}%")
                    _vc2.metric("CAGR 蹂?숆퀎??CV, Top50)", f"{_cv_cagr:.1f}%")
                    _vc3.metric("MDD 蹂?숆퀎??CV, Top50)", f"{_cv_mdd:.1f}%")
                    st.caption("CV(蹂?숆퀎?? = ?쒖??몄감 / |?됯퇏| 횞 100. ??쓣?섎줉 ?뚮씪誘명꽣 蹂?붿뿉 ?붽컧?섍퀬 ?덉젙?곸엯?덈떎.")
                    st.info(
                        f"?댁꽍: Calmar CV {_cv_calmar:.1f}%({_cv_level(_cv_calmar)}), "
                        f"CAGR CV {_cv_cagr:.1f}%({_cv_level(_cv_cagr)}), "
                        f"MDD CV {_cv_mdd:.1f}%({_cv_level(_cv_mdd)})"
                    )
                    st.markdown(
                        """
**?됯? 吏???곸꽭 ?ㅻ챸 (理쒖쟻??寃利?**
- `蹂?숆퀎??CV)`: `?쒖??몄감 / |?됯퇏| 횞 100`?낅땲?? 媛숈? ?깃낵 ?됯퇏?대씪??CV媛 ??쓣?섎줉 ?뚮씪誘명꽣 誘쇨컧?꾧? ??븘 ?ㅼ쟾 ?ы쁽?깆씠 醫뗭뒿?덈떎.
- `Calmar CV`: ?섏씡-由ъ뒪???⑥쑉(Calmar)???덉젙?깆엯?덈떎. ??쓣?섎줉 二쇰? ?뚮씪誘명꽣?먯꽌???깃낵媛 ???붾뱾由쎈땲??
- `CAGR CV`: ?고솚???섏씡瑜좎쓽 ?덉젙?깆엯?덈떎. ??쓣?섎줉 ?섏씡瑜좎씠 ?뚮씪誘명꽣 蹂?붿뿉 ??誘쇨컧?⑸땲??
- `MDD CV`: ?숉룺???덉젙?깆엯?덈떎. ??쓣?섎줉 由ъ뒪?ш? ?뚮씪誘명꽣 蹂?붿뿉 ??誘쇨컧?⑸땲??
- `寃ш퀬??Robustness)`: ?좏깮 議고빀 二쇰? ?댁썐?ㅼ쓽 Calmar ?됯퇏?낅땲?? ?믪쓣?섎줉 '毓곗”??????理쒖쟻??媛 ?꾨땺 媛?μ꽦???쎈땲??
- `Top 20 ??: ?⑥씪 理쒓퀬媛믩낫???곸쐞 議고빀??遺꾪룷瑜??④퍡 蹂닿퀬, ?섏씡瑜졖텺DD쨌寃ш퀬?깆쓽 洹좏삎??醫뗭? 議고빀???좏깮?섎뒗 ???ъ슜?⑸땲??
"""
                    )

                    # Best params (嫄곕옒?잛닔 ?꾪꽣 諛섏쁺)
                    if len(top20) > 0:
                        _best_row = top20.iloc[0]
                        _seed_mode_best = str(_best_row.get("Buy Seed Mode", "equal")).lower()
                        _seed_mode_kr_for_opt = "?쇰씪誘몃뵫" if _seed_mode_best == "pyramiding" else "洹좊벑"
                        st.success(
                            f"理쒖쟻 ?뚮씪誘명꽣(嫄곕옒?잛닔 ?꾪꽣 諛섏쁺): "
                            f"蹂댁“?쒓컙遊?{_best_row.get('Exec Interval', aux_interval)}, "
                            f"硫붿씤?쒓컙遊?{_best_row.get('Main Interval', aux_main_interval)} | "
                            f"MA Short={int(_best_row.get('MA Short', 0))}, "
                            f"MA Long={int(_best_row.get('MA Long', 0))}, "
                            f"Threshold={float(_best_row.get('Threshold', 0.0)):.1f}, "
                            f"TP1={float(_best_row.get('TP1 %', 0.0)):.1f}%, "
                            f"TP2={float(_best_row.get('TP2 %', 0.0)):.1f}%, "
                            f"遺꾪븷={int(_best_row.get('Split', 1))}??| ?쒕뱶={_seed_mode_kr_for_opt}"
                            + (
                                f" x{float(_best_row.get('Pyramid Ratio', 1.0)):.2f}"
                                if _seed_mode_best == "pyramiding" else ""
                            )
                            + f" | 嫄곕옒?잛닔={int(_best_row.get('trade_count', 0))}??
                        )
                    else:
                        st.warning("嫄곕옒?잛닔 ?꾪꽣瑜?留뚯”?섎뒗 理쒖쟻 ?뚮씪誘명꽣媛 ?놁뒿?덈떎.")

                    # ?좏깮 ??諛깊뀒?ㅽ듃 ?곌껐
                    st.subheader("?좏깮 ?뚮씪誘명꽣濡?諛깊뀒?ㅽ듃 ?ㅽ뻾")
                    if len(top20) > 0:
                        _opt_labels = [
                            (
                                f"[蹂댁“={row.get('Exec Interval', aux_interval)} | 硫붿씤={row.get('Main Interval', aux_main_interval)}] "
                                f"#{i+1}: MA({int(row.get('MA Short', 0))},{int(row.get('MA Long', 0))}) "
                                f"Thr={row.get('Threshold', 0):.1f}% "
                                f"TP={row.get('TP1 %', 0):.1f}/{row.get('TP2 %', 0):.1f}% "
                                f"Split={int(row.get('Split', 2))} "
                                f"Seed={'?쇰씪誘몃뵫' if row.get('Buy Seed Mode', 'equal') == 'pyramiding' else '洹좊벑'}"
                                + (f"x{row.get('Pyramid Ratio', 1.0):.2f} " if row.get('Buy Seed Mode', 'equal') == 'pyramiding' else " ")
                                + f"???섏씡 {row.get('total_return', 0):.1f}% "
                                + f"Calmar {row.get('calmar', 0):.2f} "
                                + f"Rob {row.get('Robustness', 0):.2f} "
                                + f"嫄곕옒 {int(row.get('trade_count', 0))}??
                            )
                            for i, row in top20.iterrows()
                        ]
                        _sel_idx = st.selectbox("?뚮씪誘명꽣 ?좏깮", range(len(_opt_labels)),
                                                format_func=lambda x: _opt_labels[x],
                                                key="aux_opt_select")

                        # ?좏깮 議고빀 二쇰? ?깅뒫 寃利?
                        _sel_row_prev = top20.iloc[_sel_idx]
                        with st.expander("?뵇 ?좏깮 議고빀 二쇰? 寃利?, expanded=False):
                            if all(c in df_trials.columns for c in _pcols):
                                _q = df_trials.copy()
                                _mask = (
                                    (_q["MA Short"].between(_sel_row_prev["MA Short"] - 2, _sel_row_prev["MA Short"] + 2)) &
                                    (_q["MA Long"].between(_sel_row_prev["MA Long"] - 5, _sel_row_prev["MA Long"] + 5)) &
                                    (_q["Threshold"].between(_sel_row_prev["Threshold"] - 1.0, _sel_row_prev["Threshold"] + 1.0)) &
                                    (_q["TP1 %"].between(_sel_row_prev["TP1 %"] - 1.0, _sel_row_prev["TP1 %"] + 1.0)) &
                                    (_q["TP2 %"].between(_sel_row_prev["TP2 %"] - 1.0, _sel_row_prev["TP2 %"] + 1.0)) &
                                    (_q["Split"].between(_sel_row_prev["Split"] - 1, _sel_row_prev["Split"] + 1))
                                )
                                _near = _q[_mask]
                                if len(_near) >= 3:
                                    _n1, _n2, _n3 = st.columns(3)
                                    _n1.metric("二쇰? ?됯퇏 Calmar", f"{_near['calmar'].mean():.2f}")
                                    _n2.metric("二쇰? ?됯퇏 ?섏씡瑜?, f"{_near['total_return'].mean():.2f}%")
                                    _n3.metric("二쇰? ?됯퇏 MDD", f"{_near['mdd'].mean():.2f}%")
                                    _near_show_cols = [c for c in ["MA Short", "MA Long", "Threshold", "TP1 %", "TP2 %", "Split", "total_return", "calmar", "mdd"] if c in _near.columns]
                                    st.dataframe(_near[_near_show_cols].head(20), use_container_width=True, hide_index=True)
                                else:
                                    st.info("二쇰? 議고빀???곸뼱 ?듦퀎 寃利앹쓣 ?앸왂?덉뒿?덈떎.")
                            else:
                                st.info("寃利앹뿉 ?꾩슂??而щ읆??遺議깊빀?덈떎.")

                        if st.button("???뚮씪誘명꽣濡?諛깊뀒?ㅽ듃 ?ㅽ뻾", key="aux_opt_bt_run"):
                            _sel_row = top20.iloc[_sel_idx]
                            _seed_mode_raw = str(_sel_row.get("Buy Seed Mode", "equal")).lower()
                            _seed_mode_label = "?쇰씪誘몃뵫 留ㅼ닔" if _seed_mode_raw == "pyramiding" else "洹좊벑 留ㅼ닔"
                            st.session_state["aux_apply_params"] = {
                                "aux_interval": str(_sel_row.get("Exec Interval", aux_interval)),
                                "aux_main_interval": str(_sel_row.get("Main Interval", aux_main_interval)),
                                "aux_ma_short": int(_sel_row.get("MA Short", aux_ma_short)),
                                "aux_ma_long": int(_sel_row.get("MA Long", aux_ma_long)),
                                "aux_threshold": float(_sel_row.get("Threshold", aux_threshold)),
                                "aux_tp1": float(_sel_row.get("TP1 %", aux_tp1)),
                                "aux_tp2": float(_sel_row.get("TP2 %", aux_tp2)),
                                "aux_split": int(_sel_row.get("Split", aux_split)),
                                "aux_seed_mode": _seed_mode_label,
                            }
                            if _seed_mode_raw == "pyramiding":
                                _pr = _sel_row.get("Pyramid Ratio", aux_pyramid_ratio)
                                try:
                                    _pr = float(_pr)
                                except Exception:
                                    _pr = float(aux_pyramid_ratio)
                                if np.isnan(_pr):
                                    _pr = float(aux_pyramid_ratio)
                                st.session_state["aux_apply_params"]["aux_pyramid_ratio"] = float(np.clip(_pr, 1.05, 3.00))
                            # 理쒖쟻????利됱떆 ?щ갚?뚯뒪??
                            st.session_state["aux_run_backtest_now"] = True
                            st.rerun()

        # === ?쒕툕??: ?꾩껜 醫낅ぉ ?ㅼ틪 ===
        with bt_sub3:
            st.header("?꾩껜 醫낅ぉ ?ㅼ틪")
            st.caption("?곸쐞 醫낅ぉ?????쒓컙?/?꾨왂?쇰줈 諛깊뀒?ㅽ듃?섏뿬 Calmar ?쒖쑝濡??뺣젹?⑸땲??")

            # ?ㅼ틪 ?ㅼ젙
            scan_col1, scan_col2, scan_col3 = st.columns(3)
            scan_strategy = scan_col1.selectbox("?꾨왂", ["SMA", "Donchian"], key="scan_strat")
            scan_period = scan_col2.number_input("湲곌컙 (Period)", 5, 300, 20, key="scan_period")
            scan_count = scan_col3.number_input("諛깊뀒?ㅽ듃 罹붾뱾 ??, 200, 10000, 2000, step=200, key="scan_count")

            scan_col4, scan_col5 = st.columns(2)
            scan_intervals = scan_col4.multiselect(
                "?쒓컙遊?, list(INTERVAL_MAP.keys()),
                default=["?쇰큺", "4?쒓컙", "1?쒓컙"],
                key="scan_intervals"
            )
            sell_ratio = 0.5
            if scan_strategy == "Donchian":
                sell_ratio = st.slider("留ㅻ룄 梨꾨꼸 鍮꾩쑉", 0.1, 1.0, 0.5, 0.1, key="scan_sell_ratio")

            st.caption(f"??? ?쒓?珥앹븸 ?곸쐞 {len(TOP_20_TICKERS)}媛???{', '.join(t.replace('KRW-','') for t in TOP_20_TICKERS)}")

            if st.button("?뵇 ?ㅼ틪 ?쒖옉", key="scan_run", type="primary"):
                engine = BacktestEngine()
                top_tickers = TOP_20_TICKERS

                if top_tickers:
                    interval_apis = [INTERVAL_MAP[k] for k in scan_intervals]
                    total_jobs = len(top_tickers) * len(interval_apis)
                    st.write(f"醫낅ぉ {len(top_tickers)}媛?횞 ?쒓컙遊?{len(interval_apis)}媛?= 珥?**{total_jobs}嫄?* 諛깊뀒?ㅽ듃")

                    progress_bar = st.progress(0)
                    status_text = st.empty()
                    results = []
                    done = 0

                    for ticker in top_tickers:
                        for interval_api in interval_apis:
                            done += 1
                            interval_label = INTERVAL_REV_MAP.get(interval_api, interval_api)
                            status_text.text(f"[{done}/{total_jobs}] {ticker} ({interval_label})")
                            progress_bar.progress(done / total_jobs)

                            try:
                                # ?곗씠??議고쉶 (罹먯떆 ?곗꽑)
                                df = data_cache.get_ohlcv_cached(ticker, interval=interval_api, count=scan_count)
                                if df is None or len(df) < scan_period + 10:
                                    continue

                                df = df.copy()

                                # ?쒓렇???앹꽦
                                if scan_strategy == "Donchian":
                                    strat = DonchianStrategy()
                                    sell_p = max(5, int(scan_period * sell_ratio))
                                    df = strat.create_features(df, buy_period=scan_period, sell_period=sell_p)
                                    signal_arr = np.zeros(len(df), dtype=np.int8)
                                    upper_col = f'Donchian_Upper_{scan_period}'
                                    lower_col = f'Donchian_Lower_{sell_p}'
                                    if upper_col in df.columns and lower_col in df.columns:
                                        signal_arr[df['close'].values > df[upper_col].values] = 1
                                        signal_arr[df['close'].values < df[lower_col].values] = -1
                                    else:
                                        continue
                                else:
                                    sma_vals = df['close'].rolling(window=scan_period).mean().values
                                    close_vals = df['close'].values
                                    signal_arr = np.zeros(len(df), dtype=np.int8)
                                    valid = ~np.isnan(sma_vals)
                                    signal_arr[valid & (close_vals > sma_vals)] = 1
                                    signal_arr[valid & (close_vals <= sma_vals)] = -1

                                open_arr = df['open'].values
                                close_arr = df['close'].values

                                # 怨좎냽 ?쒕??덉씠??
                                res = engine._fast_simulate(open_arr, close_arr, signal_arr, fee=0.0005, slippage=0.0, initial_balance=1000000)

                                # Buy & Hold ?섏씡瑜?
                                bnh_return = (close_arr[-1] / close_arr[0] - 1) * 100

                                # Calmar = CAGR / |MDD| (MDD媛 0?대㈃ inf 諛⑹?)
                                calmar = abs(res['cagr'] / res['mdd']) if res['mdd'] != 0 else 0

                                results.append({
                                    '醫낅ぉ': ticker,
                                    '?쒓컙遊?: interval_label,
                                    'CAGR (%)': round(res['cagr'], 2),
                                    'MDD (%)': round(res['mdd'], 2),
                                    'Calmar': round(calmar, 2),
                                    '?섏씡瑜?(%)': round(res['total_return'], 2),
                                    'B&H (%)': round(bnh_return, 2),
                                    '珥덇낵?섏씡 (%)': round(res['total_return'] - bnh_return, 2),
                                    '?밸쪧 (%)': round(res['win_rate'], 1),
                                    '嫄곕옒??: res['trade_count'],
                                    'Sharpe': round(res['sharpe'], 2),
                                    '罹붾뱾??: len(df),
                                })
                            except Exception:
                                continue

                    progress_bar.progress(1.0)
                    status_text.text(f"?꾨즺! {len(results)}嫄?寃곌낵")

                    if results:
                        df_results = pd.DataFrame(results)
                        df_results = df_results.sort_values('Calmar', ascending=False).reset_index(drop=True)
                        df_results.index = df_results.index + 1  # 1遺???쒖옉
                        df_results.index.name = "?쒖쐞"

                        # ?붿빟
                        st.success(f"?ㅼ틪 ?꾨즺: {len(results)}嫄?以??섏씡 {len(df_results[df_results['?섏씡瑜?(%)'] > 0])}嫄? ?먯떎 {len(df_results[df_results['?섏씡瑜?(%)'] <= 0])}嫄?)

                        # Calmar ?곸쐞 寃곌낵 ?뚯씠釉?
                        st.dataframe(
                            df_results.style.format({
                                'CAGR (%)': '{:.2f}',
                                'MDD (%)': '{:.2f}',
                                'Calmar': '{:.2f}',
                                '?섏씡瑜?(%)': '{:.2f}',
                                'B&H (%)': '{:.2f}',
                                '珥덇낵?섏씡 (%)': '{:.2f}',
                                '?밸쪧 (%)': '{:.1f}',
                                'Sharpe': '{:.2f}',
                            }).background_gradient(cmap='RdYlGn', subset=['Calmar', '珥덇낵?섏씡 (%)'])
                            .background_gradient(cmap='RdYlGn_r', subset=['MDD (%)']),
                            use_container_width=True,
                            height=700,
                        )

                        # ?꾨왂蹂??쒓컙遊됰퀎 ?붿빟
                        st.divider()
                        sum_col1, sum_col2 = st.columns(2)
                        with sum_col1:
                            st.caption("?쒓컙遊됰퀎 ?됯퇏 Calmar")
                            interval_summary = df_results.groupby('?쒓컙遊?).agg(
                                Calmar_?됯퇏=('Calmar', 'mean'),
                                ?섏씡瑜??됯퇏=('?섏씡瑜?(%)', 'mean'),
                                醫낅ぉ??('醫낅ぉ', 'count')
                            ).sort_values('Calmar_?됯퇏', ascending=False)
                            st.dataframe(interval_summary.style.format({'Calmar_?됯퇏': '{:.2f}', '?섏씡瑜??됯퇏': '{:.2f}'}), use_container_width=True)

                        with sum_col2:
                            st.caption("醫낅ぉ蹂?理쒓퀬 Calmar ?쒓컙遊?)
                            best_per_ticker = df_results.loc[df_results.groupby('醫낅ぉ')['Calmar'].idxmax()][['醫낅ぉ', '?쒓컙遊?, 'Calmar', '?섏씡瑜?(%)', 'MDD (%)']].reset_index(drop=True)
                            best_per_ticker.index = best_per_ticker.index + 1
                            st.dataframe(best_per_ticker.style.format({'Calmar': '{:.2f}', '?섏씡瑜?(%)': '{:.2f}', 'MDD (%)': '{:.2f}'}), use_container_width=True)
                    else:
                        st.warning("寃곌낵媛 ?놁뒿?덈떎. ?곗씠???ㅼ슫濡쒕뱶媛 ?꾩슂?????덉뒿?덈떎.")


if __name__ == "__main__":
    if "cache_warmed" not in st.session_state:
        warm_up_cache()
        st.session_state["cache_warmed"] = True
    main()

